# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE user_id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE user_id = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                },
                {
                    # data to create a User record
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'user_id': 'ggciceaie',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'user_id': 'bbehjachib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'user_id': 'cadfabfehe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the user_id field
        users = await User.prisma().find_many(
            take=5,
            order={
                'user_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the user_id field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'user_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the user_id field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'user_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'user_id': 'dgiiaaijj',
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'user_id': 'bfaiacjjfc',
            },
            data={
                'create': {
                    'user_id': 'bfaiacjjfc',
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'user_id': 'eigcfgbif'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'user_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'user_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by user_id values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['user_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LandActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Land]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Land.prisma().query_raw(
            'SELECT * FROM Land WHERE land_id = $1',
            'bagcfbhiig',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Land
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Land.prisma().query_first(
            'SELECT * FROM Land WHERE latitude = $1',
            267834847.18017,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LandCreateInput,
        include: Optional[types.LandInclude] = None
    ) -> _PrismaModelT:
        """Create a new Land record.

        Parameters
        ----------
        data
            Land record data
        include
            Specifies which relations should be loaded on the returned Land model

        Returns
        -------
        prisma.models.Land
            The created Land record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Land record from just the required fields
        land = await Land.prisma().create(
            data={
                # data to create a Land record
                'latitude': 836760821.59533,
                'longitude': 790425851.211191,
                'land_size': 1149758321.164428,
                'ph_level': 1388290519.164741,
                'phosphorus': 1675546029.176727,
                'potassium': 326272115.134320,
                'oxygen_level': 675780521.74496,
                'nitrogen': 1969681615.111617,
                'user_id': 'igbehcbab',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LandCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Land records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Land record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Land.prisma().create_many(
            data=[
                {
                    # data to create a Land record
                    'latitude': 1303003706.168663,
                    'longitude': 2000430152.186814,
                    'land_size': 1860847622.144852,
                    'ph_level': 1628650740.124960,
                    'phosphorus': 835903122.76371,
                    'potassium': 429995104.177581,
                    'oxygen_level': 893145566.99540,
                    'nitrogen': 2102736524.27152,
                    'user_id': 'efggddide',
                },
                {
                    # data to create a Land record
                    'latitude': 2058258651.158368,
                    'longitude': 878442065.167528,
                    'land_size': 1627576247.205480,
                    'ph_level': 60335757.68446,
                    'phosphorus': 1625503827.52182,
                    'potassium': 1266032265.9325,
                    'oxygen_level': 2053047983.68533,
                    'nitrogen': 127474245.94892,
                    'user_id': 'bjgejjabff',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LandWhereUniqueInput,
        include: Optional[types.LandInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Land record.

        Parameters
        ----------
        where
            Land filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Land model

        Returns
        -------
        prisma.models.Land
            The deleted Land record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        land = await Land.prisma().delete(
            where={
                'land_id': 'bcciijbibg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LandWhereUniqueInput,
        include: Optional[types.LandInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Land record.

        Parameters
        ----------
        where
            Land filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Land model

        Returns
        -------
        prisma.models.Land
            The found Land record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        land = await Land.prisma().find_unique(
            where={
                'land_id': 'cffcachfd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LandWhereUniqueInput,
        include: Optional[types.LandInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Land record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Land filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Land model

        Returns
        -------
        prisma.models.Land
            The found Land record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        land = await Land.prisma().find_unique_or_raise(
            where={
                'land_id': 'bccdfhdigc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LandWhereInput] = None,
        cursor: Optional[types.LandWhereUniqueInput] = None,
        include: Optional[types.LandInclude] = None,
        order: Optional[Union[types.LandOrderByInput, List[types.LandOrderByInput]]] = None,
        distinct: Optional[List[types.LandScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Land records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Land records returned
        skip
            Ignore the first N results
        where
            Land filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Land model
        order
            Order the returned Land records by any field
        distinct
            Filter Land records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Land]
            The list of all Land records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Land records
        lands = await Land.prisma().find_many(take=10)

        # find the first 5 Land records ordered by the longitude field
        lands = await Land.prisma().find_many(
            take=5,
            order={
                'longitude': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LandWhereInput] = None,
        cursor: Optional[types.LandWhereUniqueInput] = None,
        include: Optional[types.LandInclude] = None,
        order: Optional[Union[types.LandOrderByInput, List[types.LandOrderByInput]]] = None,
        distinct: Optional[List[types.LandScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Land record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Land filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Land model
        order
            Order the returned Land records by any field
        distinct
            Filter Land records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Land
            The first Land record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Land record ordered by the land_size field
        land = await Land.prisma().find_first(
            skip=1,
            order={
                'land_size': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LandWhereInput] = None,
        cursor: Optional[types.LandWhereUniqueInput] = None,
        include: Optional[types.LandInclude] = None,
        order: Optional[Union[types.LandOrderByInput, List[types.LandOrderByInput]]] = None,
        distinct: Optional[List[types.LandScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Land record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Land filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Land model
        order
            Order the returned Land records by any field
        distinct
            Filter Land records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Land
            The first Land record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Land record ordered by the land_name field
        land = await Land.prisma().find_first_or_raise(
            skip=1,
            order={
                'land_name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LandUpdateInput,
        where: types.LandWhereUniqueInput,
        include: Optional[types.LandInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Land record.

        Parameters
        ----------
        data
            Land record data specifying what to update
        where
            Land filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Land model

        Returns
        -------
        prisma.models.Land
            The updated Land record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        land = await Land.prisma().update(
            where={
                'land_id': 'febcgjbfj',
            },
            data={
                # data to update the Land record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LandWhereUniqueInput,
        data: types.LandUpsertInput,
        include: Optional[types.LandInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Land filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Land model

        Returns
        -------
        prisma.models.Land
            The created or updated Land record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        land = await Land.prisma().upsert(
            where={
                'land_id': 'bageiegghg',
            },
            data={
                'create': {
                    'land_id': 'bageiegghg',
                    'latitude': 2058258651.158368,
                    'longitude': 878442065.167528,
                    'land_size': 1627576247.205480,
                    'ph_level': 60335757.68446,
                    'phosphorus': 1625503827.52182,
                    'potassium': 1266032265.9325,
                    'oxygen_level': 2053047983.68533,
                    'nitrogen': 127474245.94892,
                    'user_id': 'bjgejjabff',
                },
                'update': {
                    'latitude': 2058258651.158368,
                    'longitude': 878442065.167528,
                    'land_size': 1627576247.205480,
                    'ph_level': 60335757.68446,
                    'phosphorus': 1625503827.52182,
                    'potassium': 1266032265.9325,
                    'oxygen_level': 2053047983.68533,
                    'nitrogen': 127474245.94892,
                    'user_id': 'bjgejjabff',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LandUpdateManyMutationInput,
        where: types.LandWhereInput,
    ) -> int:
        """Update multiple Land records

        Parameters
        ----------
        data
            Land data to update the selected Land records to
        where
            Filter to select the Land records to update

        Returns
        -------
        int
            The total number of Land records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Land records
        total = await Land.prisma().update_many(
            data={
                'land_image': 'faidicegb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LandWhereInput] = None,
        cursor: Optional[types.LandWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Land records present in the database

        Parameters
        ----------
        select
            Select the Land fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Land filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LandCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Land.prisma().count()

        # results: prisma.types.LandCountAggregateOutput
        results = await Land.prisma().count(
            select={
                '_all': True,
                'ph_level': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LandCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LandWhereInput] = None,
        cursor: Optional[types.LandWhereUniqueInput] = None,
    ) -> types.LandCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LandCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LandWhereInput] = None,
        cursor: Optional[types.LandWhereUniqueInput] = None,
    ) -> Union[int, types.LandCountAggregateOutput]:
        """Count the number of Land records present in the database

        Parameters
        ----------
        select
            Select the Land fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Land filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LandCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Land.prisma().count()

        # results: prisma.types.LandCountAggregateOutput
        results = await Land.prisma().count(
            select={
                '_all': True,
                'phosphorus': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LandCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LandWhereInput] = None
    ) -> int:
        """Delete multiple Land records.

        Parameters
        ----------
        where
            Optional Land filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Land records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Land records
        total = await Land.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LandScalarFieldKeys'],
        *,
        where: Optional['types.LandWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LandAvgAggregateInput'] = None,
        sum: Optional['types.LandSumAggregateInput'] = None,
        min: Optional['types.LandMinAggregateInput'] = None,
        max: Optional['types.LandMaxAggregateInput'] = None,
        having: Optional['types.LandScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LandCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LandScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LandScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LandGroupByOutput']:
        """Group Land records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Land fields to group records by
        where
            Land filter to select records
        take
            Limit the maximum number of Land records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LandGroupByOutput]
            A list of dictionaries representing the Land record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Land records by potassium values
        # and count how many records are in each group
        results = await Land.prisma().group_by(
            ['potassium'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LandStatisticActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LandStatistic]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LandStatistic.prisma().query_raw(
            'SELECT * FROM LandStatistic WHERE land_stat_id = $1',
            'bacecgfhbe',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LandStatistic
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LandStatistic.prisma().query_first(
            'SELECT * FROM LandStatistic WHERE land_use = $1',
            872078403.187474,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LandStatisticCreateInput,
        include: Optional[types.LandStatisticInclude] = None
    ) -> _PrismaModelT:
        """Create a new LandStatistic record.

        Parameters
        ----------
        data
            LandStatistic record data
        include
            Specifies which relations should be loaded on the returned LandStatistic model

        Returns
        -------
        prisma.models.LandStatistic
            The created LandStatistic record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LandStatistic record from just the required fields
        landstatistic = await LandStatistic.prisma().create(
            data={
                # data to create a LandStatistic record
                'land_use': 916896761.76926,
                'human_coverage': 820312479.9272,
                'water_availability': 344858293.112174,
                'distribution_optimality': 1495896251.20852,
                'land_id': 'igaibbfgj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LandStatisticCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LandStatistic records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LandStatistic record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LandStatistic.prisma().create_many(
            data=[
                {
                    # data to create a LandStatistic record
                    'land_use': 1660932118.52576,
                    'human_coverage': 736209796.49390,
                    'water_availability': 639686562.65400,
                    'distribution_optimality': 1905261552.7874,
                    'land_id': 'bdjidcidac',
                },
                {
                    # data to create a LandStatistic record
                    'land_use': 856000655.145233,
                    'human_coverage': 1573199653.201390,
                    'water_availability': 500965035.180062,
                    'distribution_optimality': 2077067425.167211,
                    'land_id': 'jcgghhgdj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LandStatisticWhereUniqueInput,
        include: Optional[types.LandStatisticInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LandStatistic record.

        Parameters
        ----------
        where
            LandStatistic filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LandStatistic model

        Returns
        -------
        prisma.models.LandStatistic
            The deleted LandStatistic record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        landstatistic = await LandStatistic.prisma().delete(
            where={
                'land_stat_id': 'beehgcebbg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LandStatisticWhereUniqueInput,
        include: Optional[types.LandStatisticInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LandStatistic record.

        Parameters
        ----------
        where
            LandStatistic filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LandStatistic model

        Returns
        -------
        prisma.models.LandStatistic
            The found LandStatistic record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        landstatistic = await LandStatistic.prisma().find_unique(
            where={
                'land_stat_id': 'bhdiaidiaf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LandStatisticWhereUniqueInput,
        include: Optional[types.LandStatisticInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LandStatistic record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LandStatistic filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LandStatistic model

        Returns
        -------
        prisma.models.LandStatistic
            The found LandStatistic record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        landstatistic = await LandStatistic.prisma().find_unique_or_raise(
            where={
                'land_stat_id': 'deajegcfi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LandStatisticWhereInput] = None,
        cursor: Optional[types.LandStatisticWhereUniqueInput] = None,
        include: Optional[types.LandStatisticInclude] = None,
        order: Optional[Union[types.LandStatisticOrderByInput, List[types.LandStatisticOrderByInput]]] = None,
        distinct: Optional[List[types.LandStatisticScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LandStatistic records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LandStatistic records returned
        skip
            Ignore the first N results
        where
            LandStatistic filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LandStatistic model
        order
            Order the returned LandStatistic records by any field
        distinct
            Filter LandStatistic records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LandStatistic]
            The list of all LandStatistic records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LandStatistic records
        landstatistics = await LandStatistic.prisma().find_many(take=10)

        # find the first 5 LandStatistic records ordered by the human_coverage field
        landstatistics = await LandStatistic.prisma().find_many(
            take=5,
            order={
                'human_coverage': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LandStatisticWhereInput] = None,
        cursor: Optional[types.LandStatisticWhereUniqueInput] = None,
        include: Optional[types.LandStatisticInclude] = None,
        order: Optional[Union[types.LandStatisticOrderByInput, List[types.LandStatisticOrderByInput]]] = None,
        distinct: Optional[List[types.LandStatisticScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LandStatistic record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LandStatistic filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LandStatistic model
        order
            Order the returned LandStatistic records by any field
        distinct
            Filter LandStatistic records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LandStatistic
            The first LandStatistic record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LandStatistic record ordered by the water_availability field
        landstatistic = await LandStatistic.prisma().find_first(
            skip=1,
            order={
                'water_availability': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LandStatisticWhereInput] = None,
        cursor: Optional[types.LandStatisticWhereUniqueInput] = None,
        include: Optional[types.LandStatisticInclude] = None,
        order: Optional[Union[types.LandStatisticOrderByInput, List[types.LandStatisticOrderByInput]]] = None,
        distinct: Optional[List[types.LandStatisticScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LandStatistic record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LandStatistic filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LandStatistic model
        order
            Order the returned LandStatistic records by any field
        distinct
            Filter LandStatistic records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LandStatistic
            The first LandStatistic record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LandStatistic record ordered by the distribution_optimality field
        landstatistic = await LandStatistic.prisma().find_first_or_raise(
            skip=1,
            order={
                'distribution_optimality': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LandStatisticUpdateInput,
        where: types.LandStatisticWhereUniqueInput,
        include: Optional[types.LandStatisticInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LandStatistic record.

        Parameters
        ----------
        data
            LandStatistic record data specifying what to update
        where
            LandStatistic filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LandStatistic model

        Returns
        -------
        prisma.models.LandStatistic
            The updated LandStatistic record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        landstatistic = await LandStatistic.prisma().update(
            where={
                'land_stat_id': 'gabahhhjf',
            },
            data={
                # data to update the LandStatistic record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LandStatisticWhereUniqueInput,
        data: types.LandStatisticUpsertInput,
        include: Optional[types.LandStatisticInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LandStatistic filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LandStatistic model

        Returns
        -------
        prisma.models.LandStatistic
            The created or updated LandStatistic record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        landstatistic = await LandStatistic.prisma().upsert(
            where={
                'land_stat_id': 'cjagadcjg',
            },
            data={
                'create': {
                    'land_stat_id': 'cjagadcjg',
                    'land_use': 856000655.145233,
                    'human_coverage': 1573199653.201390,
                    'water_availability': 500965035.180062,
                    'distribution_optimality': 2077067425.167211,
                    'land_id': 'jcgghhgdj',
                },
                'update': {
                    'land_use': 856000655.145233,
                    'human_coverage': 1573199653.201390,
                    'water_availability': 500965035.180062,
                    'distribution_optimality': 2077067425.167211,
                    'land_id': 'jcgghhgdj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LandStatisticUpdateManyMutationInput,
        where: types.LandStatisticWhereInput,
    ) -> int:
        """Update multiple LandStatistic records

        Parameters
        ----------
        data
            LandStatistic data to update the selected LandStatistic records to
        where
            Filter to select the LandStatistic records to update

        Returns
        -------
        int
            The total number of LandStatistic records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LandStatistic records
        total = await LandStatistic.prisma().update_many(
            data={
                'total_profit': 1855826649.161100
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LandStatisticWhereInput] = None,
        cursor: Optional[types.LandStatisticWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LandStatistic records present in the database

        Parameters
        ----------
        select
            Select the LandStatistic fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LandStatistic filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LandStatisticCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LandStatistic.prisma().count()

        # results: prisma.types.LandStatisticCountAggregateOutput
        results = await LandStatistic.prisma().count(
            select={
                '_all': True,
                'land_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LandStatisticCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LandStatisticWhereInput] = None,
        cursor: Optional[types.LandStatisticWhereUniqueInput] = None,
    ) -> types.LandStatisticCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LandStatisticCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LandStatisticWhereInput] = None,
        cursor: Optional[types.LandStatisticWhereUniqueInput] = None,
    ) -> Union[int, types.LandStatisticCountAggregateOutput]:
        """Count the number of LandStatistic records present in the database

        Parameters
        ----------
        select
            Select the LandStatistic fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LandStatistic filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LandStatisticCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LandStatistic.prisma().count()

        # results: prisma.types.LandStatisticCountAggregateOutput
        results = await LandStatistic.prisma().count(
            select={
                '_all': True,
                'land_stat_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LandStatisticCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LandStatisticWhereInput] = None
    ) -> int:
        """Delete multiple LandStatistic records.

        Parameters
        ----------
        where
            Optional LandStatistic filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LandStatistic records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LandStatistic records
        total = await LandStatistic.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LandStatisticScalarFieldKeys'],
        *,
        where: Optional['types.LandStatisticWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LandStatisticAvgAggregateInput'] = None,
        sum: Optional['types.LandStatisticSumAggregateInput'] = None,
        min: Optional['types.LandStatisticMinAggregateInput'] = None,
        max: Optional['types.LandStatisticMaxAggregateInput'] = None,
        having: Optional['types.LandStatisticScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LandStatisticCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LandStatisticScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LandStatisticScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LandStatisticGroupByOutput']:
        """Group LandStatistic records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LandStatistic fields to group records by
        where
            LandStatistic filter to select records
        take
            Limit the maximum number of LandStatistic records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LandStatisticGroupByOutput]
            A list of dictionaries representing the LandStatistic record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LandStatistic records by land_use values
        # and count how many records are in each group
        results = await LandStatistic.prisma().group_by(
            ['land_use'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CropActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Crop]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Crop.prisma().query_raw(
            'SELECT * FROM Crop WHERE crop_id = $1',
            'eegghdhjb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Crop
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Crop.prisma().query_first(
            'SELECT * FROM Crop WHERE crop_name = $1',
            'daafgidjg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CropCreateInput,
        include: Optional[types.CropInclude] = None
    ) -> _PrismaModelT:
        """Create a new Crop record.

        Parameters
        ----------
        data
            Crop record data
        include
            Specifies which relations should be loaded on the returned Crop model

        Returns
        -------
        prisma.models.Crop
            The created Crop record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Crop record from just the required fields
        crop = await Crop.prisma().create(
            data={
                # data to create a Crop record
                'crop_name': 'gdcgcgagj',
                'crop_area': 1724011690.47015,
                'crop_investment': 1209209912.153674,
                'expected_money_return': 424218998.212563,
                'expected_weight_return': 536951780.92472,
                'land_id': 'bgcbjdhjcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CropCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Crop records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Crop record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Crop.prisma().create_many(
            data=[
                {
                    # data to create a Crop record
                    'crop_name': 'bieiidcabj',
                    'crop_area': 1921528400.210042,
                    'crop_investment': 849140046.92815,
                    'expected_money_return': 273032060.98284,
                    'expected_weight_return': 510737498.211748,
                    'land_id': 'beabjeejdg',
                },
                {
                    # data to create a Crop record
                    'crop_name': 'bcjhgahffd',
                    'crop_area': 519488550.97683,
                    'crop_investment': 1696425492.16926,
                    'expected_money_return': 1023081650.32768,
                    'expected_weight_return': 527748992.202935,
                    'land_id': 'bdbifjhbbi',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CropWhereUniqueInput,
        include: Optional[types.CropInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Crop record.

        Parameters
        ----------
        where
            Crop filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Crop model

        Returns
        -------
        prisma.models.Crop
            The deleted Crop record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        crop = await Crop.prisma().delete(
            where={
                'crop_id': 'cbccbbcdfb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CropWhereUniqueInput,
        include: Optional[types.CropInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Crop record.

        Parameters
        ----------
        where
            Crop filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Crop model

        Returns
        -------
        prisma.models.Crop
            The found Crop record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        crop = await Crop.prisma().find_unique(
            where={
                'crop_id': 'bacejedaca',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CropWhereUniqueInput,
        include: Optional[types.CropInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Crop record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Crop filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Crop model

        Returns
        -------
        prisma.models.Crop
            The found Crop record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        crop = await Crop.prisma().find_unique_or_raise(
            where={
                'crop_id': 'bhbhdahfaj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CropWhereInput] = None,
        cursor: Optional[types.CropWhereUniqueInput] = None,
        include: Optional[types.CropInclude] = None,
        order: Optional[Union[types.CropOrderByInput, List[types.CropOrderByInput]]] = None,
        distinct: Optional[List[types.CropScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Crop records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Crop records returned
        skip
            Ignore the first N results
        where
            Crop filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Crop model
        order
            Order the returned Crop records by any field
        distinct
            Filter Crop records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Crop]
            The list of all Crop records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Crop records
        crops = await Crop.prisma().find_many(take=10)

        # find the first 5 Crop records ordered by the crop_area field
        crops = await Crop.prisma().find_many(
            take=5,
            order={
                'crop_area': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CropWhereInput] = None,
        cursor: Optional[types.CropWhereUniqueInput] = None,
        include: Optional[types.CropInclude] = None,
        order: Optional[Union[types.CropOrderByInput, List[types.CropOrderByInput]]] = None,
        distinct: Optional[List[types.CropScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Crop record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Crop filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Crop model
        order
            Order the returned Crop records by any field
        distinct
            Filter Crop records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Crop
            The first Crop record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Crop record ordered by the crop_investment field
        crop = await Crop.prisma().find_first(
            skip=1,
            order={
                'crop_investment': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CropWhereInput] = None,
        cursor: Optional[types.CropWhereUniqueInput] = None,
        include: Optional[types.CropInclude] = None,
        order: Optional[Union[types.CropOrderByInput, List[types.CropOrderByInput]]] = None,
        distinct: Optional[List[types.CropScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Crop record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Crop filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Crop model
        order
            Order the returned Crop records by any field
        distinct
            Filter Crop records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Crop
            The first Crop record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Crop record ordered by the expected_money_return field
        crop = await Crop.prisma().find_first_or_raise(
            skip=1,
            order={
                'expected_money_return': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CropUpdateInput,
        where: types.CropWhereUniqueInput,
        include: Optional[types.CropInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Crop record.

        Parameters
        ----------
        data
            Crop record data specifying what to update
        where
            Crop filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Crop model

        Returns
        -------
        prisma.models.Crop
            The updated Crop record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        crop = await Crop.prisma().update(
            where={
                'crop_id': 'bfjibceaec',
            },
            data={
                # data to update the Crop record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CropWhereUniqueInput,
        data: types.CropUpsertInput,
        include: Optional[types.CropInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Crop filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Crop model

        Returns
        -------
        prisma.models.Crop
            The created or updated Crop record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        crop = await Crop.prisma().upsert(
            where={
                'crop_id': 'ibhgcdbgd',
            },
            data={
                'create': {
                    'crop_id': 'ibhgcdbgd',
                    'crop_name': 'bcjhgahffd',
                    'crop_area': 519488550.97683,
                    'crop_investment': 1696425492.16926,
                    'expected_money_return': 1023081650.32768,
                    'expected_weight_return': 527748992.202935,
                    'land_id': 'bdbifjhbbi',
                },
                'update': {
                    'crop_name': 'bcjhgahffd',
                    'crop_area': 519488550.97683,
                    'crop_investment': 1696425492.16926,
                    'expected_money_return': 1023081650.32768,
                    'expected_weight_return': 527748992.202935,
                    'land_id': 'bdbifjhbbi',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CropUpdateManyMutationInput,
        where: types.CropWhereInput,
    ) -> int:
        """Update multiple Crop records

        Parameters
        ----------
        data
            Crop data to update the selected Crop records to
        where
            Filter to select the Crop records to update

        Returns
        -------
        int
            The total number of Crop records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Crop records
        total = await Crop.prisma().update_many(
            data={
                'expected_weight_return': 1030557336.113152
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CropWhereInput] = None,
        cursor: Optional[types.CropWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Crop records present in the database

        Parameters
        ----------
        select
            Select the Crop fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Crop filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CropCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Crop.prisma().count()

        # results: prisma.types.CropCountAggregateOutput
        results = await Crop.prisma().count(
            select={
                '_all': True,
                'land_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CropCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CropWhereInput] = None,
        cursor: Optional[types.CropWhereUniqueInput] = None,
    ) -> types.CropCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CropCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CropWhereInput] = None,
        cursor: Optional[types.CropWhereUniqueInput] = None,
    ) -> Union[int, types.CropCountAggregateOutput]:
        """Count the number of Crop records present in the database

        Parameters
        ----------
        select
            Select the Crop fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Crop filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CropCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Crop.prisma().count()

        # results: prisma.types.CropCountAggregateOutput
        results = await Crop.prisma().count(
            select={
                '_all': True,
                'crop_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CropCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CropWhereInput] = None
    ) -> int:
        """Delete multiple Crop records.

        Parameters
        ----------
        where
            Optional Crop filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Crop records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Crop records
        total = await Crop.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CropScalarFieldKeys'],
        *,
        where: Optional['types.CropWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CropAvgAggregateInput'] = None,
        sum: Optional['types.CropSumAggregateInput'] = None,
        min: Optional['types.CropMinAggregateInput'] = None,
        max: Optional['types.CropMaxAggregateInput'] = None,
        having: Optional['types.CropScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CropCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CropScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CropScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CropGroupByOutput']:
        """Group Crop records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Crop fields to group records by
        where
            Crop filter to select records
        take
            Limit the maximum number of Crop records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CropGroupByOutput]
            A list of dictionaries representing the Crop record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Crop records by crop_name values
        # and count how many records are in each group
        results = await Crop.prisma().group_by(
            ['crop_name'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CropMaintenanceActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.CropMaintenance]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await CropMaintenance.prisma().query_raw(
            'SELECT * FROM CropMaintenance WHERE maintenance_id = $1',
            'cbagggbji',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.CropMaintenance
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await CropMaintenance.prisma().query_first(
            'SELECT * FROM CropMaintenance WHERE pesticide_level = $1',
            1276057943.74556,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CropMaintenanceCreateInput,
        include: Optional[types.CropMaintenanceInclude] = None
    ) -> _PrismaModelT:
        """Create a new CropMaintenance record.

        Parameters
        ----------
        data
            CropMaintenance record data
        include
            Specifies which relations should be loaded on the returned CropMaintenance model

        Returns
        -------
        prisma.models.CropMaintenance
            The created CropMaintenance record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a CropMaintenance record from just the required fields
        cropmaintenance = await CropMaintenance.prisma().create(
            data={
                # data to create a CropMaintenance record
                'pesticide_level': 307876141.167404,
                'water_sufficienty': 1526854643.95807,
                'land_id': 'bfbdafajcb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CropMaintenanceCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple CropMaintenance records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of CropMaintenance record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await CropMaintenance.prisma().create_many(
            data=[
                {
                    # data to create a CropMaintenance record
                    'pesticide_level': 204674734.206765,
                    'water_sufficienty': 1183911900.158970,
                    'land_id': 'bcedehfiji',
                },
                {
                    # data to create a CropMaintenance record
                    'pesticide_level': 1369828971.167859,
                    'water_sufficienty': 403521121.64876,
                    'land_id': 'gahdcdhbj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CropMaintenanceWhereUniqueInput,
        include: Optional[types.CropMaintenanceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single CropMaintenance record.

        Parameters
        ----------
        where
            CropMaintenance filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned CropMaintenance model

        Returns
        -------
        prisma.models.CropMaintenance
            The deleted CropMaintenance record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cropmaintenance = await CropMaintenance.prisma().delete(
            where={
                'maintenance_id': 'begiijahea',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CropMaintenanceWhereUniqueInput,
        include: Optional[types.CropMaintenanceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique CropMaintenance record.

        Parameters
        ----------
        where
            CropMaintenance filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CropMaintenance model

        Returns
        -------
        prisma.models.CropMaintenance
            The found CropMaintenance record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cropmaintenance = await CropMaintenance.prisma().find_unique(
            where={
                'maintenance_id': 'gcjadjaaf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CropMaintenanceWhereUniqueInput,
        include: Optional[types.CropMaintenanceInclude] = None
    ) -> _PrismaModelT:
        """Find a unique CropMaintenance record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            CropMaintenance filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CropMaintenance model

        Returns
        -------
        prisma.models.CropMaintenance
            The found CropMaintenance record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cropmaintenance = await CropMaintenance.prisma().find_unique_or_raise(
            where={
                'maintenance_id': 'bcbebgiaic',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CropMaintenanceWhereInput] = None,
        cursor: Optional[types.CropMaintenanceWhereUniqueInput] = None,
        include: Optional[types.CropMaintenanceInclude] = None,
        order: Optional[Union[types.CropMaintenanceOrderByInput, List[types.CropMaintenanceOrderByInput]]] = None,
        distinct: Optional[List[types.CropMaintenanceScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple CropMaintenance records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of CropMaintenance records returned
        skip
            Ignore the first N results
        where
            CropMaintenance filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CropMaintenance model
        order
            Order the returned CropMaintenance records by any field
        distinct
            Filter CropMaintenance records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.CropMaintenance]
            The list of all CropMaintenance records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 CropMaintenance records
        cropmaintenances = await CropMaintenance.prisma().find_many(take=10)

        # find the first 5 CropMaintenance records ordered by the water_sufficienty field
        cropmaintenances = await CropMaintenance.prisma().find_many(
            take=5,
            order={
                'water_sufficienty': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CropMaintenanceWhereInput] = None,
        cursor: Optional[types.CropMaintenanceWhereUniqueInput] = None,
        include: Optional[types.CropMaintenanceInclude] = None,
        order: Optional[Union[types.CropMaintenanceOrderByInput, List[types.CropMaintenanceOrderByInput]]] = None,
        distinct: Optional[List[types.CropMaintenanceScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single CropMaintenance record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CropMaintenance filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CropMaintenance model
        order
            Order the returned CropMaintenance records by any field
        distinct
            Filter CropMaintenance records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CropMaintenance
            The first CropMaintenance record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CropMaintenance record ordered by the land_id field
        cropmaintenance = await CropMaintenance.prisma().find_first(
            skip=1,
            order={
                'land_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CropMaintenanceWhereInput] = None,
        cursor: Optional[types.CropMaintenanceWhereUniqueInput] = None,
        include: Optional[types.CropMaintenanceInclude] = None,
        order: Optional[Union[types.CropMaintenanceOrderByInput, List[types.CropMaintenanceOrderByInput]]] = None,
        distinct: Optional[List[types.CropMaintenanceScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single CropMaintenance record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CropMaintenance filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CropMaintenance model
        order
            Order the returned CropMaintenance records by any field
        distinct
            Filter CropMaintenance records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CropMaintenance
            The first CropMaintenance record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CropMaintenance record ordered by the maintenance_id field
        cropmaintenance = await CropMaintenance.prisma().find_first_or_raise(
            skip=1,
            order={
                'maintenance_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CropMaintenanceUpdateInput,
        where: types.CropMaintenanceWhereUniqueInput,
        include: Optional[types.CropMaintenanceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single CropMaintenance record.

        Parameters
        ----------
        data
            CropMaintenance record data specifying what to update
        where
            CropMaintenance filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned CropMaintenance model

        Returns
        -------
        prisma.models.CropMaintenance
            The updated CropMaintenance record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        cropmaintenance = await CropMaintenance.prisma().update(
            where={
                'maintenance_id': 'ijigbdcbj',
            },
            data={
                # data to update the CropMaintenance record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CropMaintenanceWhereUniqueInput,
        data: types.CropMaintenanceUpsertInput,
        include: Optional[types.CropMaintenanceInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            CropMaintenance filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned CropMaintenance model

        Returns
        -------
        prisma.models.CropMaintenance
            The created or updated CropMaintenance record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cropmaintenance = await CropMaintenance.prisma().upsert(
            where={
                'maintenance_id': 'gfidhicai',
            },
            data={
                'create': {
                    'maintenance_id': 'gfidhicai',
                    'pesticide_level': 1369828971.167859,
                    'water_sufficienty': 403521121.64876,
                    'land_id': 'gahdcdhbj',
                },
                'update': {
                    'pesticide_level': 1369828971.167859,
                    'water_sufficienty': 403521121.64876,
                    'land_id': 'gahdcdhbj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CropMaintenanceUpdateManyMutationInput,
        where: types.CropMaintenanceWhereInput,
    ) -> int:
        """Update multiple CropMaintenance records

        Parameters
        ----------
        data
            CropMaintenance data to update the selected CropMaintenance records to
        where
            Filter to select the CropMaintenance records to update

        Returns
        -------
        int
            The total number of CropMaintenance records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all CropMaintenance records
        total = await CropMaintenance.prisma().update_many(
            data={
                'pesticide_level': 954620057.121480
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CropMaintenanceWhereInput] = None,
        cursor: Optional[types.CropMaintenanceWhereUniqueInput] = None,
    ) -> int:
        """Count the number of CropMaintenance records present in the database

        Parameters
        ----------
        select
            Select the CropMaintenance fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CropMaintenance filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CropMaintenanceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CropMaintenance.prisma().count()

        # results: prisma.types.CropMaintenanceCountAggregateOutput
        results = await CropMaintenance.prisma().count(
            select={
                '_all': True,
                'water_sufficienty': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CropMaintenanceCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CropMaintenanceWhereInput] = None,
        cursor: Optional[types.CropMaintenanceWhereUniqueInput] = None,
    ) -> types.CropMaintenanceCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CropMaintenanceCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CropMaintenanceWhereInput] = None,
        cursor: Optional[types.CropMaintenanceWhereUniqueInput] = None,
    ) -> Union[int, types.CropMaintenanceCountAggregateOutput]:
        """Count the number of CropMaintenance records present in the database

        Parameters
        ----------
        select
            Select the CropMaintenance fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CropMaintenance filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CropMaintenanceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CropMaintenance.prisma().count()

        # results: prisma.types.CropMaintenanceCountAggregateOutput
        results = await CropMaintenance.prisma().count(
            select={
                '_all': True,
                'land_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CropMaintenanceCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CropMaintenanceWhereInput] = None
    ) -> int:
        """Delete multiple CropMaintenance records.

        Parameters
        ----------
        where
            Optional CropMaintenance filter to find the records to be deleted

        Returns
        -------
        int
            The total number of CropMaintenance records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all CropMaintenance records
        total = await CropMaintenance.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CropMaintenanceScalarFieldKeys'],
        *,
        where: Optional['types.CropMaintenanceWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CropMaintenanceAvgAggregateInput'] = None,
        sum: Optional['types.CropMaintenanceSumAggregateInput'] = None,
        min: Optional['types.CropMaintenanceMinAggregateInput'] = None,
        max: Optional['types.CropMaintenanceMaxAggregateInput'] = None,
        having: Optional['types.CropMaintenanceScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CropMaintenanceCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CropMaintenanceScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CropMaintenanceScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CropMaintenanceGroupByOutput']:
        """Group CropMaintenance records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar CropMaintenance fields to group records by
        where
            CropMaintenance filter to select records
        take
            Limit the maximum number of CropMaintenance records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CropMaintenanceGroupByOutput]
            A list of dictionaries representing the CropMaintenance record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group CropMaintenance records by maintenance_id values
        # and count how many records are in each group
        results = await CropMaintenance.prisma().group_by(
            ['maintenance_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class FinanceActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Finance]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Finance.prisma().query_raw(
            'SELECT * FROM Finance WHERE financial_id = $1',
            'baehicaajf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Finance
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Finance.prisma().query_first(
            'SELECT * FROM Finance WHERE investment_amount = $1',
            1302734860.89305,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.FinanceCreateInput,
        include: Optional[types.FinanceInclude] = None
    ) -> _PrismaModelT:
        """Create a new Finance record.

        Parameters
        ----------
        data
            Finance record data
        include
            Specifies which relations should be loaded on the returned Finance model

        Returns
        -------
        prisma.models.Finance
            The created Finance record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Finance record from just the required fields
        finance = await Finance.prisma().create(
            data={
                # data to create a Finance record
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.FinanceCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Finance records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Finance record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Finance.prisma().create_many(
            data=[
                {
                    # data to create a Finance record
                },
                {
                    # data to create a Finance record
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.FinanceWhereUniqueInput,
        include: Optional[types.FinanceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Finance record.

        Parameters
        ----------
        where
            Finance filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Finance model

        Returns
        -------
        prisma.models.Finance
            The deleted Finance record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        finance = await Finance.prisma().delete(
            where={
                'financial_id': 'ciaaiddag',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.FinanceWhereUniqueInput,
        include: Optional[types.FinanceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Finance record.

        Parameters
        ----------
        where
            Finance filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Finance model

        Returns
        -------
        prisma.models.Finance
            The found Finance record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        finance = await Finance.prisma().find_unique(
            where={
                'financial_id': 'fejggijff',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.FinanceWhereUniqueInput,
        include: Optional[types.FinanceInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Finance record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Finance filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Finance model

        Returns
        -------
        prisma.models.Finance
            The found Finance record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        finance = await Finance.prisma().find_unique_or_raise(
            where={
                'financial_id': 'hghjaaai',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FinanceWhereInput] = None,
        cursor: Optional[types.FinanceWhereUniqueInput] = None,
        include: Optional[types.FinanceInclude] = None,
        order: Optional[Union[types.FinanceOrderByInput, List[types.FinanceOrderByInput]]] = None,
        distinct: Optional[List[types.FinanceScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Finance records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Finance records returned
        skip
            Ignore the first N results
        where
            Finance filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Finance model
        order
            Order the returned Finance records by any field
        distinct
            Filter Finance records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Finance]
            The list of all Finance records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Finance records
        finances = await Finance.prisma().find_many(take=10)

        # find the first 5 Finance records ordered by the expected_revenue field
        finances = await Finance.prisma().find_many(
            take=5,
            order={
                'expected_revenue': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FinanceWhereInput] = None,
        cursor: Optional[types.FinanceWhereUniqueInput] = None,
        include: Optional[types.FinanceInclude] = None,
        order: Optional[Union[types.FinanceOrderByInput, List[types.FinanceOrderByInput]]] = None,
        distinct: Optional[List[types.FinanceScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Finance record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Finance filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Finance model
        order
            Order the returned Finance records by any field
        distinct
            Filter Finance records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Finance
            The first Finance record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Finance record ordered by the land_id field
        finance = await Finance.prisma().find_first(
            skip=1,
            order={
                'land_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FinanceWhereInput] = None,
        cursor: Optional[types.FinanceWhereUniqueInput] = None,
        include: Optional[types.FinanceInclude] = None,
        order: Optional[Union[types.FinanceOrderByInput, List[types.FinanceOrderByInput]]] = None,
        distinct: Optional[List[types.FinanceScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Finance record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Finance filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Finance model
        order
            Order the returned Finance records by any field
        distinct
            Filter Finance records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Finance
            The first Finance record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Finance record ordered by the financial_id field
        finance = await Finance.prisma().find_first_or_raise(
            skip=1,
            order={
                'financial_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.FinanceUpdateInput,
        where: types.FinanceWhereUniqueInput,
        include: Optional[types.FinanceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Finance record.

        Parameters
        ----------
        data
            Finance record data specifying what to update
        where
            Finance filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Finance model

        Returns
        -------
        prisma.models.Finance
            The updated Finance record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        finance = await Finance.prisma().update(
            where={
                'financial_id': 'cajicjjdef',
            },
            data={
                # data to update the Finance record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.FinanceWhereUniqueInput,
        data: types.FinanceUpsertInput,
        include: Optional[types.FinanceInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Finance filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Finance model

        Returns
        -------
        prisma.models.Finance
            The created or updated Finance record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        finance = await Finance.prisma().upsert(
            where={
                'financial_id': 'cefjaadec',
            },
            data={
                'create': {
                    'financial_id': 'cefjaadec',
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.FinanceUpdateManyMutationInput,
        where: types.FinanceWhereInput,
    ) -> int:
        """Update multiple Finance records

        Parameters
        ----------
        data
            Finance data to update the selected Finance records to
        where
            Filter to select the Finance records to update

        Returns
        -------
        int
            The total number of Finance records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Finance records
        total = await Finance.prisma().update_many(
            data={
                'investment_amount': 811863863.138880
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FinanceWhereInput] = None,
        cursor: Optional[types.FinanceWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Finance records present in the database

        Parameters
        ----------
        select
            Select the Finance fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Finance filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FinanceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Finance.prisma().count()

        # results: prisma.types.FinanceCountAggregateOutput
        results = await Finance.prisma().count(
            select={
                '_all': True,
                'expected_revenue': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.FinanceCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FinanceWhereInput] = None,
        cursor: Optional[types.FinanceWhereUniqueInput] = None,
    ) -> types.FinanceCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.FinanceCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FinanceWhereInput] = None,
        cursor: Optional[types.FinanceWhereUniqueInput] = None,
    ) -> Union[int, types.FinanceCountAggregateOutput]:
        """Count the number of Finance records present in the database

        Parameters
        ----------
        select
            Select the Finance fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Finance filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FinanceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Finance.prisma().count()

        # results: prisma.types.FinanceCountAggregateOutput
        results = await Finance.prisma().count(
            select={
                '_all': True,
                'land_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.FinanceCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.FinanceWhereInput] = None
    ) -> int:
        """Delete multiple Finance records.

        Parameters
        ----------
        where
            Optional Finance filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Finance records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Finance records
        total = await Finance.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.FinanceScalarFieldKeys'],
        *,
        where: Optional['types.FinanceWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.FinanceAvgAggregateInput'] = None,
        sum: Optional['types.FinanceSumAggregateInput'] = None,
        min: Optional['types.FinanceMinAggregateInput'] = None,
        max: Optional['types.FinanceMaxAggregateInput'] = None,
        having: Optional['types.FinanceScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.FinanceCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.FinanceScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.FinanceScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.FinanceGroupByOutput']:
        """Group Finance records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Finance fields to group records by
        where
            Finance filter to select records
        take
            Limit the maximum number of Finance records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.FinanceGroupByOutput]
            A list of dictionaries representing the Finance record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Finance records by financial_id values
        # and count how many records are in each group
        results = await Finance.prisma().group_by(
            ['financial_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class WeatherActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Weather]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Weather.prisma().query_raw(
            'SELECT * FROM Weather WHERE weather_id = $1',
            'hfcfhhadh',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Weather
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Weather.prisma().query_first(
            'SELECT * FROM Weather WHERE temperature = $1',
            1187663298.76968,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.WeatherCreateInput,
        include: Optional[types.WeatherInclude] = None
    ) -> _PrismaModelT:
        """Create a new Weather record.

        Parameters
        ----------
        data
            Weather record data
        include
            Specifies which relations should be loaded on the returned Weather model

        Returns
        -------
        prisma.models.Weather
            The created Weather record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Weather record from just the required fields
        weather = await Weather.prisma().create(
            data={
                # data to create a Weather record
                'temperature': 1214295824.102141,
                'humidity': 351503374.132118,
                'rainfall': 369732668.119123,
                'sunlight': 627561242.187295,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.WeatherCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Weather records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Weather record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Weather.prisma().create_many(
            data=[
                {
                    # data to create a Weather record
                    'temperature': 1793282088.181439,
                    'humidity': 1923090150.127724,
                    'rainfall': 1160857300.36123,
                    'sunlight': 1406511986.148287,
                },
                {
                    # data to create a Weather record
                    'temperature': 566623296.22911,
                    'humidity': 1750011070.41094,
                    'rainfall': 909024364.75561,
                    'sunlight': 1802188490.29491,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.WeatherWhereUniqueInput,
        include: Optional[types.WeatherInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Weather record.

        Parameters
        ----------
        where
            Weather filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Weather model

        Returns
        -------
        prisma.models.Weather
            The deleted Weather record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        weather = await Weather.prisma().delete(
            where={
                'weather_id': 'fgeahddae',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.WeatherWhereUniqueInput,
        include: Optional[types.WeatherInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Weather record.

        Parameters
        ----------
        where
            Weather filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Weather model

        Returns
        -------
        prisma.models.Weather
            The found Weather record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        weather = await Weather.prisma().find_unique(
            where={
                'weather_id': 'diageigcf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.WeatherWhereUniqueInput,
        include: Optional[types.WeatherInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Weather record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Weather filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Weather model

        Returns
        -------
        prisma.models.Weather
            The found Weather record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        weather = await Weather.prisma().find_unique_or_raise(
            where={
                'weather_id': 'badagbgeha',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WeatherWhereInput] = None,
        cursor: Optional[types.WeatherWhereUniqueInput] = None,
        include: Optional[types.WeatherInclude] = None,
        order: Optional[Union[types.WeatherOrderByInput, List[types.WeatherOrderByInput]]] = None,
        distinct: Optional[List[types.WeatherScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Weather records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Weather records returned
        skip
            Ignore the first N results
        where
            Weather filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Weather model
        order
            Order the returned Weather records by any field
        distinct
            Filter Weather records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Weather]
            The list of all Weather records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Weather records
        weathers = await Weather.prisma().find_many(take=10)

        # find the first 5 Weather records ordered by the humidity field
        weathers = await Weather.prisma().find_many(
            take=5,
            order={
                'humidity': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WeatherWhereInput] = None,
        cursor: Optional[types.WeatherWhereUniqueInput] = None,
        include: Optional[types.WeatherInclude] = None,
        order: Optional[Union[types.WeatherOrderByInput, List[types.WeatherOrderByInput]]] = None,
        distinct: Optional[List[types.WeatherScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Weather record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Weather filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Weather model
        order
            Order the returned Weather records by any field
        distinct
            Filter Weather records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Weather
            The first Weather record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Weather record ordered by the rainfall field
        weather = await Weather.prisma().find_first(
            skip=1,
            order={
                'rainfall': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WeatherWhereInput] = None,
        cursor: Optional[types.WeatherWhereUniqueInput] = None,
        include: Optional[types.WeatherInclude] = None,
        order: Optional[Union[types.WeatherOrderByInput, List[types.WeatherOrderByInput]]] = None,
        distinct: Optional[List[types.WeatherScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Weather record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Weather filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Weather model
        order
            Order the returned Weather records by any field
        distinct
            Filter Weather records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Weather
            The first Weather record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Weather record ordered by the sunlight field
        weather = await Weather.prisma().find_first_or_raise(
            skip=1,
            order={
                'sunlight': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.WeatherUpdateInput,
        where: types.WeatherWhereUniqueInput,
        include: Optional[types.WeatherInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Weather record.

        Parameters
        ----------
        data
            Weather record data specifying what to update
        where
            Weather filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Weather model

        Returns
        -------
        prisma.models.Weather
            The updated Weather record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        weather = await Weather.prisma().update(
            where={
                'weather_id': 'ibgebbjch',
            },
            data={
                # data to update the Weather record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.WeatherWhereUniqueInput,
        data: types.WeatherUpsertInput,
        include: Optional[types.WeatherInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Weather filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Weather model

        Returns
        -------
        prisma.models.Weather
            The created or updated Weather record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        weather = await Weather.prisma().upsert(
            where={
                'weather_id': 'baieajjiee',
            },
            data={
                'create': {
                    'weather_id': 'baieajjiee',
                    'temperature': 566623296.22911,
                    'humidity': 1750011070.41094,
                    'rainfall': 909024364.75561,
                    'sunlight': 1802188490.29491,
                },
                'update': {
                    'temperature': 566623296.22911,
                    'humidity': 1750011070.41094,
                    'rainfall': 909024364.75561,
                    'sunlight': 1802188490.29491,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.WeatherUpdateManyMutationInput,
        where: types.WeatherWhereInput,
    ) -> int:
        """Update multiple Weather records

        Parameters
        ----------
        data
            Weather data to update the selected Weather records to
        where
            Filter to select the Weather records to update

        Returns
        -------
        int
            The total number of Weather records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Weather records
        total = await Weather.prisma().update_many(
            data={
                'land_id': 'bahjhaccfd'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WeatherWhereInput] = None,
        cursor: Optional[types.WeatherWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Weather records present in the database

        Parameters
        ----------
        select
            Select the Weather fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Weather filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WeatherCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Weather.prisma().count()

        # results: prisma.types.WeatherCountAggregateOutput
        results = await Weather.prisma().count(
            select={
                '_all': True,
                'weather_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.WeatherCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WeatherWhereInput] = None,
        cursor: Optional[types.WeatherWhereUniqueInput] = None,
    ) -> types.WeatherCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.WeatherCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WeatherWhereInput] = None,
        cursor: Optional[types.WeatherWhereUniqueInput] = None,
    ) -> Union[int, types.WeatherCountAggregateOutput]:
        """Count the number of Weather records present in the database

        Parameters
        ----------
        select
            Select the Weather fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Weather filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WeatherCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Weather.prisma().count()

        # results: prisma.types.WeatherCountAggregateOutput
        results = await Weather.prisma().count(
            select={
                '_all': True,
                'temperature': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.WeatherCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.WeatherWhereInput] = None
    ) -> int:
        """Delete multiple Weather records.

        Parameters
        ----------
        where
            Optional Weather filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Weather records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Weather records
        total = await Weather.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.WeatherScalarFieldKeys'],
        *,
        where: Optional['types.WeatherWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.WeatherAvgAggregateInput'] = None,
        sum: Optional['types.WeatherSumAggregateInput'] = None,
        min: Optional['types.WeatherMinAggregateInput'] = None,
        max: Optional['types.WeatherMaxAggregateInput'] = None,
        having: Optional['types.WeatherScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.WeatherCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.WeatherScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.WeatherScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.WeatherGroupByOutput']:
        """Group Weather records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Weather fields to group records by
        where
            Weather filter to select records
        take
            Limit the maximum number of Weather records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.WeatherGroupByOutput]
            A list of dictionaries representing the Weather record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Weather records by humidity values
        # and count how many records are in each group
        results = await Weather.prisma().group_by(
            ['humidity'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class BusinessPlanActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.BusinessPlan]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await BusinessPlan.prisma().query_raw(
            'SELECT * FROM BusinessPlan WHERE business_plan_id = $1',
            'hffhfabhi',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.BusinessPlan
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await BusinessPlan.prisma().query_first(
            'SELECT * FROM BusinessPlan WHERE executive_summary = $1',
            'bbcigiadhb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.BusinessPlanCreateInput,
        include: Optional[types.BusinessPlanInclude] = None
    ) -> _PrismaModelT:
        """Create a new BusinessPlan record.

        Parameters
        ----------
        data
            BusinessPlan record data
        include
            Specifies which relations should be loaded on the returned BusinessPlan model

        Returns
        -------
        prisma.models.BusinessPlan
            The created BusinessPlan record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a BusinessPlan record from just the required fields
        businessplan = await BusinessPlan.prisma().create(
            data={
                # data to create a BusinessPlan record
                'executive_summary': 'cfjagbbae',
                'resources': 'bbbfhdidef',
                'crops': 'bdadhibhec',
                'weather_considerations': 'bfhdjaiejf',
                'soil_maintenance': 'bbjfijjadg',
                'profit_estimations': 'hdjacbehh',
                'other_recommendations': 'bhcccbeaba',
                'land_id': 'bcgjbdgjdj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.BusinessPlanCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple BusinessPlan records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of BusinessPlan record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await BusinessPlan.prisma().create_many(
            data=[
                {
                    # data to create a BusinessPlan record
                    'executive_summary': 'fhdbhifae',
                    'resources': 'beeacgfcej',
                    'crops': 'bbifhdiicc',
                    'weather_considerations': 'bgjeccejad',
                    'soil_maintenance': 'bjagdgabbg',
                    'profit_estimations': 'bjbbcffdij',
                    'other_recommendations': 'begcgchdi',
                    'land_id': 'bhbjceagbb',
                },
                {
                    # data to create a BusinessPlan record
                    'executive_summary': 'bjeifffjdg',
                    'resources': 'bdidcfdfjd',
                    'crops': 'dfeggejja',
                    'weather_considerations': 'gehbgghbj',
                    'soil_maintenance': 'dfhaijeie',
                    'profit_estimations': 'gbcdjgicb',
                    'other_recommendations': 'biaibdagac',
                    'land_id': 'bbfbheibcd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.BusinessPlanWhereUniqueInput,
        include: Optional[types.BusinessPlanInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single BusinessPlan record.

        Parameters
        ----------
        where
            BusinessPlan filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned BusinessPlan model

        Returns
        -------
        prisma.models.BusinessPlan
            The deleted BusinessPlan record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        businessplan = await BusinessPlan.prisma().delete(
            where={
                'business_plan_id': 'hiagajie',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.BusinessPlanWhereUniqueInput,
        include: Optional[types.BusinessPlanInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique BusinessPlan record.

        Parameters
        ----------
        where
            BusinessPlan filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned BusinessPlan model

        Returns
        -------
        prisma.models.BusinessPlan
            The found BusinessPlan record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        businessplan = await BusinessPlan.prisma().find_unique(
            where={
                'business_plan_id': 'eeejidbif',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.BusinessPlanWhereUniqueInput,
        include: Optional[types.BusinessPlanInclude] = None
    ) -> _PrismaModelT:
        """Find a unique BusinessPlan record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            BusinessPlan filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned BusinessPlan model

        Returns
        -------
        prisma.models.BusinessPlan
            The found BusinessPlan record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        businessplan = await BusinessPlan.prisma().find_unique_or_raise(
            where={
                'business_plan_id': 'efgbahec',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BusinessPlanWhereInput] = None,
        cursor: Optional[types.BusinessPlanWhereUniqueInput] = None,
        include: Optional[types.BusinessPlanInclude] = None,
        order: Optional[Union[types.BusinessPlanOrderByInput, List[types.BusinessPlanOrderByInput]]] = None,
        distinct: Optional[List[types.BusinessPlanScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple BusinessPlan records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of BusinessPlan records returned
        skip
            Ignore the first N results
        where
            BusinessPlan filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned BusinessPlan model
        order
            Order the returned BusinessPlan records by any field
        distinct
            Filter BusinessPlan records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.BusinessPlan]
            The list of all BusinessPlan records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 BusinessPlan records
        businessplans = await BusinessPlan.prisma().find_many(take=10)

        # find the first 5 BusinessPlan records ordered by the resources field
        businessplans = await BusinessPlan.prisma().find_many(
            take=5,
            order={
                'resources': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BusinessPlanWhereInput] = None,
        cursor: Optional[types.BusinessPlanWhereUniqueInput] = None,
        include: Optional[types.BusinessPlanInclude] = None,
        order: Optional[Union[types.BusinessPlanOrderByInput, List[types.BusinessPlanOrderByInput]]] = None,
        distinct: Optional[List[types.BusinessPlanScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single BusinessPlan record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            BusinessPlan filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned BusinessPlan model
        order
            Order the returned BusinessPlan records by any field
        distinct
            Filter BusinessPlan records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.BusinessPlan
            The first BusinessPlan record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second BusinessPlan record ordered by the crops field
        businessplan = await BusinessPlan.prisma().find_first(
            skip=1,
            order={
                'crops': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BusinessPlanWhereInput] = None,
        cursor: Optional[types.BusinessPlanWhereUniqueInput] = None,
        include: Optional[types.BusinessPlanInclude] = None,
        order: Optional[Union[types.BusinessPlanOrderByInput, List[types.BusinessPlanOrderByInput]]] = None,
        distinct: Optional[List[types.BusinessPlanScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single BusinessPlan record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            BusinessPlan filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned BusinessPlan model
        order
            Order the returned BusinessPlan records by any field
        distinct
            Filter BusinessPlan records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.BusinessPlan
            The first BusinessPlan record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second BusinessPlan record ordered by the weather_considerations field
        businessplan = await BusinessPlan.prisma().find_first_or_raise(
            skip=1,
            order={
                'weather_considerations': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.BusinessPlanUpdateInput,
        where: types.BusinessPlanWhereUniqueInput,
        include: Optional[types.BusinessPlanInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single BusinessPlan record.

        Parameters
        ----------
        data
            BusinessPlan record data specifying what to update
        where
            BusinessPlan filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned BusinessPlan model

        Returns
        -------
        prisma.models.BusinessPlan
            The updated BusinessPlan record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        businessplan = await BusinessPlan.prisma().update(
            where={
                'business_plan_id': 'hgjaiebfb',
            },
            data={
                # data to update the BusinessPlan record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.BusinessPlanWhereUniqueInput,
        data: types.BusinessPlanUpsertInput,
        include: Optional[types.BusinessPlanInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            BusinessPlan filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned BusinessPlan model

        Returns
        -------
        prisma.models.BusinessPlan
            The created or updated BusinessPlan record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        businessplan = await BusinessPlan.prisma().upsert(
            where={
                'business_plan_id': 'bddefjjabc',
            },
            data={
                'create': {
                    'business_plan_id': 'bddefjjabc',
                    'executive_summary': 'bjeifffjdg',
                    'resources': 'bdidcfdfjd',
                    'crops': 'dfeggejja',
                    'weather_considerations': 'gehbgghbj',
                    'soil_maintenance': 'dfhaijeie',
                    'profit_estimations': 'gbcdjgicb',
                    'other_recommendations': 'biaibdagac',
                    'land_id': 'bbfbheibcd',
                },
                'update': {
                    'executive_summary': 'bjeifffjdg',
                    'resources': 'bdidcfdfjd',
                    'crops': 'dfeggejja',
                    'weather_considerations': 'gehbgghbj',
                    'soil_maintenance': 'dfhaijeie',
                    'profit_estimations': 'gbcdjgicb',
                    'other_recommendations': 'biaibdagac',
                    'land_id': 'bbfbheibcd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.BusinessPlanUpdateManyMutationInput,
        where: types.BusinessPlanWhereInput,
    ) -> int:
        """Update multiple BusinessPlan records

        Parameters
        ----------
        data
            BusinessPlan data to update the selected BusinessPlan records to
        where
            Filter to select the BusinessPlan records to update

        Returns
        -------
        int
            The total number of BusinessPlan records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all BusinessPlan records
        total = await BusinessPlan.prisma().update_many(
            data={
                'soil_maintenance': 'bbbghgbadh'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BusinessPlanWhereInput] = None,
        cursor: Optional[types.BusinessPlanWhereUniqueInput] = None,
    ) -> int:
        """Count the number of BusinessPlan records present in the database

        Parameters
        ----------
        select
            Select the BusinessPlan fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            BusinessPlan filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BusinessPlanCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await BusinessPlan.prisma().count()

        # results: prisma.types.BusinessPlanCountAggregateOutput
        results = await BusinessPlan.prisma().count(
            select={
                '_all': True,
                'profit_estimations': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.BusinessPlanCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BusinessPlanWhereInput] = None,
        cursor: Optional[types.BusinessPlanWhereUniqueInput] = None,
    ) -> types.BusinessPlanCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.BusinessPlanCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BusinessPlanWhereInput] = None,
        cursor: Optional[types.BusinessPlanWhereUniqueInput] = None,
    ) -> Union[int, types.BusinessPlanCountAggregateOutput]:
        """Count the number of BusinessPlan records present in the database

        Parameters
        ----------
        select
            Select the BusinessPlan fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            BusinessPlan filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BusinessPlanCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await BusinessPlan.prisma().count()

        # results: prisma.types.BusinessPlanCountAggregateOutput
        results = await BusinessPlan.prisma().count(
            select={
                '_all': True,
                'other_recommendations': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.BusinessPlanCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.BusinessPlanWhereInput] = None
    ) -> int:
        """Delete multiple BusinessPlan records.

        Parameters
        ----------
        where
            Optional BusinessPlan filter to find the records to be deleted

        Returns
        -------
        int
            The total number of BusinessPlan records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all BusinessPlan records
        total = await BusinessPlan.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.BusinessPlanScalarFieldKeys'],
        *,
        where: Optional['types.BusinessPlanWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.BusinessPlanAvgAggregateInput'] = None,
        sum: Optional['types.BusinessPlanSumAggregateInput'] = None,
        min: Optional['types.BusinessPlanMinAggregateInput'] = None,
        max: Optional['types.BusinessPlanMaxAggregateInput'] = None,
        having: Optional['types.BusinessPlanScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.BusinessPlanCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.BusinessPlanScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.BusinessPlanScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.BusinessPlanGroupByOutput']:
        """Group BusinessPlan records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar BusinessPlan fields to group records by
        where
            BusinessPlan filter to select records
        take
            Limit the maximum number of BusinessPlan records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.BusinessPlanGroupByOutput]
            A list of dictionaries representing the BusinessPlan record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group BusinessPlan records by land_id values
        # and count how many records are in each group
        results = await BusinessPlan.prisma().group_by(
            ['land_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models