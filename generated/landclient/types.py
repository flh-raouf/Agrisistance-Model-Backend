# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List[Any],
    Dict[None, Any],
    Dict[bool, Any],
    Dict[float, Any],
    Dict[int, Any],
    Dict[str, Any],
]


    

StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive1'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive1 = TypedDict(
    'StringFilterRecursive1',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive2'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive2 = TypedDict(
    'StringFilterRecursive2',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive3'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive3 = TypedDict(
    'StringFilterRecursive3',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive4'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive4 = TypedDict(
    'StringFilterRecursive4',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
                'mode': SortMode,
        'search': str,
    },
    total=False,
)


class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


    

DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
    },
    total=False,
)


DateTimeFilterRecursive1 = TypedDict(
    'DateTimeFilterRecursive1',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
    },
    total=False,
)


DateTimeFilterRecursive2 = TypedDict(
    'DateTimeFilterRecursive2',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive3'],
    },
    total=False,
)


DateTimeFilterRecursive3 = TypedDict(
    'DateTimeFilterRecursive3',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive4'],
    },
    total=False,
)


DateTimeFilterRecursive4 = TypedDict(
    'DateTimeFilterRecursive4',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
            },
    total=False,
)


class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


    

BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive1'],
    },
    total=False,
)


BooleanFilterRecursive1 = TypedDict(
    'BooleanFilterRecursive1',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive2'],
    },
    total=False,
)


BooleanFilterRecursive2 = TypedDict(
    'BooleanFilterRecursive2',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive3'],
    },
    total=False,
)


BooleanFilterRecursive3 = TypedDict(
    'BooleanFilterRecursive3',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive4'],
    },
    total=False,
)


BooleanFilterRecursive4 = TypedDict(
    'BooleanFilterRecursive4',
    {
        'equals': bool,
            },
    total=False,
)


class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


    

IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive1'],
    },
    total=False,
)


IntFilterRecursive1 = TypedDict(
    'IntFilterRecursive1',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive2'],
    },
    total=False,
)


IntFilterRecursive2 = TypedDict(
    'IntFilterRecursive2',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive3'],
    },
    total=False,
)


IntFilterRecursive3 = TypedDict(
    'IntFilterRecursive3',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive4'],
    },
    total=False,
)


IntFilterRecursive4 = TypedDict(
    'IntFilterRecursive4',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
            },
    total=False,
)


class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
    

FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive1'],
    },
    total=False,
)


FloatFilterRecursive1 = TypedDict(
    'FloatFilterRecursive1',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive2'],
    },
    total=False,
)


FloatFilterRecursive2 = TypedDict(
    'FloatFilterRecursive2',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive3'],
    },
    total=False,
)


FloatFilterRecursive3 = TypedDict(
    'FloatFilterRecursive3',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive4'],
    },
    total=False,
)


FloatFilterRecursive4 = TypedDict(
    'FloatFilterRecursive4',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
            },
    total=False,
)


class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


    

BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive1'],
    },
    total=False,
)


BytesFilterRecursive1 = TypedDict(
    'BytesFilterRecursive1',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive2'],
    },
    total=False,
)


BytesFilterRecursive2 = TypedDict(
    'BytesFilterRecursive2',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive3'],
    },
    total=False,
)


BytesFilterRecursive3 = TypedDict(
    'BytesFilterRecursive3',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive4'],
    },
    total=False,
)


BytesFilterRecursive4 = TypedDict(
    'BytesFilterRecursive4',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
            },
    total=False,
)


class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


    

DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive1'],
    },
    total=False,
)


DecimalFilterRecursive1 = TypedDict(
    'DecimalFilterRecursive1',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive2'],
    },
    total=False,
)


DecimalFilterRecursive2 = TypedDict(
    'DecimalFilterRecursive2',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive3'],
    },
    total=False,
)


DecimalFilterRecursive3 = TypedDict(
    'DecimalFilterRecursive3',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive4'],
    },
    total=False,
)


DecimalFilterRecursive4 = TypedDict(
    'DecimalFilterRecursive4',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
            },
    total=False,
)


class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]


# User types

class UserOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the User create method"""
    user_id: _str
    lands: 'LandCreateManyNestedWithoutRelationsInput'


class UserCreateInput(UserOptionalCreateInput):
    """Required arguments to the User create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UserOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the User create method, without relations"""
    user_id: _str


class UserCreateWithoutRelationsInput(UserOptionalCreateWithoutRelationsInput):
    """Required arguments to the User create method, without relations"""

class UserConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'UserCreateWithoutRelationsInput'
    where: 'UserWhereUniqueInput'

class UserCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    connect_or_create: 'UserConnectOrCreateWithoutRelationsInput'


class UserCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UserCreateWithoutRelationsInput', List['UserCreateWithoutRelationsInput']]
    connect: Union['UserWhereUniqueInput', List['UserWhereUniqueInput']]
    connect_or_create: Union['UserConnectOrCreateWithoutRelationsInput', List['UserConnectOrCreateWithoutRelationsInput']]

_UserWhereUnique_user_id_Input = TypedDict(
    '_UserWhereUnique_user_id_Input',
    {
        'user_id': '_str',
    },
    total=True
)

UserWhereUniqueInput = _UserWhereUnique_user_id_Input


class UserUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    user_id: _str
    lands: 'LandUpdateManyWithoutRelationsInput'


class UserUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    user_id: _str


class UserUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UserCreateWithoutRelationsInput']
    connect: List['UserWhereUniqueInput']
    connect_or_create: List['UserConnectOrCreateWithoutRelationsInput']
    set: List['UserWhereUniqueInput']
    disconnect: List['UserWhereUniqueInput']
    delete: List['UserWhereUniqueInput']

    # TODO
    # update: List['UserUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UserUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UserScalarWhereInput']
    # upsert: List['UserUpserteWithWhereUniqueWithoutRelationsInput']


class UserUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    connect_or_create: 'UserConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UserUpdateInput'
    # upsert: 'UserUpsertWithoutRelationsInput'


class UserUpsertInput(TypedDict):
    create: 'UserCreateInput'
    update: 'UserUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_User_user_id_OrderByInput = TypedDict(
    '_User_user_id_OrderByInput',
    {
        'user_id': 'SortOrder',
    },
    total=True
)

_User_RelevanceInner = TypedDict(
    '_User_RelevanceInner',
    {
        'fields': 'List[UserScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_User_RelevanceOrderByInput = TypedDict(
    '_User_RelevanceOrderByInput',
    {
        '_relevance': '_User_RelevanceInner',
    },
    total=True
)

UserOrderByInput = Union[
    '_User_user_id_OrderByInput',
    '_User_RelevanceOrderByInput',
]



# recursive User types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

UserRelationFilter = TypedDict(
    'UserRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class UserListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class UserInclude(TypedDict, total=False):
    """User relational arguments"""
    lands: Union[bool, 'FindManyLandArgsFromUser']


    

class UserIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    lands: Union[bool, 'FindManyLandArgsFromUserRecursive1']


class UserIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    lands: Union[bool, 'FindManyLandArgsFromUserRecursive2']


class UserIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    lands: Union[bool, 'FindManyLandArgsFromUserRecursive3']


class UserIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    lands: Union[bool, 'FindManyLandArgsFromUserRecursive4']


class UserIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class UserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyUserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class LandIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive1']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromUserRecursive1']
    crops: Union[bool, 'FindManyCropArgsFromUserRecursive1']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromUserRecursive1']
    finances: Union[bool, 'FindManyFinanceArgsFromUserRecursive1']
    weather_data: Union[bool, 'FindManyWeatherArgsFromUserRecursive1']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromUserRecursive1']


class LandIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive2']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromUserRecursive2']
    crops: Union[bool, 'FindManyCropArgsFromUserRecursive2']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromUserRecursive2']
    finances: Union[bool, 'FindManyFinanceArgsFromUserRecursive2']
    weather_data: Union[bool, 'FindManyWeatherArgsFromUserRecursive2']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromUserRecursive2']


class LandIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive3']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromUserRecursive3']
    crops: Union[bool, 'FindManyCropArgsFromUserRecursive3']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromUserRecursive3']
    finances: Union[bool, 'FindManyFinanceArgsFromUserRecursive3']
    weather_data: Union[bool, 'FindManyWeatherArgsFromUserRecursive3']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromUserRecursive3']


class LandIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive4']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromUserRecursive4']
    crops: Union[bool, 'FindManyCropArgsFromUserRecursive4']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromUserRecursive4']
    finances: Union[bool, 'FindManyFinanceArgsFromUserRecursive4']
    weather_data: Union[bool, 'FindManyWeatherArgsFromUserRecursive4']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromUserRecursive4']


class LandIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class LandArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'LandIncludeFromLandRecursive1'


class LandArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'LandIncludeFromLandRecursive2'


class LandArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'LandIncludeFromLandRecursive3'


class LandArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'LandIncludeFromLandRecursive4'


class LandArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyLandArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive1'


class FindManyLandArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive2'


class FindManyLandArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive3'


class FindManyLandArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive4'


class FindManyLandArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    
    

class LandStatisticIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    land: Union[bool, 'LandArgsFromUserRecursive1']


class LandStatisticIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    land: Union[bool, 'LandArgsFromUserRecursive2']


class LandStatisticIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    land: Union[bool, 'LandArgsFromUserRecursive3']


class LandStatisticIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    land: Union[bool, 'LandArgsFromUserRecursive4']


class LandStatisticIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class LandStatisticArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive1'


class LandStatisticArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive2'


class LandStatisticArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive3'


class LandStatisticArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive4'


class LandStatisticArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyLandStatisticArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive1'


class FindManyLandStatisticArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive2'


class FindManyLandStatisticArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive3'


class FindManyLandStatisticArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive4'


class FindManyLandStatisticArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    
    

class CropIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    land: Union[bool, 'LandArgsFromUserRecursive1']


class CropIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    land: Union[bool, 'LandArgsFromUserRecursive2']


class CropIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    land: Union[bool, 'LandArgsFromUserRecursive3']


class CropIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    land: Union[bool, 'LandArgsFromUserRecursive4']


class CropIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class CropArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'CropIncludeFromCropRecursive1'


class CropArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'CropIncludeFromCropRecursive2'


class CropArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'CropIncludeFromCropRecursive3'


class CropArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'CropIncludeFromCropRecursive4'


class CropArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyCropArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive1'


class FindManyCropArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive2'


class FindManyCropArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive3'


class FindManyCropArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive4'


class FindManyCropArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    
    

class CropMaintenanceIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    land: Union[bool, 'LandArgsFromUserRecursive1']


class CropMaintenanceIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    land: Union[bool, 'LandArgsFromUserRecursive2']


class CropMaintenanceIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    land: Union[bool, 'LandArgsFromUserRecursive3']


class CropMaintenanceIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    land: Union[bool, 'LandArgsFromUserRecursive4']


class CropMaintenanceIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class CropMaintenanceArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive1'


class CropMaintenanceArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive2'


class CropMaintenanceArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive3'


class CropMaintenanceArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive4'


class CropMaintenanceArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyCropMaintenanceArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive1'


class FindManyCropMaintenanceArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive2'


class FindManyCropMaintenanceArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive3'


class FindManyCropMaintenanceArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive4'


class FindManyCropMaintenanceArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    
    

class FinanceIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    land: Union[bool, 'LandArgsFromUserRecursive1']


class FinanceIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    land: Union[bool, 'LandArgsFromUserRecursive2']


class FinanceIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    land: Union[bool, 'LandArgsFromUserRecursive3']


class FinanceIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    land: Union[bool, 'LandArgsFromUserRecursive4']


class FinanceIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class FinanceArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'FinanceIncludeFromFinanceRecursive1'


class FinanceArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'FinanceIncludeFromFinanceRecursive2'


class FinanceArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'FinanceIncludeFromFinanceRecursive3'


class FinanceArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'FinanceIncludeFromFinanceRecursive4'


class FinanceArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyFinanceArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive1'


class FindManyFinanceArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive2'


class FindManyFinanceArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive3'


class FindManyFinanceArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive4'


class FindManyFinanceArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    
    

class WeatherIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    land: Union[bool, 'LandArgsFromUserRecursive1']


class WeatherIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    land: Union[bool, 'LandArgsFromUserRecursive2']


class WeatherIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    land: Union[bool, 'LandArgsFromUserRecursive3']


class WeatherIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    land: Union[bool, 'LandArgsFromUserRecursive4']


class WeatherIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class WeatherArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'WeatherIncludeFromWeatherRecursive1'


class WeatherArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'WeatherIncludeFromWeatherRecursive2'


class WeatherArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'WeatherIncludeFromWeatherRecursive3'


class WeatherArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'WeatherIncludeFromWeatherRecursive4'


class WeatherArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyWeatherArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive1'


class FindManyWeatherArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive2'


class FindManyWeatherArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive3'


class FindManyWeatherArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive4'


class FindManyWeatherArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    
    

class BusinessPlanIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    land: Union[bool, 'LandArgsFromUserRecursive1']


class BusinessPlanIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    land: Union[bool, 'LandArgsFromUserRecursive2']


class BusinessPlanIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    land: Union[bool, 'LandArgsFromUserRecursive3']


class BusinessPlanIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    land: Union[bool, 'LandArgsFromUserRecursive4']


class BusinessPlanIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class BusinessPlanArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive1'


class BusinessPlanArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive2'


class BusinessPlanArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive3'


class BusinessPlanArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive4'


class BusinessPlanArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyBusinessPlanArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive1'


class FindManyBusinessPlanArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive2'


class FindManyBusinessPlanArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive3'


class FindManyBusinessPlanArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive4'


class FindManyBusinessPlanArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    


FindManyUserArgs = FindManyUserArgsFromUser
FindFirstUserArgs = FindManyUserArgsFromUser


    

class UserWhereInput(TypedDict, total=False):
    """User arguments for searching"""
    user_id: Union[_str, 'types.StringFilter']
    lands: 'LandListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive1', List['UserWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive1']
    OR: List['UserWhereInputRecursive1']
    NOT: List['UserWhereInputRecursive1']


class UserWhereInputRecursive1(TypedDict, total=False):
    """User arguments for searching"""
    user_id: Union[_str, 'types.StringFilter']
    lands: 'LandListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive2', List['UserWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive2']
    OR: List['UserWhereInputRecursive2']
    NOT: List['UserWhereInputRecursive2']


class UserWhereInputRecursive2(TypedDict, total=False):
    """User arguments for searching"""
    user_id: Union[_str, 'types.StringFilter']
    lands: 'LandListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive3', List['UserWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive3']
    OR: List['UserWhereInputRecursive3']
    NOT: List['UserWhereInputRecursive3']


class UserWhereInputRecursive3(TypedDict, total=False):
    """User arguments for searching"""
    user_id: Union[_str, 'types.StringFilter']
    lands: 'LandListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive4', List['UserWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive4']
    OR: List['UserWhereInputRecursive4']
    NOT: List['UserWhereInputRecursive4']


class UserWhereInputRecursive4(TypedDict, total=False):
    """User arguments for searching"""
    user_id: Union[_str, 'types.StringFilter']
    lands: 'LandListRelationFilter'



# aggregate User types


    

class UserScalarWhereWithAggregatesInput(TypedDict, total=False):
    """User arguments for searching"""
    user_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive1']
    OR: List['UserScalarWhereWithAggregatesInputRecursive1']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive1']


class UserScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """User arguments for searching"""
    user_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive2']
    OR: List['UserScalarWhereWithAggregatesInputRecursive2']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive2']


class UserScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """User arguments for searching"""
    user_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive3']
    OR: List['UserScalarWhereWithAggregatesInputRecursive3']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive3']


class UserScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """User arguments for searching"""
    user_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive4']
    OR: List['UserScalarWhereWithAggregatesInputRecursive4']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive4']


class UserScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """User arguments for searching"""
    user_id: Union[_str, 'types.StringWithAggregatesFilter']



class UserGroupByOutput(TypedDict, total=False):
    user_id: _str
    _sum: 'UserSumAggregateOutput'
    _avg: 'UserAvgAggregateOutput'
    _min: 'UserMinAggregateOutput'
    _max: 'UserMaxAggregateOutput'
    _count: 'UserCountAggregateOutput'


class UserAvgAggregateOutput(TypedDict, total=False):
    """User output for aggregating averages"""


class UserSumAggregateOutput(TypedDict, total=False):
    """User output for aggregating sums"""


class UserScalarAggregateOutput(TypedDict, total=False):
    """User output including scalar fields"""
    user_id: _str


UserMinAggregateOutput = UserScalarAggregateOutput
UserMaxAggregateOutput = UserScalarAggregateOutput


class UserMaxAggregateInput(TypedDict, total=False):
    """User input for aggregating by max"""
    user_id: bool


class UserMinAggregateInput(TypedDict, total=False):
    """User input for aggregating by min"""
    user_id: bool


class UserNumberAggregateInput(TypedDict, total=False):
    """User input for aggregating numbers"""


UserAvgAggregateInput = UserNumberAggregateInput
UserSumAggregateInput = UserNumberAggregateInput


UserCountAggregateInput = TypedDict(
    'UserCountAggregateInput',
    {
        'user_id': bool,
        '_all': bool,
    },
    total=False,
)

UserCountAggregateOutput = TypedDict(
    'UserCountAggregateOutput',
    {
        'user_id': int,
        '_all': int,
    },
    total=False,
)


UserKeys = Literal[
    'user_id',
    'lands',
]
UserScalarFieldKeys = Literal[
    'user_id',
]
UserScalarFieldKeysT = TypeVar('UserScalarFieldKeysT', bound=UserScalarFieldKeys)

UserRelationalFieldKeys = Literal[
        'lands',
    ]

# Land types

class LandOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Land create method"""
    land_id: _str
    land_name: Optional[_str]
    land_image: Optional[_str]
    user_id: _str
    user: 'UserCreateNestedWithoutRelationsInput'
    statistics: 'LandStatisticCreateManyNestedWithoutRelationsInput'
    crops: 'CropCreateManyNestedWithoutRelationsInput'
    maintenances: 'CropMaintenanceCreateManyNestedWithoutRelationsInput'
    finances: 'FinanceCreateManyNestedWithoutRelationsInput'
    weather_data: 'WeatherCreateManyNestedWithoutRelationsInput'
    business_plans: 'BusinessPlanCreateManyNestedWithoutRelationsInput'


class LandCreateInput(LandOptionalCreateInput):
    """Required arguments to the Land create method"""
    latitude: _float
    longitude: _float
    land_size: _float
    ph_level: _float
    phosphorus: _float
    potassium: _float
    oxygen_level: _float
    nitrogen: _float


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class LandOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Land create method, without relations"""
    land_id: _str
    land_name: Optional[_str]
    land_image: Optional[_str]
    user_id: _str


class LandCreateWithoutRelationsInput(LandOptionalCreateWithoutRelationsInput):
    """Required arguments to the Land create method, without relations"""
    latitude: _float
    longitude: _float
    land_size: _float
    ph_level: _float
    phosphorus: _float
    potassium: _float
    oxygen_level: _float
    nitrogen: _float

class LandConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'LandCreateWithoutRelationsInput'
    where: 'LandWhereUniqueInput'

class LandCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'LandCreateWithoutRelationsInput'
    connect: 'LandWhereUniqueInput'
    connect_or_create: 'LandConnectOrCreateWithoutRelationsInput'


class LandCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['LandCreateWithoutRelationsInput', List['LandCreateWithoutRelationsInput']]
    connect: Union['LandWhereUniqueInput', List['LandWhereUniqueInput']]
    connect_or_create: Union['LandConnectOrCreateWithoutRelationsInput', List['LandConnectOrCreateWithoutRelationsInput']]

_LandWhereUnique_land_id_Input = TypedDict(
    '_LandWhereUnique_land_id_Input',
    {
        'land_id': '_str',
    },
    total=True
)

_LandCompoundlatitude_longitudeKeyInner = TypedDict(
    '_LandCompoundlatitude_longitudeKeyInner',
    {
        'latitude': '_float',
        'longitude': '_float',
    },
    total=True
)

_LandCompoundlatitude_longitudeKey = TypedDict(
    '_LandCompoundlatitude_longitudeKey',
    {
        'latitude_longitude': '_LandCompoundlatitude_longitudeKeyInner',
    },
    total=True
)

LandWhereUniqueInput = Union[
    '_LandWhereUnique_land_id_Input',
    '_LandCompoundlatitude_longitudeKey',
]


class LandUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    land_id: _str
    latitude: Union[AtomicFloatInput, _float]
    longitude: Union[AtomicFloatInput, _float]
    land_size: Union[AtomicFloatInput, _float]
    land_name: Optional[_str]
    land_image: Optional[_str]
    ph_level: Union[AtomicFloatInput, _float]
    phosphorus: Union[AtomicFloatInput, _float]
    potassium: Union[AtomicFloatInput, _float]
    oxygen_level: Union[AtomicFloatInput, _float]
    nitrogen: Union[AtomicFloatInput, _float]
    user: 'UserUpdateOneWithoutRelationsInput'
    statistics: 'LandStatisticUpdateManyWithoutRelationsInput'
    crops: 'CropUpdateManyWithoutRelationsInput'
    maintenances: 'CropMaintenanceUpdateManyWithoutRelationsInput'
    finances: 'FinanceUpdateManyWithoutRelationsInput'
    weather_data: 'WeatherUpdateManyWithoutRelationsInput'
    business_plans: 'BusinessPlanUpdateManyWithoutRelationsInput'


class LandUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    land_id: _str
    latitude: Union[AtomicFloatInput, _float]
    longitude: Union[AtomicFloatInput, _float]
    land_size: Union[AtomicFloatInput, _float]
    land_name: Optional[_str]
    land_image: Optional[_str]
    ph_level: Union[AtomicFloatInput, _float]
    phosphorus: Union[AtomicFloatInput, _float]
    potassium: Union[AtomicFloatInput, _float]
    oxygen_level: Union[AtomicFloatInput, _float]
    nitrogen: Union[AtomicFloatInput, _float]


class LandUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['LandCreateWithoutRelationsInput']
    connect: List['LandWhereUniqueInput']
    connect_or_create: List['LandConnectOrCreateWithoutRelationsInput']
    set: List['LandWhereUniqueInput']
    disconnect: List['LandWhereUniqueInput']
    delete: List['LandWhereUniqueInput']

    # TODO
    # update: List['LandUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['LandUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['LandScalarWhereInput']
    # upsert: List['LandUpserteWithWhereUniqueWithoutRelationsInput']


class LandUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'LandCreateWithoutRelationsInput'
    connect: 'LandWhereUniqueInput'
    connect_or_create: 'LandConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'LandUpdateInput'
    # upsert: 'LandUpsertWithoutRelationsInput'


class LandUpsertInput(TypedDict):
    create: 'LandCreateInput'
    update: 'LandUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Land_land_id_OrderByInput = TypedDict(
    '_Land_land_id_OrderByInput',
    {
        'land_id': 'SortOrder',
    },
    total=True
)

_Land_latitude_OrderByInput = TypedDict(
    '_Land_latitude_OrderByInput',
    {
        'latitude': 'SortOrder',
    },
    total=True
)

_Land_longitude_OrderByInput = TypedDict(
    '_Land_longitude_OrderByInput',
    {
        'longitude': 'SortOrder',
    },
    total=True
)

_Land_land_size_OrderByInput = TypedDict(
    '_Land_land_size_OrderByInput',
    {
        'land_size': 'SortOrder',
    },
    total=True
)

_Land_land_name_OrderByInput = TypedDict(
    '_Land_land_name_OrderByInput',
    {
        'land_name': 'SortOrder',
    },
    total=True
)

_Land_land_image_OrderByInput = TypedDict(
    '_Land_land_image_OrderByInput',
    {
        'land_image': 'SortOrder',
    },
    total=True
)

_Land_ph_level_OrderByInput = TypedDict(
    '_Land_ph_level_OrderByInput',
    {
        'ph_level': 'SortOrder',
    },
    total=True
)

_Land_phosphorus_OrderByInput = TypedDict(
    '_Land_phosphorus_OrderByInput',
    {
        'phosphorus': 'SortOrder',
    },
    total=True
)

_Land_potassium_OrderByInput = TypedDict(
    '_Land_potassium_OrderByInput',
    {
        'potassium': 'SortOrder',
    },
    total=True
)

_Land_oxygen_level_OrderByInput = TypedDict(
    '_Land_oxygen_level_OrderByInput',
    {
        'oxygen_level': 'SortOrder',
    },
    total=True
)

_Land_nitrogen_OrderByInput = TypedDict(
    '_Land_nitrogen_OrderByInput',
    {
        'nitrogen': 'SortOrder',
    },
    total=True
)

_Land_user_id_OrderByInput = TypedDict(
    '_Land_user_id_OrderByInput',
    {
        'user_id': 'SortOrder',
    },
    total=True
)

_Land_RelevanceInner = TypedDict(
    '_Land_RelevanceInner',
    {
        'fields': 'List[LandScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Land_RelevanceOrderByInput = TypedDict(
    '_Land_RelevanceOrderByInput',
    {
        '_relevance': '_Land_RelevanceInner',
    },
    total=True
)

LandOrderByInput = Union[
    '_Land_land_id_OrderByInput',
    '_Land_latitude_OrderByInput',
    '_Land_longitude_OrderByInput',
    '_Land_land_size_OrderByInput',
    '_Land_land_name_OrderByInput',
    '_Land_land_image_OrderByInput',
    '_Land_ph_level_OrderByInput',
    '_Land_phosphorus_OrderByInput',
    '_Land_potassium_OrderByInput',
    '_Land_oxygen_level_OrderByInput',
    '_Land_nitrogen_OrderByInput',
    '_Land_user_id_OrderByInput',
    '_Land_RelevanceOrderByInput',
]



# recursive Land types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

LandRelationFilter = TypedDict(
    'LandRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class LandListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class LandInclude(TypedDict, total=False):
    """Land relational arguments"""
    user: Union[bool, 'UserArgsFromLand']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromLand']
    crops: Union[bool, 'FindManyCropArgsFromLand']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromLand']
    finances: Union[bool, 'FindManyFinanceArgsFromLand']
    weather_data: Union[bool, 'FindManyWeatherArgsFromLand']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromLand']


    

class UserIncludeFromLand(TypedDict, total=False):
    """Relational arguments for Land"""
    lands: Union[bool, 'FindManyLandArgsFromLandRecursive1']


class UserIncludeFromLandRecursive1(TypedDict, total=False):
    """Relational arguments for Land"""
    lands: Union[bool, 'FindManyLandArgsFromLandRecursive2']


class UserIncludeFromLandRecursive2(TypedDict, total=False):
    """Relational arguments for Land"""
    lands: Union[bool, 'FindManyLandArgsFromLandRecursive3']


class UserIncludeFromLandRecursive3(TypedDict, total=False):
    """Relational arguments for Land"""
    lands: Union[bool, 'FindManyLandArgsFromLandRecursive4']


class UserIncludeFromLandRecursive4(TypedDict, total=False):
    """Relational arguments for Land"""

    

class UserArgsFromLand(TypedDict, total=False):
    """Arguments for Land"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromLandRecursive1(TypedDict, total=False):
    """Arguments for Land"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromLandRecursive2(TypedDict, total=False):
    """Arguments for Land"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromLandRecursive3(TypedDict, total=False):
    """Arguments for Land"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromLandRecursive4(TypedDict, total=False):
    """Arguments for Land"""
    
    

class FindManyUserArgsFromLand(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromLandRecursive1(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromLandRecursive2(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromLandRecursive3(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromLandRecursive4(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class LandIncludeFromLand(TypedDict, total=False):
    """Relational arguments for Land"""
    user: Union[bool, 'UserArgsFromLandRecursive1']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromLandRecursive1']
    crops: Union[bool, 'FindManyCropArgsFromLandRecursive1']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromLandRecursive1']
    finances: Union[bool, 'FindManyFinanceArgsFromLandRecursive1']
    weather_data: Union[bool, 'FindManyWeatherArgsFromLandRecursive1']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromLandRecursive1']


class LandIncludeFromLandRecursive1(TypedDict, total=False):
    """Relational arguments for Land"""
    user: Union[bool, 'UserArgsFromLandRecursive2']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromLandRecursive2']
    crops: Union[bool, 'FindManyCropArgsFromLandRecursive2']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromLandRecursive2']
    finances: Union[bool, 'FindManyFinanceArgsFromLandRecursive2']
    weather_data: Union[bool, 'FindManyWeatherArgsFromLandRecursive2']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromLandRecursive2']


class LandIncludeFromLandRecursive2(TypedDict, total=False):
    """Relational arguments for Land"""
    user: Union[bool, 'UserArgsFromLandRecursive3']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromLandRecursive3']
    crops: Union[bool, 'FindManyCropArgsFromLandRecursive3']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromLandRecursive3']
    finances: Union[bool, 'FindManyFinanceArgsFromLandRecursive3']
    weather_data: Union[bool, 'FindManyWeatherArgsFromLandRecursive3']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromLandRecursive3']


class LandIncludeFromLandRecursive3(TypedDict, total=False):
    """Relational arguments for Land"""
    user: Union[bool, 'UserArgsFromLandRecursive4']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromLandRecursive4']
    crops: Union[bool, 'FindManyCropArgsFromLandRecursive4']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromLandRecursive4']
    finances: Union[bool, 'FindManyFinanceArgsFromLandRecursive4']
    weather_data: Union[bool, 'FindManyWeatherArgsFromLandRecursive4']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromLandRecursive4']


class LandIncludeFromLandRecursive4(TypedDict, total=False):
    """Relational arguments for Land"""

    

class LandArgsFromLand(TypedDict, total=False):
    """Arguments for Land"""
    include: 'LandIncludeFromLandRecursive1'


class LandArgsFromLandRecursive1(TypedDict, total=False):
    """Arguments for Land"""
    include: 'LandIncludeFromLandRecursive2'


class LandArgsFromLandRecursive2(TypedDict, total=False):
    """Arguments for Land"""
    include: 'LandIncludeFromLandRecursive3'


class LandArgsFromLandRecursive3(TypedDict, total=False):
    """Arguments for Land"""
    include: 'LandIncludeFromLandRecursive4'


class LandArgsFromLandRecursive4(TypedDict, total=False):
    """Arguments for Land"""
    
    

class FindManyLandArgsFromLand(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive1'


class FindManyLandArgsFromLandRecursive1(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive2'


class FindManyLandArgsFromLandRecursive2(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive3'


class FindManyLandArgsFromLandRecursive3(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive4'


class FindManyLandArgsFromLandRecursive4(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    
    

class LandStatisticIncludeFromLand(TypedDict, total=False):
    """Relational arguments for Land"""
    land: Union[bool, 'LandArgsFromLandRecursive1']


class LandStatisticIncludeFromLandRecursive1(TypedDict, total=False):
    """Relational arguments for Land"""
    land: Union[bool, 'LandArgsFromLandRecursive2']


class LandStatisticIncludeFromLandRecursive2(TypedDict, total=False):
    """Relational arguments for Land"""
    land: Union[bool, 'LandArgsFromLandRecursive3']


class LandStatisticIncludeFromLandRecursive3(TypedDict, total=False):
    """Relational arguments for Land"""
    land: Union[bool, 'LandArgsFromLandRecursive4']


class LandStatisticIncludeFromLandRecursive4(TypedDict, total=False):
    """Relational arguments for Land"""

    

class LandStatisticArgsFromLand(TypedDict, total=False):
    """Arguments for Land"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive1'


class LandStatisticArgsFromLandRecursive1(TypedDict, total=False):
    """Arguments for Land"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive2'


class LandStatisticArgsFromLandRecursive2(TypedDict, total=False):
    """Arguments for Land"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive3'


class LandStatisticArgsFromLandRecursive3(TypedDict, total=False):
    """Arguments for Land"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive4'


class LandStatisticArgsFromLandRecursive4(TypedDict, total=False):
    """Arguments for Land"""
    
    

class FindManyLandStatisticArgsFromLand(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive1'


class FindManyLandStatisticArgsFromLandRecursive1(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive2'


class FindManyLandStatisticArgsFromLandRecursive2(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive3'


class FindManyLandStatisticArgsFromLandRecursive3(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive4'


class FindManyLandStatisticArgsFromLandRecursive4(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    
    

class CropIncludeFromLand(TypedDict, total=False):
    """Relational arguments for Land"""
    land: Union[bool, 'LandArgsFromLandRecursive1']


class CropIncludeFromLandRecursive1(TypedDict, total=False):
    """Relational arguments for Land"""
    land: Union[bool, 'LandArgsFromLandRecursive2']


class CropIncludeFromLandRecursive2(TypedDict, total=False):
    """Relational arguments for Land"""
    land: Union[bool, 'LandArgsFromLandRecursive3']


class CropIncludeFromLandRecursive3(TypedDict, total=False):
    """Relational arguments for Land"""
    land: Union[bool, 'LandArgsFromLandRecursive4']


class CropIncludeFromLandRecursive4(TypedDict, total=False):
    """Relational arguments for Land"""

    

class CropArgsFromLand(TypedDict, total=False):
    """Arguments for Land"""
    include: 'CropIncludeFromCropRecursive1'


class CropArgsFromLandRecursive1(TypedDict, total=False):
    """Arguments for Land"""
    include: 'CropIncludeFromCropRecursive2'


class CropArgsFromLandRecursive2(TypedDict, total=False):
    """Arguments for Land"""
    include: 'CropIncludeFromCropRecursive3'


class CropArgsFromLandRecursive3(TypedDict, total=False):
    """Arguments for Land"""
    include: 'CropIncludeFromCropRecursive4'


class CropArgsFromLandRecursive4(TypedDict, total=False):
    """Arguments for Land"""
    
    

class FindManyCropArgsFromLand(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive1'


class FindManyCropArgsFromLandRecursive1(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive2'


class FindManyCropArgsFromLandRecursive2(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive3'


class FindManyCropArgsFromLandRecursive3(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive4'


class FindManyCropArgsFromLandRecursive4(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    
    

class CropMaintenanceIncludeFromLand(TypedDict, total=False):
    """Relational arguments for Land"""
    land: Union[bool, 'LandArgsFromLandRecursive1']


class CropMaintenanceIncludeFromLandRecursive1(TypedDict, total=False):
    """Relational arguments for Land"""
    land: Union[bool, 'LandArgsFromLandRecursive2']


class CropMaintenanceIncludeFromLandRecursive2(TypedDict, total=False):
    """Relational arguments for Land"""
    land: Union[bool, 'LandArgsFromLandRecursive3']


class CropMaintenanceIncludeFromLandRecursive3(TypedDict, total=False):
    """Relational arguments for Land"""
    land: Union[bool, 'LandArgsFromLandRecursive4']


class CropMaintenanceIncludeFromLandRecursive4(TypedDict, total=False):
    """Relational arguments for Land"""

    

class CropMaintenanceArgsFromLand(TypedDict, total=False):
    """Arguments for Land"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive1'


class CropMaintenanceArgsFromLandRecursive1(TypedDict, total=False):
    """Arguments for Land"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive2'


class CropMaintenanceArgsFromLandRecursive2(TypedDict, total=False):
    """Arguments for Land"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive3'


class CropMaintenanceArgsFromLandRecursive3(TypedDict, total=False):
    """Arguments for Land"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive4'


class CropMaintenanceArgsFromLandRecursive4(TypedDict, total=False):
    """Arguments for Land"""
    
    

class FindManyCropMaintenanceArgsFromLand(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive1'


class FindManyCropMaintenanceArgsFromLandRecursive1(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive2'


class FindManyCropMaintenanceArgsFromLandRecursive2(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive3'


class FindManyCropMaintenanceArgsFromLandRecursive3(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive4'


class FindManyCropMaintenanceArgsFromLandRecursive4(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    
    

class FinanceIncludeFromLand(TypedDict, total=False):
    """Relational arguments for Land"""
    land: Union[bool, 'LandArgsFromLandRecursive1']


class FinanceIncludeFromLandRecursive1(TypedDict, total=False):
    """Relational arguments for Land"""
    land: Union[bool, 'LandArgsFromLandRecursive2']


class FinanceIncludeFromLandRecursive2(TypedDict, total=False):
    """Relational arguments for Land"""
    land: Union[bool, 'LandArgsFromLandRecursive3']


class FinanceIncludeFromLandRecursive3(TypedDict, total=False):
    """Relational arguments for Land"""
    land: Union[bool, 'LandArgsFromLandRecursive4']


class FinanceIncludeFromLandRecursive4(TypedDict, total=False):
    """Relational arguments for Land"""

    

class FinanceArgsFromLand(TypedDict, total=False):
    """Arguments for Land"""
    include: 'FinanceIncludeFromFinanceRecursive1'


class FinanceArgsFromLandRecursive1(TypedDict, total=False):
    """Arguments for Land"""
    include: 'FinanceIncludeFromFinanceRecursive2'


class FinanceArgsFromLandRecursive2(TypedDict, total=False):
    """Arguments for Land"""
    include: 'FinanceIncludeFromFinanceRecursive3'


class FinanceArgsFromLandRecursive3(TypedDict, total=False):
    """Arguments for Land"""
    include: 'FinanceIncludeFromFinanceRecursive4'


class FinanceArgsFromLandRecursive4(TypedDict, total=False):
    """Arguments for Land"""
    
    

class FindManyFinanceArgsFromLand(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive1'


class FindManyFinanceArgsFromLandRecursive1(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive2'


class FindManyFinanceArgsFromLandRecursive2(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive3'


class FindManyFinanceArgsFromLandRecursive3(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive4'


class FindManyFinanceArgsFromLandRecursive4(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    
    

class WeatherIncludeFromLand(TypedDict, total=False):
    """Relational arguments for Land"""
    land: Union[bool, 'LandArgsFromLandRecursive1']


class WeatherIncludeFromLandRecursive1(TypedDict, total=False):
    """Relational arguments for Land"""
    land: Union[bool, 'LandArgsFromLandRecursive2']


class WeatherIncludeFromLandRecursive2(TypedDict, total=False):
    """Relational arguments for Land"""
    land: Union[bool, 'LandArgsFromLandRecursive3']


class WeatherIncludeFromLandRecursive3(TypedDict, total=False):
    """Relational arguments for Land"""
    land: Union[bool, 'LandArgsFromLandRecursive4']


class WeatherIncludeFromLandRecursive4(TypedDict, total=False):
    """Relational arguments for Land"""

    

class WeatherArgsFromLand(TypedDict, total=False):
    """Arguments for Land"""
    include: 'WeatherIncludeFromWeatherRecursive1'


class WeatherArgsFromLandRecursive1(TypedDict, total=False):
    """Arguments for Land"""
    include: 'WeatherIncludeFromWeatherRecursive2'


class WeatherArgsFromLandRecursive2(TypedDict, total=False):
    """Arguments for Land"""
    include: 'WeatherIncludeFromWeatherRecursive3'


class WeatherArgsFromLandRecursive3(TypedDict, total=False):
    """Arguments for Land"""
    include: 'WeatherIncludeFromWeatherRecursive4'


class WeatherArgsFromLandRecursive4(TypedDict, total=False):
    """Arguments for Land"""
    
    

class FindManyWeatherArgsFromLand(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive1'


class FindManyWeatherArgsFromLandRecursive1(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive2'


class FindManyWeatherArgsFromLandRecursive2(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive3'


class FindManyWeatherArgsFromLandRecursive3(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive4'


class FindManyWeatherArgsFromLandRecursive4(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    
    

class BusinessPlanIncludeFromLand(TypedDict, total=False):
    """Relational arguments for Land"""
    land: Union[bool, 'LandArgsFromLandRecursive1']


class BusinessPlanIncludeFromLandRecursive1(TypedDict, total=False):
    """Relational arguments for Land"""
    land: Union[bool, 'LandArgsFromLandRecursive2']


class BusinessPlanIncludeFromLandRecursive2(TypedDict, total=False):
    """Relational arguments for Land"""
    land: Union[bool, 'LandArgsFromLandRecursive3']


class BusinessPlanIncludeFromLandRecursive3(TypedDict, total=False):
    """Relational arguments for Land"""
    land: Union[bool, 'LandArgsFromLandRecursive4']


class BusinessPlanIncludeFromLandRecursive4(TypedDict, total=False):
    """Relational arguments for Land"""

    

class BusinessPlanArgsFromLand(TypedDict, total=False):
    """Arguments for Land"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive1'


class BusinessPlanArgsFromLandRecursive1(TypedDict, total=False):
    """Arguments for Land"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive2'


class BusinessPlanArgsFromLandRecursive2(TypedDict, total=False):
    """Arguments for Land"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive3'


class BusinessPlanArgsFromLandRecursive3(TypedDict, total=False):
    """Arguments for Land"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive4'


class BusinessPlanArgsFromLandRecursive4(TypedDict, total=False):
    """Arguments for Land"""
    
    

class FindManyBusinessPlanArgsFromLand(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive1'


class FindManyBusinessPlanArgsFromLandRecursive1(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive2'


class FindManyBusinessPlanArgsFromLandRecursive2(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive3'


class FindManyBusinessPlanArgsFromLandRecursive3(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive4'


class FindManyBusinessPlanArgsFromLandRecursive4(TypedDict, total=False):
    """Arguments for Land"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    


FindManyLandArgs = FindManyLandArgsFromLand
FindFirstLandArgs = FindManyLandArgsFromLand


    

class LandWhereInput(TypedDict, total=False):
    """Land arguments for searching"""
    land_id: Union[_str, 'types.StringFilter']
    latitude: Union[_float, 'types.FloatFilter']
    longitude: Union[_float, 'types.FloatFilter']
    land_size: Union[_float, 'types.FloatFilter']
    land_name: Union[None, _str, 'types.StringFilter']
    land_image: Union[None, _str, 'types.StringFilter']
    ph_level: Union[_float, 'types.FloatFilter']
    phosphorus: Union[_float, 'types.FloatFilter']
    potassium: Union[_float, 'types.FloatFilter']
    oxygen_level: Union[_float, 'types.FloatFilter']
    nitrogen: Union[_float, 'types.FloatFilter']
    user_id: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    statistics: 'LandStatisticListRelationFilter'
    crops: 'CropListRelationFilter'
    maintenances: 'CropMaintenanceListRelationFilter'
    finances: 'FinanceListRelationFilter'
    weather_data: 'WeatherListRelationFilter'
    business_plans: 'BusinessPlanListRelationFilter'

    # should be noted that AND and NOT should be Union['LandWhereInputRecursive1', List['LandWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['LandWhereInputRecursive1']
    OR: List['LandWhereInputRecursive1']
    NOT: List['LandWhereInputRecursive1']


class LandWhereInputRecursive1(TypedDict, total=False):
    """Land arguments for searching"""
    land_id: Union[_str, 'types.StringFilter']
    latitude: Union[_float, 'types.FloatFilter']
    longitude: Union[_float, 'types.FloatFilter']
    land_size: Union[_float, 'types.FloatFilter']
    land_name: Union[None, _str, 'types.StringFilter']
    land_image: Union[None, _str, 'types.StringFilter']
    ph_level: Union[_float, 'types.FloatFilter']
    phosphorus: Union[_float, 'types.FloatFilter']
    potassium: Union[_float, 'types.FloatFilter']
    oxygen_level: Union[_float, 'types.FloatFilter']
    nitrogen: Union[_float, 'types.FloatFilter']
    user_id: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    statistics: 'LandStatisticListRelationFilter'
    crops: 'CropListRelationFilter'
    maintenances: 'CropMaintenanceListRelationFilter'
    finances: 'FinanceListRelationFilter'
    weather_data: 'WeatherListRelationFilter'
    business_plans: 'BusinessPlanListRelationFilter'

    # should be noted that AND and NOT should be Union['LandWhereInputRecursive2', List['LandWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['LandWhereInputRecursive2']
    OR: List['LandWhereInputRecursive2']
    NOT: List['LandWhereInputRecursive2']


class LandWhereInputRecursive2(TypedDict, total=False):
    """Land arguments for searching"""
    land_id: Union[_str, 'types.StringFilter']
    latitude: Union[_float, 'types.FloatFilter']
    longitude: Union[_float, 'types.FloatFilter']
    land_size: Union[_float, 'types.FloatFilter']
    land_name: Union[None, _str, 'types.StringFilter']
    land_image: Union[None, _str, 'types.StringFilter']
    ph_level: Union[_float, 'types.FloatFilter']
    phosphorus: Union[_float, 'types.FloatFilter']
    potassium: Union[_float, 'types.FloatFilter']
    oxygen_level: Union[_float, 'types.FloatFilter']
    nitrogen: Union[_float, 'types.FloatFilter']
    user_id: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    statistics: 'LandStatisticListRelationFilter'
    crops: 'CropListRelationFilter'
    maintenances: 'CropMaintenanceListRelationFilter'
    finances: 'FinanceListRelationFilter'
    weather_data: 'WeatherListRelationFilter'
    business_plans: 'BusinessPlanListRelationFilter'

    # should be noted that AND and NOT should be Union['LandWhereInputRecursive3', List['LandWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['LandWhereInputRecursive3']
    OR: List['LandWhereInputRecursive3']
    NOT: List['LandWhereInputRecursive3']


class LandWhereInputRecursive3(TypedDict, total=False):
    """Land arguments for searching"""
    land_id: Union[_str, 'types.StringFilter']
    latitude: Union[_float, 'types.FloatFilter']
    longitude: Union[_float, 'types.FloatFilter']
    land_size: Union[_float, 'types.FloatFilter']
    land_name: Union[None, _str, 'types.StringFilter']
    land_image: Union[None, _str, 'types.StringFilter']
    ph_level: Union[_float, 'types.FloatFilter']
    phosphorus: Union[_float, 'types.FloatFilter']
    potassium: Union[_float, 'types.FloatFilter']
    oxygen_level: Union[_float, 'types.FloatFilter']
    nitrogen: Union[_float, 'types.FloatFilter']
    user_id: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    statistics: 'LandStatisticListRelationFilter'
    crops: 'CropListRelationFilter'
    maintenances: 'CropMaintenanceListRelationFilter'
    finances: 'FinanceListRelationFilter'
    weather_data: 'WeatherListRelationFilter'
    business_plans: 'BusinessPlanListRelationFilter'

    # should be noted that AND and NOT should be Union['LandWhereInputRecursive4', List['LandWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['LandWhereInputRecursive4']
    OR: List['LandWhereInputRecursive4']
    NOT: List['LandWhereInputRecursive4']


class LandWhereInputRecursive4(TypedDict, total=False):
    """Land arguments for searching"""
    land_id: Union[_str, 'types.StringFilter']
    latitude: Union[_float, 'types.FloatFilter']
    longitude: Union[_float, 'types.FloatFilter']
    land_size: Union[_float, 'types.FloatFilter']
    land_name: Union[None, _str, 'types.StringFilter']
    land_image: Union[None, _str, 'types.StringFilter']
    ph_level: Union[_float, 'types.FloatFilter']
    phosphorus: Union[_float, 'types.FloatFilter']
    potassium: Union[_float, 'types.FloatFilter']
    oxygen_level: Union[_float, 'types.FloatFilter']
    nitrogen: Union[_float, 'types.FloatFilter']
    user_id: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    statistics: 'LandStatisticListRelationFilter'
    crops: 'CropListRelationFilter'
    maintenances: 'CropMaintenanceListRelationFilter'
    finances: 'FinanceListRelationFilter'
    weather_data: 'WeatherListRelationFilter'
    business_plans: 'BusinessPlanListRelationFilter'



# aggregate Land types


    

class LandScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Land arguments for searching"""
    land_id: Union[_str, 'types.StringWithAggregatesFilter']
    latitude: Union[_float, 'types.FloatWithAggregatesFilter']
    longitude: Union[_float, 'types.FloatWithAggregatesFilter']
    land_size: Union[_float, 'types.FloatWithAggregatesFilter']
    land_name: Union[_str, 'types.StringWithAggregatesFilter']
    land_image: Union[_str, 'types.StringWithAggregatesFilter']
    ph_level: Union[_float, 'types.FloatWithAggregatesFilter']
    phosphorus: Union[_float, 'types.FloatWithAggregatesFilter']
    potassium: Union[_float, 'types.FloatWithAggregatesFilter']
    oxygen_level: Union[_float, 'types.FloatWithAggregatesFilter']
    nitrogen: Union[_float, 'types.FloatWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['LandScalarWhereWithAggregatesInputRecursive1']
    OR: List['LandScalarWhereWithAggregatesInputRecursive1']
    NOT: List['LandScalarWhereWithAggregatesInputRecursive1']


class LandScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Land arguments for searching"""
    land_id: Union[_str, 'types.StringWithAggregatesFilter']
    latitude: Union[_float, 'types.FloatWithAggregatesFilter']
    longitude: Union[_float, 'types.FloatWithAggregatesFilter']
    land_size: Union[_float, 'types.FloatWithAggregatesFilter']
    land_name: Union[_str, 'types.StringWithAggregatesFilter']
    land_image: Union[_str, 'types.StringWithAggregatesFilter']
    ph_level: Union[_float, 'types.FloatWithAggregatesFilter']
    phosphorus: Union[_float, 'types.FloatWithAggregatesFilter']
    potassium: Union[_float, 'types.FloatWithAggregatesFilter']
    oxygen_level: Union[_float, 'types.FloatWithAggregatesFilter']
    nitrogen: Union[_float, 'types.FloatWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['LandScalarWhereWithAggregatesInputRecursive2']
    OR: List['LandScalarWhereWithAggregatesInputRecursive2']
    NOT: List['LandScalarWhereWithAggregatesInputRecursive2']


class LandScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Land arguments for searching"""
    land_id: Union[_str, 'types.StringWithAggregatesFilter']
    latitude: Union[_float, 'types.FloatWithAggregatesFilter']
    longitude: Union[_float, 'types.FloatWithAggregatesFilter']
    land_size: Union[_float, 'types.FloatWithAggregatesFilter']
    land_name: Union[_str, 'types.StringWithAggregatesFilter']
    land_image: Union[_str, 'types.StringWithAggregatesFilter']
    ph_level: Union[_float, 'types.FloatWithAggregatesFilter']
    phosphorus: Union[_float, 'types.FloatWithAggregatesFilter']
    potassium: Union[_float, 'types.FloatWithAggregatesFilter']
    oxygen_level: Union[_float, 'types.FloatWithAggregatesFilter']
    nitrogen: Union[_float, 'types.FloatWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['LandScalarWhereWithAggregatesInputRecursive3']
    OR: List['LandScalarWhereWithAggregatesInputRecursive3']
    NOT: List['LandScalarWhereWithAggregatesInputRecursive3']


class LandScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Land arguments for searching"""
    land_id: Union[_str, 'types.StringWithAggregatesFilter']
    latitude: Union[_float, 'types.FloatWithAggregatesFilter']
    longitude: Union[_float, 'types.FloatWithAggregatesFilter']
    land_size: Union[_float, 'types.FloatWithAggregatesFilter']
    land_name: Union[_str, 'types.StringWithAggregatesFilter']
    land_image: Union[_str, 'types.StringWithAggregatesFilter']
    ph_level: Union[_float, 'types.FloatWithAggregatesFilter']
    phosphorus: Union[_float, 'types.FloatWithAggregatesFilter']
    potassium: Union[_float, 'types.FloatWithAggregatesFilter']
    oxygen_level: Union[_float, 'types.FloatWithAggregatesFilter']
    nitrogen: Union[_float, 'types.FloatWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['LandScalarWhereWithAggregatesInputRecursive4']
    OR: List['LandScalarWhereWithAggregatesInputRecursive4']
    NOT: List['LandScalarWhereWithAggregatesInputRecursive4']


class LandScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Land arguments for searching"""
    land_id: Union[_str, 'types.StringWithAggregatesFilter']
    latitude: Union[_float, 'types.FloatWithAggregatesFilter']
    longitude: Union[_float, 'types.FloatWithAggregatesFilter']
    land_size: Union[_float, 'types.FloatWithAggregatesFilter']
    land_name: Union[_str, 'types.StringWithAggregatesFilter']
    land_image: Union[_str, 'types.StringWithAggregatesFilter']
    ph_level: Union[_float, 'types.FloatWithAggregatesFilter']
    phosphorus: Union[_float, 'types.FloatWithAggregatesFilter']
    potassium: Union[_float, 'types.FloatWithAggregatesFilter']
    oxygen_level: Union[_float, 'types.FloatWithAggregatesFilter']
    nitrogen: Union[_float, 'types.FloatWithAggregatesFilter']
    user_id: Union[_str, 'types.StringWithAggregatesFilter']



class LandGroupByOutput(TypedDict, total=False):
    land_id: _str
    latitude: _float
    longitude: _float
    land_size: _float
    land_name: _str
    land_image: _str
    ph_level: _float
    phosphorus: _float
    potassium: _float
    oxygen_level: _float
    nitrogen: _float
    user_id: _str
    _sum: 'LandSumAggregateOutput'
    _avg: 'LandAvgAggregateOutput'
    _min: 'LandMinAggregateOutput'
    _max: 'LandMaxAggregateOutput'
    _count: 'LandCountAggregateOutput'


class LandAvgAggregateOutput(TypedDict, total=False):
    """Land output for aggregating averages"""
    latitude: float
    longitude: float
    land_size: float
    ph_level: float
    phosphorus: float
    potassium: float
    oxygen_level: float
    nitrogen: float


class LandSumAggregateOutput(TypedDict, total=False):
    """Land output for aggregating sums"""
    latitude: _float
    longitude: _float
    land_size: _float
    ph_level: _float
    phosphorus: _float
    potassium: _float
    oxygen_level: _float
    nitrogen: _float


class LandScalarAggregateOutput(TypedDict, total=False):
    """Land output including scalar fields"""
    land_id: _str
    latitude: _float
    longitude: _float
    land_size: _float
    land_name: _str
    land_image: _str
    ph_level: _float
    phosphorus: _float
    potassium: _float
    oxygen_level: _float
    nitrogen: _float
    user_id: _str


LandMinAggregateOutput = LandScalarAggregateOutput
LandMaxAggregateOutput = LandScalarAggregateOutput


class LandMaxAggregateInput(TypedDict, total=False):
    """Land input for aggregating by max"""
    land_id: bool
    latitude: bool
    longitude: bool
    land_size: bool
    land_name: bool
    land_image: bool
    ph_level: bool
    phosphorus: bool
    potassium: bool
    oxygen_level: bool
    nitrogen: bool
    user_id: bool


class LandMinAggregateInput(TypedDict, total=False):
    """Land input for aggregating by min"""
    land_id: bool
    latitude: bool
    longitude: bool
    land_size: bool
    land_name: bool
    land_image: bool
    ph_level: bool
    phosphorus: bool
    potassium: bool
    oxygen_level: bool
    nitrogen: bool
    user_id: bool


class LandNumberAggregateInput(TypedDict, total=False):
    """Land input for aggregating numbers"""
    latitude: bool
    longitude: bool
    land_size: bool
    ph_level: bool
    phosphorus: bool
    potassium: bool
    oxygen_level: bool
    nitrogen: bool


LandAvgAggregateInput = LandNumberAggregateInput
LandSumAggregateInput = LandNumberAggregateInput


LandCountAggregateInput = TypedDict(
    'LandCountAggregateInput',
    {
        'land_id': bool,
        'latitude': bool,
        'longitude': bool,
        'land_size': bool,
        'land_name': bool,
        'land_image': bool,
        'ph_level': bool,
        'phosphorus': bool,
        'potassium': bool,
        'oxygen_level': bool,
        'nitrogen': bool,
        'user_id': bool,
        '_all': bool,
    },
    total=False,
)

LandCountAggregateOutput = TypedDict(
    'LandCountAggregateOutput',
    {
        'land_id': int,
        'latitude': int,
        'longitude': int,
        'land_size': int,
        'land_name': int,
        'land_image': int,
        'ph_level': int,
        'phosphorus': int,
        'potassium': int,
        'oxygen_level': int,
        'nitrogen': int,
        'user_id': int,
        '_all': int,
    },
    total=False,
)


LandKeys = Literal[
    'land_id',
    'latitude',
    'longitude',
    'land_size',
    'land_name',
    'land_image',
    'ph_level',
    'phosphorus',
    'potassium',
    'oxygen_level',
    'nitrogen',
    'user_id',
    'user',
    'statistics',
    'crops',
    'maintenances',
    'finances',
    'weather_data',
    'business_plans',
]
LandScalarFieldKeys = Literal[
    'land_id',
    'latitude',
    'longitude',
    'land_size',
    'land_name',
    'land_image',
    'ph_level',
    'phosphorus',
    'potassium',
    'oxygen_level',
    'nitrogen',
    'user_id',
]
LandScalarFieldKeysT = TypeVar('LandScalarFieldKeysT', bound=LandScalarFieldKeys)

LandRelationalFieldKeys = Literal[
        'user',
        'statistics',
        'crops',
        'maintenances',
        'finances',
        'weather_data',
        'business_plans',
    ]

# LandStatistic types

class LandStatisticOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the LandStatistic create method"""
    land_stat_id: _str
    total_profit: _float
    land_id: _str
    land: 'LandCreateNestedWithoutRelationsInput'


class LandStatisticCreateInput(LandStatisticOptionalCreateInput):
    """Required arguments to the LandStatistic create method"""
    land_use: _float
    human_coverage: _float
    water_availability: _float
    distribution_optimality: _float


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class LandStatisticOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the LandStatistic create method, without relations"""
    land_stat_id: _str
    total_profit: _float
    land_id: _str


class LandStatisticCreateWithoutRelationsInput(LandStatisticOptionalCreateWithoutRelationsInput):
    """Required arguments to the LandStatistic create method, without relations"""
    land_use: _float
    human_coverage: _float
    water_availability: _float
    distribution_optimality: _float

class LandStatisticConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'LandStatisticCreateWithoutRelationsInput'
    where: 'LandStatisticWhereUniqueInput'

class LandStatisticCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'LandStatisticCreateWithoutRelationsInput'
    connect: 'LandStatisticWhereUniqueInput'
    connect_or_create: 'LandStatisticConnectOrCreateWithoutRelationsInput'


class LandStatisticCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['LandStatisticCreateWithoutRelationsInput', List['LandStatisticCreateWithoutRelationsInput']]
    connect: Union['LandStatisticWhereUniqueInput', List['LandStatisticWhereUniqueInput']]
    connect_or_create: Union['LandStatisticConnectOrCreateWithoutRelationsInput', List['LandStatisticConnectOrCreateWithoutRelationsInput']]

_LandStatisticWhereUnique_land_stat_id_Input = TypedDict(
    '_LandStatisticWhereUnique_land_stat_id_Input',
    {
        'land_stat_id': '_str',
    },
    total=True
)

_LandStatisticWhereUnique_land_id_Input = TypedDict(
    '_LandStatisticWhereUnique_land_id_Input',
    {
        'land_id': '_str',
    },
    total=True
)

LandStatisticWhereUniqueInput = Union[
    '_LandStatisticWhereUnique_land_stat_id_Input',
    '_LandStatisticWhereUnique_land_id_Input',
]


class LandStatisticUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    land_stat_id: _str
    land_use: Union[AtomicFloatInput, _float]
    human_coverage: Union[AtomicFloatInput, _float]
    water_availability: Union[AtomicFloatInput, _float]
    distribution_optimality: Union[AtomicFloatInput, _float]
    total_profit: Union[AtomicFloatInput, _float]
    land: 'LandUpdateOneWithoutRelationsInput'


class LandStatisticUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    land_stat_id: _str
    land_use: Union[AtomicFloatInput, _float]
    human_coverage: Union[AtomicFloatInput, _float]
    water_availability: Union[AtomicFloatInput, _float]
    distribution_optimality: Union[AtomicFloatInput, _float]
    total_profit: Union[AtomicFloatInput, _float]


class LandStatisticUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['LandStatisticCreateWithoutRelationsInput']
    connect: List['LandStatisticWhereUniqueInput']
    connect_or_create: List['LandStatisticConnectOrCreateWithoutRelationsInput']
    set: List['LandStatisticWhereUniqueInput']
    disconnect: List['LandStatisticWhereUniqueInput']
    delete: List['LandStatisticWhereUniqueInput']

    # TODO
    # update: List['LandStatisticUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['LandStatisticUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['LandStatisticScalarWhereInput']
    # upsert: List['LandStatisticUpserteWithWhereUniqueWithoutRelationsInput']


class LandStatisticUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'LandStatisticCreateWithoutRelationsInput'
    connect: 'LandStatisticWhereUniqueInput'
    connect_or_create: 'LandStatisticConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'LandStatisticUpdateInput'
    # upsert: 'LandStatisticUpsertWithoutRelationsInput'


class LandStatisticUpsertInput(TypedDict):
    create: 'LandStatisticCreateInput'
    update: 'LandStatisticUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_LandStatistic_land_stat_id_OrderByInput = TypedDict(
    '_LandStatistic_land_stat_id_OrderByInput',
    {
        'land_stat_id': 'SortOrder',
    },
    total=True
)

_LandStatistic_land_use_OrderByInput = TypedDict(
    '_LandStatistic_land_use_OrderByInput',
    {
        'land_use': 'SortOrder',
    },
    total=True
)

_LandStatistic_human_coverage_OrderByInput = TypedDict(
    '_LandStatistic_human_coverage_OrderByInput',
    {
        'human_coverage': 'SortOrder',
    },
    total=True
)

_LandStatistic_water_availability_OrderByInput = TypedDict(
    '_LandStatistic_water_availability_OrderByInput',
    {
        'water_availability': 'SortOrder',
    },
    total=True
)

_LandStatistic_distribution_optimality_OrderByInput = TypedDict(
    '_LandStatistic_distribution_optimality_OrderByInput',
    {
        'distribution_optimality': 'SortOrder',
    },
    total=True
)

_LandStatistic_total_profit_OrderByInput = TypedDict(
    '_LandStatistic_total_profit_OrderByInput',
    {
        'total_profit': 'SortOrder',
    },
    total=True
)

_LandStatistic_land_id_OrderByInput = TypedDict(
    '_LandStatistic_land_id_OrderByInput',
    {
        'land_id': 'SortOrder',
    },
    total=True
)

_LandStatistic_RelevanceInner = TypedDict(
    '_LandStatistic_RelevanceInner',
    {
        'fields': 'List[LandStatisticScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_LandStatistic_RelevanceOrderByInput = TypedDict(
    '_LandStatistic_RelevanceOrderByInput',
    {
        '_relevance': '_LandStatistic_RelevanceInner',
    },
    total=True
)

LandStatisticOrderByInput = Union[
    '_LandStatistic_land_stat_id_OrderByInput',
    '_LandStatistic_land_use_OrderByInput',
    '_LandStatistic_human_coverage_OrderByInput',
    '_LandStatistic_water_availability_OrderByInput',
    '_LandStatistic_distribution_optimality_OrderByInput',
    '_LandStatistic_total_profit_OrderByInput',
    '_LandStatistic_land_id_OrderByInput',
    '_LandStatistic_RelevanceOrderByInput',
]



# recursive LandStatistic types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

LandStatisticRelationFilter = TypedDict(
    'LandStatisticRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class LandStatisticListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class LandStatisticInclude(TypedDict, total=False):
    """LandStatistic relational arguments"""
    land: Union[bool, 'LandArgsFromLandStatistic']


    

class UserIncludeFromLandStatistic(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    lands: Union[bool, 'FindManyLandArgsFromLandStatisticRecursive1']


class UserIncludeFromLandStatisticRecursive1(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    lands: Union[bool, 'FindManyLandArgsFromLandStatisticRecursive2']


class UserIncludeFromLandStatisticRecursive2(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    lands: Union[bool, 'FindManyLandArgsFromLandStatisticRecursive3']


class UserIncludeFromLandStatisticRecursive3(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    lands: Union[bool, 'FindManyLandArgsFromLandStatisticRecursive4']


class UserIncludeFromLandStatisticRecursive4(TypedDict, total=False):
    """Relational arguments for LandStatistic"""

    

class UserArgsFromLandStatistic(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromLandStatisticRecursive1(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromLandStatisticRecursive2(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromLandStatisticRecursive3(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromLandStatisticRecursive4(TypedDict, total=False):
    """Arguments for LandStatistic"""
    
    

class FindManyUserArgsFromLandStatistic(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromLandStatisticRecursive1(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromLandStatisticRecursive2(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromLandStatisticRecursive3(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromLandStatisticRecursive4(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class LandIncludeFromLandStatistic(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    user: Union[bool, 'UserArgsFromLandStatisticRecursive1']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromLandStatisticRecursive1']
    crops: Union[bool, 'FindManyCropArgsFromLandStatisticRecursive1']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromLandStatisticRecursive1']
    finances: Union[bool, 'FindManyFinanceArgsFromLandStatisticRecursive1']
    weather_data: Union[bool, 'FindManyWeatherArgsFromLandStatisticRecursive1']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromLandStatisticRecursive1']


class LandIncludeFromLandStatisticRecursive1(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    user: Union[bool, 'UserArgsFromLandStatisticRecursive2']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromLandStatisticRecursive2']
    crops: Union[bool, 'FindManyCropArgsFromLandStatisticRecursive2']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromLandStatisticRecursive2']
    finances: Union[bool, 'FindManyFinanceArgsFromLandStatisticRecursive2']
    weather_data: Union[bool, 'FindManyWeatherArgsFromLandStatisticRecursive2']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromLandStatisticRecursive2']


class LandIncludeFromLandStatisticRecursive2(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    user: Union[bool, 'UserArgsFromLandStatisticRecursive3']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromLandStatisticRecursive3']
    crops: Union[bool, 'FindManyCropArgsFromLandStatisticRecursive3']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromLandStatisticRecursive3']
    finances: Union[bool, 'FindManyFinanceArgsFromLandStatisticRecursive3']
    weather_data: Union[bool, 'FindManyWeatherArgsFromLandStatisticRecursive3']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromLandStatisticRecursive3']


class LandIncludeFromLandStatisticRecursive3(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    user: Union[bool, 'UserArgsFromLandStatisticRecursive4']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromLandStatisticRecursive4']
    crops: Union[bool, 'FindManyCropArgsFromLandStatisticRecursive4']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromLandStatisticRecursive4']
    finances: Union[bool, 'FindManyFinanceArgsFromLandStatisticRecursive4']
    weather_data: Union[bool, 'FindManyWeatherArgsFromLandStatisticRecursive4']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromLandStatisticRecursive4']


class LandIncludeFromLandStatisticRecursive4(TypedDict, total=False):
    """Relational arguments for LandStatistic"""

    

class LandArgsFromLandStatistic(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'LandIncludeFromLandRecursive1'


class LandArgsFromLandStatisticRecursive1(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'LandIncludeFromLandRecursive2'


class LandArgsFromLandStatisticRecursive2(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'LandIncludeFromLandRecursive3'


class LandArgsFromLandStatisticRecursive3(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'LandIncludeFromLandRecursive4'


class LandArgsFromLandStatisticRecursive4(TypedDict, total=False):
    """Arguments for LandStatistic"""
    
    

class FindManyLandArgsFromLandStatistic(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive1'


class FindManyLandArgsFromLandStatisticRecursive1(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive2'


class FindManyLandArgsFromLandStatisticRecursive2(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive3'


class FindManyLandArgsFromLandStatisticRecursive3(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive4'


class FindManyLandArgsFromLandStatisticRecursive4(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    
    

class LandStatisticIncludeFromLandStatistic(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    land: Union[bool, 'LandArgsFromLandStatisticRecursive1']


class LandStatisticIncludeFromLandStatisticRecursive1(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    land: Union[bool, 'LandArgsFromLandStatisticRecursive2']


class LandStatisticIncludeFromLandStatisticRecursive2(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    land: Union[bool, 'LandArgsFromLandStatisticRecursive3']


class LandStatisticIncludeFromLandStatisticRecursive3(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    land: Union[bool, 'LandArgsFromLandStatisticRecursive4']


class LandStatisticIncludeFromLandStatisticRecursive4(TypedDict, total=False):
    """Relational arguments for LandStatistic"""

    

class LandStatisticArgsFromLandStatistic(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive1'


class LandStatisticArgsFromLandStatisticRecursive1(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive2'


class LandStatisticArgsFromLandStatisticRecursive2(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive3'


class LandStatisticArgsFromLandStatisticRecursive3(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive4'


class LandStatisticArgsFromLandStatisticRecursive4(TypedDict, total=False):
    """Arguments for LandStatistic"""
    
    

class FindManyLandStatisticArgsFromLandStatistic(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive1'


class FindManyLandStatisticArgsFromLandStatisticRecursive1(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive2'


class FindManyLandStatisticArgsFromLandStatisticRecursive2(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive3'


class FindManyLandStatisticArgsFromLandStatisticRecursive3(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive4'


class FindManyLandStatisticArgsFromLandStatisticRecursive4(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    
    

class CropIncludeFromLandStatistic(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    land: Union[bool, 'LandArgsFromLandStatisticRecursive1']


class CropIncludeFromLandStatisticRecursive1(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    land: Union[bool, 'LandArgsFromLandStatisticRecursive2']


class CropIncludeFromLandStatisticRecursive2(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    land: Union[bool, 'LandArgsFromLandStatisticRecursive3']


class CropIncludeFromLandStatisticRecursive3(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    land: Union[bool, 'LandArgsFromLandStatisticRecursive4']


class CropIncludeFromLandStatisticRecursive4(TypedDict, total=False):
    """Relational arguments for LandStatistic"""

    

class CropArgsFromLandStatistic(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'CropIncludeFromCropRecursive1'


class CropArgsFromLandStatisticRecursive1(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'CropIncludeFromCropRecursive2'


class CropArgsFromLandStatisticRecursive2(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'CropIncludeFromCropRecursive3'


class CropArgsFromLandStatisticRecursive3(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'CropIncludeFromCropRecursive4'


class CropArgsFromLandStatisticRecursive4(TypedDict, total=False):
    """Arguments for LandStatistic"""
    
    

class FindManyCropArgsFromLandStatistic(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive1'


class FindManyCropArgsFromLandStatisticRecursive1(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive2'


class FindManyCropArgsFromLandStatisticRecursive2(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive3'


class FindManyCropArgsFromLandStatisticRecursive3(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive4'


class FindManyCropArgsFromLandStatisticRecursive4(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    
    

class CropMaintenanceIncludeFromLandStatistic(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    land: Union[bool, 'LandArgsFromLandStatisticRecursive1']


class CropMaintenanceIncludeFromLandStatisticRecursive1(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    land: Union[bool, 'LandArgsFromLandStatisticRecursive2']


class CropMaintenanceIncludeFromLandStatisticRecursive2(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    land: Union[bool, 'LandArgsFromLandStatisticRecursive3']


class CropMaintenanceIncludeFromLandStatisticRecursive3(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    land: Union[bool, 'LandArgsFromLandStatisticRecursive4']


class CropMaintenanceIncludeFromLandStatisticRecursive4(TypedDict, total=False):
    """Relational arguments for LandStatistic"""

    

class CropMaintenanceArgsFromLandStatistic(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive1'


class CropMaintenanceArgsFromLandStatisticRecursive1(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive2'


class CropMaintenanceArgsFromLandStatisticRecursive2(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive3'


class CropMaintenanceArgsFromLandStatisticRecursive3(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive4'


class CropMaintenanceArgsFromLandStatisticRecursive4(TypedDict, total=False):
    """Arguments for LandStatistic"""
    
    

class FindManyCropMaintenanceArgsFromLandStatistic(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive1'


class FindManyCropMaintenanceArgsFromLandStatisticRecursive1(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive2'


class FindManyCropMaintenanceArgsFromLandStatisticRecursive2(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive3'


class FindManyCropMaintenanceArgsFromLandStatisticRecursive3(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive4'


class FindManyCropMaintenanceArgsFromLandStatisticRecursive4(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    
    

class FinanceIncludeFromLandStatistic(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    land: Union[bool, 'LandArgsFromLandStatisticRecursive1']


class FinanceIncludeFromLandStatisticRecursive1(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    land: Union[bool, 'LandArgsFromLandStatisticRecursive2']


class FinanceIncludeFromLandStatisticRecursive2(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    land: Union[bool, 'LandArgsFromLandStatisticRecursive3']


class FinanceIncludeFromLandStatisticRecursive3(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    land: Union[bool, 'LandArgsFromLandStatisticRecursive4']


class FinanceIncludeFromLandStatisticRecursive4(TypedDict, total=False):
    """Relational arguments for LandStatistic"""

    

class FinanceArgsFromLandStatistic(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'FinanceIncludeFromFinanceRecursive1'


class FinanceArgsFromLandStatisticRecursive1(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'FinanceIncludeFromFinanceRecursive2'


class FinanceArgsFromLandStatisticRecursive2(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'FinanceIncludeFromFinanceRecursive3'


class FinanceArgsFromLandStatisticRecursive3(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'FinanceIncludeFromFinanceRecursive4'


class FinanceArgsFromLandStatisticRecursive4(TypedDict, total=False):
    """Arguments for LandStatistic"""
    
    

class FindManyFinanceArgsFromLandStatistic(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive1'


class FindManyFinanceArgsFromLandStatisticRecursive1(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive2'


class FindManyFinanceArgsFromLandStatisticRecursive2(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive3'


class FindManyFinanceArgsFromLandStatisticRecursive3(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive4'


class FindManyFinanceArgsFromLandStatisticRecursive4(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    
    

class WeatherIncludeFromLandStatistic(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    land: Union[bool, 'LandArgsFromLandStatisticRecursive1']


class WeatherIncludeFromLandStatisticRecursive1(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    land: Union[bool, 'LandArgsFromLandStatisticRecursive2']


class WeatherIncludeFromLandStatisticRecursive2(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    land: Union[bool, 'LandArgsFromLandStatisticRecursive3']


class WeatherIncludeFromLandStatisticRecursive3(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    land: Union[bool, 'LandArgsFromLandStatisticRecursive4']


class WeatherIncludeFromLandStatisticRecursive4(TypedDict, total=False):
    """Relational arguments for LandStatistic"""

    

class WeatherArgsFromLandStatistic(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'WeatherIncludeFromWeatherRecursive1'


class WeatherArgsFromLandStatisticRecursive1(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'WeatherIncludeFromWeatherRecursive2'


class WeatherArgsFromLandStatisticRecursive2(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'WeatherIncludeFromWeatherRecursive3'


class WeatherArgsFromLandStatisticRecursive3(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'WeatherIncludeFromWeatherRecursive4'


class WeatherArgsFromLandStatisticRecursive4(TypedDict, total=False):
    """Arguments for LandStatistic"""
    
    

class FindManyWeatherArgsFromLandStatistic(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive1'


class FindManyWeatherArgsFromLandStatisticRecursive1(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive2'


class FindManyWeatherArgsFromLandStatisticRecursive2(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive3'


class FindManyWeatherArgsFromLandStatisticRecursive3(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive4'


class FindManyWeatherArgsFromLandStatisticRecursive4(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    
    

class BusinessPlanIncludeFromLandStatistic(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    land: Union[bool, 'LandArgsFromLandStatisticRecursive1']


class BusinessPlanIncludeFromLandStatisticRecursive1(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    land: Union[bool, 'LandArgsFromLandStatisticRecursive2']


class BusinessPlanIncludeFromLandStatisticRecursive2(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    land: Union[bool, 'LandArgsFromLandStatisticRecursive3']


class BusinessPlanIncludeFromLandStatisticRecursive3(TypedDict, total=False):
    """Relational arguments for LandStatistic"""
    land: Union[bool, 'LandArgsFromLandStatisticRecursive4']


class BusinessPlanIncludeFromLandStatisticRecursive4(TypedDict, total=False):
    """Relational arguments for LandStatistic"""

    

class BusinessPlanArgsFromLandStatistic(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive1'


class BusinessPlanArgsFromLandStatisticRecursive1(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive2'


class BusinessPlanArgsFromLandStatisticRecursive2(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive3'


class BusinessPlanArgsFromLandStatisticRecursive3(TypedDict, total=False):
    """Arguments for LandStatistic"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive4'


class BusinessPlanArgsFromLandStatisticRecursive4(TypedDict, total=False):
    """Arguments for LandStatistic"""
    
    

class FindManyBusinessPlanArgsFromLandStatistic(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive1'


class FindManyBusinessPlanArgsFromLandStatisticRecursive1(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive2'


class FindManyBusinessPlanArgsFromLandStatisticRecursive2(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive3'


class FindManyBusinessPlanArgsFromLandStatisticRecursive3(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive4'


class FindManyBusinessPlanArgsFromLandStatisticRecursive4(TypedDict, total=False):
    """Arguments for LandStatistic"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    


FindManyLandStatisticArgs = FindManyLandStatisticArgsFromLandStatistic
FindFirstLandStatisticArgs = FindManyLandStatisticArgsFromLandStatistic


    

class LandStatisticWhereInput(TypedDict, total=False):
    """LandStatistic arguments for searching"""
    land_stat_id: Union[_str, 'types.StringFilter']
    land_use: Union[_float, 'types.FloatFilter']
    human_coverage: Union[_float, 'types.FloatFilter']
    water_availability: Union[_float, 'types.FloatFilter']
    distribution_optimality: Union[_float, 'types.FloatFilter']
    total_profit: Union[_float, 'types.FloatFilter']
    land_id: Union[_str, 'types.StringFilter']
    land: 'LandRelationFilter'

    # should be noted that AND and NOT should be Union['LandStatisticWhereInputRecursive1', List['LandStatisticWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['LandStatisticWhereInputRecursive1']
    OR: List['LandStatisticWhereInputRecursive1']
    NOT: List['LandStatisticWhereInputRecursive1']


class LandStatisticWhereInputRecursive1(TypedDict, total=False):
    """LandStatistic arguments for searching"""
    land_stat_id: Union[_str, 'types.StringFilter']
    land_use: Union[_float, 'types.FloatFilter']
    human_coverage: Union[_float, 'types.FloatFilter']
    water_availability: Union[_float, 'types.FloatFilter']
    distribution_optimality: Union[_float, 'types.FloatFilter']
    total_profit: Union[_float, 'types.FloatFilter']
    land_id: Union[_str, 'types.StringFilter']
    land: 'LandRelationFilter'

    # should be noted that AND and NOT should be Union['LandStatisticWhereInputRecursive2', List['LandStatisticWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['LandStatisticWhereInputRecursive2']
    OR: List['LandStatisticWhereInputRecursive2']
    NOT: List['LandStatisticWhereInputRecursive2']


class LandStatisticWhereInputRecursive2(TypedDict, total=False):
    """LandStatistic arguments for searching"""
    land_stat_id: Union[_str, 'types.StringFilter']
    land_use: Union[_float, 'types.FloatFilter']
    human_coverage: Union[_float, 'types.FloatFilter']
    water_availability: Union[_float, 'types.FloatFilter']
    distribution_optimality: Union[_float, 'types.FloatFilter']
    total_profit: Union[_float, 'types.FloatFilter']
    land_id: Union[_str, 'types.StringFilter']
    land: 'LandRelationFilter'

    # should be noted that AND and NOT should be Union['LandStatisticWhereInputRecursive3', List['LandStatisticWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['LandStatisticWhereInputRecursive3']
    OR: List['LandStatisticWhereInputRecursive3']
    NOT: List['LandStatisticWhereInputRecursive3']


class LandStatisticWhereInputRecursive3(TypedDict, total=False):
    """LandStatistic arguments for searching"""
    land_stat_id: Union[_str, 'types.StringFilter']
    land_use: Union[_float, 'types.FloatFilter']
    human_coverage: Union[_float, 'types.FloatFilter']
    water_availability: Union[_float, 'types.FloatFilter']
    distribution_optimality: Union[_float, 'types.FloatFilter']
    total_profit: Union[_float, 'types.FloatFilter']
    land_id: Union[_str, 'types.StringFilter']
    land: 'LandRelationFilter'

    # should be noted that AND and NOT should be Union['LandStatisticWhereInputRecursive4', List['LandStatisticWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['LandStatisticWhereInputRecursive4']
    OR: List['LandStatisticWhereInputRecursive4']
    NOT: List['LandStatisticWhereInputRecursive4']


class LandStatisticWhereInputRecursive4(TypedDict, total=False):
    """LandStatistic arguments for searching"""
    land_stat_id: Union[_str, 'types.StringFilter']
    land_use: Union[_float, 'types.FloatFilter']
    human_coverage: Union[_float, 'types.FloatFilter']
    water_availability: Union[_float, 'types.FloatFilter']
    distribution_optimality: Union[_float, 'types.FloatFilter']
    total_profit: Union[_float, 'types.FloatFilter']
    land_id: Union[_str, 'types.StringFilter']
    land: 'LandRelationFilter'



# aggregate LandStatistic types


    

class LandStatisticScalarWhereWithAggregatesInput(TypedDict, total=False):
    """LandStatistic arguments for searching"""
    land_stat_id: Union[_str, 'types.StringWithAggregatesFilter']
    land_use: Union[_float, 'types.FloatWithAggregatesFilter']
    human_coverage: Union[_float, 'types.FloatWithAggregatesFilter']
    water_availability: Union[_float, 'types.FloatWithAggregatesFilter']
    distribution_optimality: Union[_float, 'types.FloatWithAggregatesFilter']
    total_profit: Union[_float, 'types.FloatWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['LandStatisticScalarWhereWithAggregatesInputRecursive1']
    OR: List['LandStatisticScalarWhereWithAggregatesInputRecursive1']
    NOT: List['LandStatisticScalarWhereWithAggregatesInputRecursive1']


class LandStatisticScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """LandStatistic arguments for searching"""
    land_stat_id: Union[_str, 'types.StringWithAggregatesFilter']
    land_use: Union[_float, 'types.FloatWithAggregatesFilter']
    human_coverage: Union[_float, 'types.FloatWithAggregatesFilter']
    water_availability: Union[_float, 'types.FloatWithAggregatesFilter']
    distribution_optimality: Union[_float, 'types.FloatWithAggregatesFilter']
    total_profit: Union[_float, 'types.FloatWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['LandStatisticScalarWhereWithAggregatesInputRecursive2']
    OR: List['LandStatisticScalarWhereWithAggregatesInputRecursive2']
    NOT: List['LandStatisticScalarWhereWithAggregatesInputRecursive2']


class LandStatisticScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """LandStatistic arguments for searching"""
    land_stat_id: Union[_str, 'types.StringWithAggregatesFilter']
    land_use: Union[_float, 'types.FloatWithAggregatesFilter']
    human_coverage: Union[_float, 'types.FloatWithAggregatesFilter']
    water_availability: Union[_float, 'types.FloatWithAggregatesFilter']
    distribution_optimality: Union[_float, 'types.FloatWithAggregatesFilter']
    total_profit: Union[_float, 'types.FloatWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['LandStatisticScalarWhereWithAggregatesInputRecursive3']
    OR: List['LandStatisticScalarWhereWithAggregatesInputRecursive3']
    NOT: List['LandStatisticScalarWhereWithAggregatesInputRecursive3']


class LandStatisticScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """LandStatistic arguments for searching"""
    land_stat_id: Union[_str, 'types.StringWithAggregatesFilter']
    land_use: Union[_float, 'types.FloatWithAggregatesFilter']
    human_coverage: Union[_float, 'types.FloatWithAggregatesFilter']
    water_availability: Union[_float, 'types.FloatWithAggregatesFilter']
    distribution_optimality: Union[_float, 'types.FloatWithAggregatesFilter']
    total_profit: Union[_float, 'types.FloatWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['LandStatisticScalarWhereWithAggregatesInputRecursive4']
    OR: List['LandStatisticScalarWhereWithAggregatesInputRecursive4']
    NOT: List['LandStatisticScalarWhereWithAggregatesInputRecursive4']


class LandStatisticScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """LandStatistic arguments for searching"""
    land_stat_id: Union[_str, 'types.StringWithAggregatesFilter']
    land_use: Union[_float, 'types.FloatWithAggregatesFilter']
    human_coverage: Union[_float, 'types.FloatWithAggregatesFilter']
    water_availability: Union[_float, 'types.FloatWithAggregatesFilter']
    distribution_optimality: Union[_float, 'types.FloatWithAggregatesFilter']
    total_profit: Union[_float, 'types.FloatWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']



class LandStatisticGroupByOutput(TypedDict, total=False):
    land_stat_id: _str
    land_use: _float
    human_coverage: _float
    water_availability: _float
    distribution_optimality: _float
    total_profit: _float
    land_id: _str
    _sum: 'LandStatisticSumAggregateOutput'
    _avg: 'LandStatisticAvgAggregateOutput'
    _min: 'LandStatisticMinAggregateOutput'
    _max: 'LandStatisticMaxAggregateOutput'
    _count: 'LandStatisticCountAggregateOutput'


class LandStatisticAvgAggregateOutput(TypedDict, total=False):
    """LandStatistic output for aggregating averages"""
    land_use: float
    human_coverage: float
    water_availability: float
    distribution_optimality: float
    total_profit: float


class LandStatisticSumAggregateOutput(TypedDict, total=False):
    """LandStatistic output for aggregating sums"""
    land_use: _float
    human_coverage: _float
    water_availability: _float
    distribution_optimality: _float
    total_profit: _float


class LandStatisticScalarAggregateOutput(TypedDict, total=False):
    """LandStatistic output including scalar fields"""
    land_stat_id: _str
    land_use: _float
    human_coverage: _float
    water_availability: _float
    distribution_optimality: _float
    total_profit: _float
    land_id: _str


LandStatisticMinAggregateOutput = LandStatisticScalarAggregateOutput
LandStatisticMaxAggregateOutput = LandStatisticScalarAggregateOutput


class LandStatisticMaxAggregateInput(TypedDict, total=False):
    """LandStatistic input for aggregating by max"""
    land_stat_id: bool
    land_use: bool
    human_coverage: bool
    water_availability: bool
    distribution_optimality: bool
    total_profit: bool
    land_id: bool


class LandStatisticMinAggregateInput(TypedDict, total=False):
    """LandStatistic input for aggregating by min"""
    land_stat_id: bool
    land_use: bool
    human_coverage: bool
    water_availability: bool
    distribution_optimality: bool
    total_profit: bool
    land_id: bool


class LandStatisticNumberAggregateInput(TypedDict, total=False):
    """LandStatistic input for aggregating numbers"""
    land_use: bool
    human_coverage: bool
    water_availability: bool
    distribution_optimality: bool
    total_profit: bool


LandStatisticAvgAggregateInput = LandStatisticNumberAggregateInput
LandStatisticSumAggregateInput = LandStatisticNumberAggregateInput


LandStatisticCountAggregateInput = TypedDict(
    'LandStatisticCountAggregateInput',
    {
        'land_stat_id': bool,
        'land_use': bool,
        'human_coverage': bool,
        'water_availability': bool,
        'distribution_optimality': bool,
        'total_profit': bool,
        'land_id': bool,
        '_all': bool,
    },
    total=False,
)

LandStatisticCountAggregateOutput = TypedDict(
    'LandStatisticCountAggregateOutput',
    {
        'land_stat_id': int,
        'land_use': int,
        'human_coverage': int,
        'water_availability': int,
        'distribution_optimality': int,
        'total_profit': int,
        'land_id': int,
        '_all': int,
    },
    total=False,
)


LandStatisticKeys = Literal[
    'land_stat_id',
    'land_use',
    'human_coverage',
    'water_availability',
    'distribution_optimality',
    'total_profit',
    'land_id',
    'land',
]
LandStatisticScalarFieldKeys = Literal[
    'land_stat_id',
    'land_use',
    'human_coverage',
    'water_availability',
    'distribution_optimality',
    'total_profit',
    'land_id',
]
LandStatisticScalarFieldKeysT = TypeVar('LandStatisticScalarFieldKeysT', bound=LandStatisticScalarFieldKeys)

LandStatisticRelationalFieldKeys = Literal[
        'land',
    ]

# Crop types

class CropOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Crop create method"""
    crop_id: _str
    land_id: _str
    land: 'LandCreateNestedWithoutRelationsInput'


class CropCreateInput(CropOptionalCreateInput):
    """Required arguments to the Crop create method"""
    crop_name: _str
    crop_area: _float
    crop_investment: _float
    expected_money_return: _float
    expected_weight_return: _float


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class CropOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Crop create method, without relations"""
    crop_id: _str
    land_id: _str


class CropCreateWithoutRelationsInput(CropOptionalCreateWithoutRelationsInput):
    """Required arguments to the Crop create method, without relations"""
    crop_name: _str
    crop_area: _float
    crop_investment: _float
    expected_money_return: _float
    expected_weight_return: _float

class CropConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'CropCreateWithoutRelationsInput'
    where: 'CropWhereUniqueInput'

class CropCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'CropCreateWithoutRelationsInput'
    connect: 'CropWhereUniqueInput'
    connect_or_create: 'CropConnectOrCreateWithoutRelationsInput'


class CropCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['CropCreateWithoutRelationsInput', List['CropCreateWithoutRelationsInput']]
    connect: Union['CropWhereUniqueInput', List['CropWhereUniqueInput']]
    connect_or_create: Union['CropConnectOrCreateWithoutRelationsInput', List['CropConnectOrCreateWithoutRelationsInput']]

_CropWhereUnique_crop_id_Input = TypedDict(
    '_CropWhereUnique_crop_id_Input',
    {
        'crop_id': '_str',
    },
    total=True
)

CropWhereUniqueInput = _CropWhereUnique_crop_id_Input


class CropUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    crop_id: _str
    crop_name: _str
    crop_area: Union[AtomicFloatInput, _float]
    crop_investment: Union[AtomicFloatInput, _float]
    expected_money_return: Union[AtomicFloatInput, _float]
    expected_weight_return: Union[AtomicFloatInput, _float]
    land: 'LandUpdateOneWithoutRelationsInput'


class CropUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    crop_id: _str
    crop_name: _str
    crop_area: Union[AtomicFloatInput, _float]
    crop_investment: Union[AtomicFloatInput, _float]
    expected_money_return: Union[AtomicFloatInput, _float]
    expected_weight_return: Union[AtomicFloatInput, _float]


class CropUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['CropCreateWithoutRelationsInput']
    connect: List['CropWhereUniqueInput']
    connect_or_create: List['CropConnectOrCreateWithoutRelationsInput']
    set: List['CropWhereUniqueInput']
    disconnect: List['CropWhereUniqueInput']
    delete: List['CropWhereUniqueInput']

    # TODO
    # update: List['CropUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['CropUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['CropScalarWhereInput']
    # upsert: List['CropUpserteWithWhereUniqueWithoutRelationsInput']


class CropUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'CropCreateWithoutRelationsInput'
    connect: 'CropWhereUniqueInput'
    connect_or_create: 'CropConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'CropUpdateInput'
    # upsert: 'CropUpsertWithoutRelationsInput'


class CropUpsertInput(TypedDict):
    create: 'CropCreateInput'
    update: 'CropUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Crop_crop_id_OrderByInput = TypedDict(
    '_Crop_crop_id_OrderByInput',
    {
        'crop_id': 'SortOrder',
    },
    total=True
)

_Crop_crop_name_OrderByInput = TypedDict(
    '_Crop_crop_name_OrderByInput',
    {
        'crop_name': 'SortOrder',
    },
    total=True
)

_Crop_crop_area_OrderByInput = TypedDict(
    '_Crop_crop_area_OrderByInput',
    {
        'crop_area': 'SortOrder',
    },
    total=True
)

_Crop_crop_investment_OrderByInput = TypedDict(
    '_Crop_crop_investment_OrderByInput',
    {
        'crop_investment': 'SortOrder',
    },
    total=True
)

_Crop_expected_money_return_OrderByInput = TypedDict(
    '_Crop_expected_money_return_OrderByInput',
    {
        'expected_money_return': 'SortOrder',
    },
    total=True
)

_Crop_expected_weight_return_OrderByInput = TypedDict(
    '_Crop_expected_weight_return_OrderByInput',
    {
        'expected_weight_return': 'SortOrder',
    },
    total=True
)

_Crop_land_id_OrderByInput = TypedDict(
    '_Crop_land_id_OrderByInput',
    {
        'land_id': 'SortOrder',
    },
    total=True
)

_Crop_RelevanceInner = TypedDict(
    '_Crop_RelevanceInner',
    {
        'fields': 'List[CropScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Crop_RelevanceOrderByInput = TypedDict(
    '_Crop_RelevanceOrderByInput',
    {
        '_relevance': '_Crop_RelevanceInner',
    },
    total=True
)

CropOrderByInput = Union[
    '_Crop_crop_id_OrderByInput',
    '_Crop_crop_name_OrderByInput',
    '_Crop_crop_area_OrderByInput',
    '_Crop_crop_investment_OrderByInput',
    '_Crop_expected_money_return_OrderByInput',
    '_Crop_expected_weight_return_OrderByInput',
    '_Crop_land_id_OrderByInput',
    '_Crop_RelevanceOrderByInput',
]



# recursive Crop types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

CropRelationFilter = TypedDict(
    'CropRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class CropListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class CropInclude(TypedDict, total=False):
    """Crop relational arguments"""
    land: Union[bool, 'LandArgsFromCrop']


    

class UserIncludeFromCrop(TypedDict, total=False):
    """Relational arguments for Crop"""
    lands: Union[bool, 'FindManyLandArgsFromCropRecursive1']


class UserIncludeFromCropRecursive1(TypedDict, total=False):
    """Relational arguments for Crop"""
    lands: Union[bool, 'FindManyLandArgsFromCropRecursive2']


class UserIncludeFromCropRecursive2(TypedDict, total=False):
    """Relational arguments for Crop"""
    lands: Union[bool, 'FindManyLandArgsFromCropRecursive3']


class UserIncludeFromCropRecursive3(TypedDict, total=False):
    """Relational arguments for Crop"""
    lands: Union[bool, 'FindManyLandArgsFromCropRecursive4']


class UserIncludeFromCropRecursive4(TypedDict, total=False):
    """Relational arguments for Crop"""

    

class UserArgsFromCrop(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromCropRecursive1(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromCropRecursive2(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromCropRecursive3(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromCropRecursive4(TypedDict, total=False):
    """Arguments for Crop"""
    
    

class FindManyUserArgsFromCrop(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromCropRecursive1(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromCropRecursive2(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromCropRecursive3(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromCropRecursive4(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class LandIncludeFromCrop(TypedDict, total=False):
    """Relational arguments for Crop"""
    user: Union[bool, 'UserArgsFromCropRecursive1']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromCropRecursive1']
    crops: Union[bool, 'FindManyCropArgsFromCropRecursive1']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromCropRecursive1']
    finances: Union[bool, 'FindManyFinanceArgsFromCropRecursive1']
    weather_data: Union[bool, 'FindManyWeatherArgsFromCropRecursive1']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromCropRecursive1']


class LandIncludeFromCropRecursive1(TypedDict, total=False):
    """Relational arguments for Crop"""
    user: Union[bool, 'UserArgsFromCropRecursive2']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromCropRecursive2']
    crops: Union[bool, 'FindManyCropArgsFromCropRecursive2']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromCropRecursive2']
    finances: Union[bool, 'FindManyFinanceArgsFromCropRecursive2']
    weather_data: Union[bool, 'FindManyWeatherArgsFromCropRecursive2']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromCropRecursive2']


class LandIncludeFromCropRecursive2(TypedDict, total=False):
    """Relational arguments for Crop"""
    user: Union[bool, 'UserArgsFromCropRecursive3']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromCropRecursive3']
    crops: Union[bool, 'FindManyCropArgsFromCropRecursive3']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromCropRecursive3']
    finances: Union[bool, 'FindManyFinanceArgsFromCropRecursive3']
    weather_data: Union[bool, 'FindManyWeatherArgsFromCropRecursive3']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromCropRecursive3']


class LandIncludeFromCropRecursive3(TypedDict, total=False):
    """Relational arguments for Crop"""
    user: Union[bool, 'UserArgsFromCropRecursive4']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromCropRecursive4']
    crops: Union[bool, 'FindManyCropArgsFromCropRecursive4']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromCropRecursive4']
    finances: Union[bool, 'FindManyFinanceArgsFromCropRecursive4']
    weather_data: Union[bool, 'FindManyWeatherArgsFromCropRecursive4']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromCropRecursive4']


class LandIncludeFromCropRecursive4(TypedDict, total=False):
    """Relational arguments for Crop"""

    

class LandArgsFromCrop(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'LandIncludeFromLandRecursive1'


class LandArgsFromCropRecursive1(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'LandIncludeFromLandRecursive2'


class LandArgsFromCropRecursive2(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'LandIncludeFromLandRecursive3'


class LandArgsFromCropRecursive3(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'LandIncludeFromLandRecursive4'


class LandArgsFromCropRecursive4(TypedDict, total=False):
    """Arguments for Crop"""
    
    

class FindManyLandArgsFromCrop(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive1'


class FindManyLandArgsFromCropRecursive1(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive2'


class FindManyLandArgsFromCropRecursive2(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive3'


class FindManyLandArgsFromCropRecursive3(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive4'


class FindManyLandArgsFromCropRecursive4(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    
    

class LandStatisticIncludeFromCrop(TypedDict, total=False):
    """Relational arguments for Crop"""
    land: Union[bool, 'LandArgsFromCropRecursive1']


class LandStatisticIncludeFromCropRecursive1(TypedDict, total=False):
    """Relational arguments for Crop"""
    land: Union[bool, 'LandArgsFromCropRecursive2']


class LandStatisticIncludeFromCropRecursive2(TypedDict, total=False):
    """Relational arguments for Crop"""
    land: Union[bool, 'LandArgsFromCropRecursive3']


class LandStatisticIncludeFromCropRecursive3(TypedDict, total=False):
    """Relational arguments for Crop"""
    land: Union[bool, 'LandArgsFromCropRecursive4']


class LandStatisticIncludeFromCropRecursive4(TypedDict, total=False):
    """Relational arguments for Crop"""

    

class LandStatisticArgsFromCrop(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive1'


class LandStatisticArgsFromCropRecursive1(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive2'


class LandStatisticArgsFromCropRecursive2(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive3'


class LandStatisticArgsFromCropRecursive3(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive4'


class LandStatisticArgsFromCropRecursive4(TypedDict, total=False):
    """Arguments for Crop"""
    
    

class FindManyLandStatisticArgsFromCrop(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive1'


class FindManyLandStatisticArgsFromCropRecursive1(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive2'


class FindManyLandStatisticArgsFromCropRecursive2(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive3'


class FindManyLandStatisticArgsFromCropRecursive3(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive4'


class FindManyLandStatisticArgsFromCropRecursive4(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    
    

class CropIncludeFromCrop(TypedDict, total=False):
    """Relational arguments for Crop"""
    land: Union[bool, 'LandArgsFromCropRecursive1']


class CropIncludeFromCropRecursive1(TypedDict, total=False):
    """Relational arguments for Crop"""
    land: Union[bool, 'LandArgsFromCropRecursive2']


class CropIncludeFromCropRecursive2(TypedDict, total=False):
    """Relational arguments for Crop"""
    land: Union[bool, 'LandArgsFromCropRecursive3']


class CropIncludeFromCropRecursive3(TypedDict, total=False):
    """Relational arguments for Crop"""
    land: Union[bool, 'LandArgsFromCropRecursive4']


class CropIncludeFromCropRecursive4(TypedDict, total=False):
    """Relational arguments for Crop"""

    

class CropArgsFromCrop(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'CropIncludeFromCropRecursive1'


class CropArgsFromCropRecursive1(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'CropIncludeFromCropRecursive2'


class CropArgsFromCropRecursive2(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'CropIncludeFromCropRecursive3'


class CropArgsFromCropRecursive3(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'CropIncludeFromCropRecursive4'


class CropArgsFromCropRecursive4(TypedDict, total=False):
    """Arguments for Crop"""
    
    

class FindManyCropArgsFromCrop(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive1'


class FindManyCropArgsFromCropRecursive1(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive2'


class FindManyCropArgsFromCropRecursive2(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive3'


class FindManyCropArgsFromCropRecursive3(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive4'


class FindManyCropArgsFromCropRecursive4(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    
    

class CropMaintenanceIncludeFromCrop(TypedDict, total=False):
    """Relational arguments for Crop"""
    land: Union[bool, 'LandArgsFromCropRecursive1']


class CropMaintenanceIncludeFromCropRecursive1(TypedDict, total=False):
    """Relational arguments for Crop"""
    land: Union[bool, 'LandArgsFromCropRecursive2']


class CropMaintenanceIncludeFromCropRecursive2(TypedDict, total=False):
    """Relational arguments for Crop"""
    land: Union[bool, 'LandArgsFromCropRecursive3']


class CropMaintenanceIncludeFromCropRecursive3(TypedDict, total=False):
    """Relational arguments for Crop"""
    land: Union[bool, 'LandArgsFromCropRecursive4']


class CropMaintenanceIncludeFromCropRecursive4(TypedDict, total=False):
    """Relational arguments for Crop"""

    

class CropMaintenanceArgsFromCrop(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive1'


class CropMaintenanceArgsFromCropRecursive1(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive2'


class CropMaintenanceArgsFromCropRecursive2(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive3'


class CropMaintenanceArgsFromCropRecursive3(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive4'


class CropMaintenanceArgsFromCropRecursive4(TypedDict, total=False):
    """Arguments for Crop"""
    
    

class FindManyCropMaintenanceArgsFromCrop(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive1'


class FindManyCropMaintenanceArgsFromCropRecursive1(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive2'


class FindManyCropMaintenanceArgsFromCropRecursive2(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive3'


class FindManyCropMaintenanceArgsFromCropRecursive3(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive4'


class FindManyCropMaintenanceArgsFromCropRecursive4(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    
    

class FinanceIncludeFromCrop(TypedDict, total=False):
    """Relational arguments for Crop"""
    land: Union[bool, 'LandArgsFromCropRecursive1']


class FinanceIncludeFromCropRecursive1(TypedDict, total=False):
    """Relational arguments for Crop"""
    land: Union[bool, 'LandArgsFromCropRecursive2']


class FinanceIncludeFromCropRecursive2(TypedDict, total=False):
    """Relational arguments for Crop"""
    land: Union[bool, 'LandArgsFromCropRecursive3']


class FinanceIncludeFromCropRecursive3(TypedDict, total=False):
    """Relational arguments for Crop"""
    land: Union[bool, 'LandArgsFromCropRecursive4']


class FinanceIncludeFromCropRecursive4(TypedDict, total=False):
    """Relational arguments for Crop"""

    

class FinanceArgsFromCrop(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'FinanceIncludeFromFinanceRecursive1'


class FinanceArgsFromCropRecursive1(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'FinanceIncludeFromFinanceRecursive2'


class FinanceArgsFromCropRecursive2(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'FinanceIncludeFromFinanceRecursive3'


class FinanceArgsFromCropRecursive3(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'FinanceIncludeFromFinanceRecursive4'


class FinanceArgsFromCropRecursive4(TypedDict, total=False):
    """Arguments for Crop"""
    
    

class FindManyFinanceArgsFromCrop(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive1'


class FindManyFinanceArgsFromCropRecursive1(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive2'


class FindManyFinanceArgsFromCropRecursive2(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive3'


class FindManyFinanceArgsFromCropRecursive3(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive4'


class FindManyFinanceArgsFromCropRecursive4(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    
    

class WeatherIncludeFromCrop(TypedDict, total=False):
    """Relational arguments for Crop"""
    land: Union[bool, 'LandArgsFromCropRecursive1']


class WeatherIncludeFromCropRecursive1(TypedDict, total=False):
    """Relational arguments for Crop"""
    land: Union[bool, 'LandArgsFromCropRecursive2']


class WeatherIncludeFromCropRecursive2(TypedDict, total=False):
    """Relational arguments for Crop"""
    land: Union[bool, 'LandArgsFromCropRecursive3']


class WeatherIncludeFromCropRecursive3(TypedDict, total=False):
    """Relational arguments for Crop"""
    land: Union[bool, 'LandArgsFromCropRecursive4']


class WeatherIncludeFromCropRecursive4(TypedDict, total=False):
    """Relational arguments for Crop"""

    

class WeatherArgsFromCrop(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'WeatherIncludeFromWeatherRecursive1'


class WeatherArgsFromCropRecursive1(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'WeatherIncludeFromWeatherRecursive2'


class WeatherArgsFromCropRecursive2(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'WeatherIncludeFromWeatherRecursive3'


class WeatherArgsFromCropRecursive3(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'WeatherIncludeFromWeatherRecursive4'


class WeatherArgsFromCropRecursive4(TypedDict, total=False):
    """Arguments for Crop"""
    
    

class FindManyWeatherArgsFromCrop(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive1'


class FindManyWeatherArgsFromCropRecursive1(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive2'


class FindManyWeatherArgsFromCropRecursive2(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive3'


class FindManyWeatherArgsFromCropRecursive3(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive4'


class FindManyWeatherArgsFromCropRecursive4(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    
    

class BusinessPlanIncludeFromCrop(TypedDict, total=False):
    """Relational arguments for Crop"""
    land: Union[bool, 'LandArgsFromCropRecursive1']


class BusinessPlanIncludeFromCropRecursive1(TypedDict, total=False):
    """Relational arguments for Crop"""
    land: Union[bool, 'LandArgsFromCropRecursive2']


class BusinessPlanIncludeFromCropRecursive2(TypedDict, total=False):
    """Relational arguments for Crop"""
    land: Union[bool, 'LandArgsFromCropRecursive3']


class BusinessPlanIncludeFromCropRecursive3(TypedDict, total=False):
    """Relational arguments for Crop"""
    land: Union[bool, 'LandArgsFromCropRecursive4']


class BusinessPlanIncludeFromCropRecursive4(TypedDict, total=False):
    """Relational arguments for Crop"""

    

class BusinessPlanArgsFromCrop(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive1'


class BusinessPlanArgsFromCropRecursive1(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive2'


class BusinessPlanArgsFromCropRecursive2(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive3'


class BusinessPlanArgsFromCropRecursive3(TypedDict, total=False):
    """Arguments for Crop"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive4'


class BusinessPlanArgsFromCropRecursive4(TypedDict, total=False):
    """Arguments for Crop"""
    
    

class FindManyBusinessPlanArgsFromCrop(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive1'


class FindManyBusinessPlanArgsFromCropRecursive1(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive2'


class FindManyBusinessPlanArgsFromCropRecursive2(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive3'


class FindManyBusinessPlanArgsFromCropRecursive3(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive4'


class FindManyBusinessPlanArgsFromCropRecursive4(TypedDict, total=False):
    """Arguments for Crop"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    


FindManyCropArgs = FindManyCropArgsFromCrop
FindFirstCropArgs = FindManyCropArgsFromCrop


    

class CropWhereInput(TypedDict, total=False):
    """Crop arguments for searching"""
    crop_id: Union[_str, 'types.StringFilter']
    crop_name: Union[_str, 'types.StringFilter']
    crop_area: Union[_float, 'types.FloatFilter']
    crop_investment: Union[_float, 'types.FloatFilter']
    expected_money_return: Union[_float, 'types.FloatFilter']
    expected_weight_return: Union[_float, 'types.FloatFilter']
    land_id: Union[_str, 'types.StringFilter']
    land: 'LandRelationFilter'

    # should be noted that AND and NOT should be Union['CropWhereInputRecursive1', List['CropWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['CropWhereInputRecursive1']
    OR: List['CropWhereInputRecursive1']
    NOT: List['CropWhereInputRecursive1']


class CropWhereInputRecursive1(TypedDict, total=False):
    """Crop arguments for searching"""
    crop_id: Union[_str, 'types.StringFilter']
    crop_name: Union[_str, 'types.StringFilter']
    crop_area: Union[_float, 'types.FloatFilter']
    crop_investment: Union[_float, 'types.FloatFilter']
    expected_money_return: Union[_float, 'types.FloatFilter']
    expected_weight_return: Union[_float, 'types.FloatFilter']
    land_id: Union[_str, 'types.StringFilter']
    land: 'LandRelationFilter'

    # should be noted that AND and NOT should be Union['CropWhereInputRecursive2', List['CropWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['CropWhereInputRecursive2']
    OR: List['CropWhereInputRecursive2']
    NOT: List['CropWhereInputRecursive2']


class CropWhereInputRecursive2(TypedDict, total=False):
    """Crop arguments for searching"""
    crop_id: Union[_str, 'types.StringFilter']
    crop_name: Union[_str, 'types.StringFilter']
    crop_area: Union[_float, 'types.FloatFilter']
    crop_investment: Union[_float, 'types.FloatFilter']
    expected_money_return: Union[_float, 'types.FloatFilter']
    expected_weight_return: Union[_float, 'types.FloatFilter']
    land_id: Union[_str, 'types.StringFilter']
    land: 'LandRelationFilter'

    # should be noted that AND and NOT should be Union['CropWhereInputRecursive3', List['CropWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['CropWhereInputRecursive3']
    OR: List['CropWhereInputRecursive3']
    NOT: List['CropWhereInputRecursive3']


class CropWhereInputRecursive3(TypedDict, total=False):
    """Crop arguments for searching"""
    crop_id: Union[_str, 'types.StringFilter']
    crop_name: Union[_str, 'types.StringFilter']
    crop_area: Union[_float, 'types.FloatFilter']
    crop_investment: Union[_float, 'types.FloatFilter']
    expected_money_return: Union[_float, 'types.FloatFilter']
    expected_weight_return: Union[_float, 'types.FloatFilter']
    land_id: Union[_str, 'types.StringFilter']
    land: 'LandRelationFilter'

    # should be noted that AND and NOT should be Union['CropWhereInputRecursive4', List['CropWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['CropWhereInputRecursive4']
    OR: List['CropWhereInputRecursive4']
    NOT: List['CropWhereInputRecursive4']


class CropWhereInputRecursive4(TypedDict, total=False):
    """Crop arguments for searching"""
    crop_id: Union[_str, 'types.StringFilter']
    crop_name: Union[_str, 'types.StringFilter']
    crop_area: Union[_float, 'types.FloatFilter']
    crop_investment: Union[_float, 'types.FloatFilter']
    expected_money_return: Union[_float, 'types.FloatFilter']
    expected_weight_return: Union[_float, 'types.FloatFilter']
    land_id: Union[_str, 'types.StringFilter']
    land: 'LandRelationFilter'



# aggregate Crop types


    

class CropScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Crop arguments for searching"""
    crop_id: Union[_str, 'types.StringWithAggregatesFilter']
    crop_name: Union[_str, 'types.StringWithAggregatesFilter']
    crop_area: Union[_float, 'types.FloatWithAggregatesFilter']
    crop_investment: Union[_float, 'types.FloatWithAggregatesFilter']
    expected_money_return: Union[_float, 'types.FloatWithAggregatesFilter']
    expected_weight_return: Union[_float, 'types.FloatWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['CropScalarWhereWithAggregatesInputRecursive1']
    OR: List['CropScalarWhereWithAggregatesInputRecursive1']
    NOT: List['CropScalarWhereWithAggregatesInputRecursive1']


class CropScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Crop arguments for searching"""
    crop_id: Union[_str, 'types.StringWithAggregatesFilter']
    crop_name: Union[_str, 'types.StringWithAggregatesFilter']
    crop_area: Union[_float, 'types.FloatWithAggregatesFilter']
    crop_investment: Union[_float, 'types.FloatWithAggregatesFilter']
    expected_money_return: Union[_float, 'types.FloatWithAggregatesFilter']
    expected_weight_return: Union[_float, 'types.FloatWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['CropScalarWhereWithAggregatesInputRecursive2']
    OR: List['CropScalarWhereWithAggregatesInputRecursive2']
    NOT: List['CropScalarWhereWithAggregatesInputRecursive2']


class CropScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Crop arguments for searching"""
    crop_id: Union[_str, 'types.StringWithAggregatesFilter']
    crop_name: Union[_str, 'types.StringWithAggregatesFilter']
    crop_area: Union[_float, 'types.FloatWithAggregatesFilter']
    crop_investment: Union[_float, 'types.FloatWithAggregatesFilter']
    expected_money_return: Union[_float, 'types.FloatWithAggregatesFilter']
    expected_weight_return: Union[_float, 'types.FloatWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['CropScalarWhereWithAggregatesInputRecursive3']
    OR: List['CropScalarWhereWithAggregatesInputRecursive3']
    NOT: List['CropScalarWhereWithAggregatesInputRecursive3']


class CropScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Crop arguments for searching"""
    crop_id: Union[_str, 'types.StringWithAggregatesFilter']
    crop_name: Union[_str, 'types.StringWithAggregatesFilter']
    crop_area: Union[_float, 'types.FloatWithAggregatesFilter']
    crop_investment: Union[_float, 'types.FloatWithAggregatesFilter']
    expected_money_return: Union[_float, 'types.FloatWithAggregatesFilter']
    expected_weight_return: Union[_float, 'types.FloatWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['CropScalarWhereWithAggregatesInputRecursive4']
    OR: List['CropScalarWhereWithAggregatesInputRecursive4']
    NOT: List['CropScalarWhereWithAggregatesInputRecursive4']


class CropScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Crop arguments for searching"""
    crop_id: Union[_str, 'types.StringWithAggregatesFilter']
    crop_name: Union[_str, 'types.StringWithAggregatesFilter']
    crop_area: Union[_float, 'types.FloatWithAggregatesFilter']
    crop_investment: Union[_float, 'types.FloatWithAggregatesFilter']
    expected_money_return: Union[_float, 'types.FloatWithAggregatesFilter']
    expected_weight_return: Union[_float, 'types.FloatWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']



class CropGroupByOutput(TypedDict, total=False):
    crop_id: _str
    crop_name: _str
    crop_area: _float
    crop_investment: _float
    expected_money_return: _float
    expected_weight_return: _float
    land_id: _str
    _sum: 'CropSumAggregateOutput'
    _avg: 'CropAvgAggregateOutput'
    _min: 'CropMinAggregateOutput'
    _max: 'CropMaxAggregateOutput'
    _count: 'CropCountAggregateOutput'


class CropAvgAggregateOutput(TypedDict, total=False):
    """Crop output for aggregating averages"""
    crop_area: float
    crop_investment: float
    expected_money_return: float
    expected_weight_return: float


class CropSumAggregateOutput(TypedDict, total=False):
    """Crop output for aggregating sums"""
    crop_area: _float
    crop_investment: _float
    expected_money_return: _float
    expected_weight_return: _float


class CropScalarAggregateOutput(TypedDict, total=False):
    """Crop output including scalar fields"""
    crop_id: _str
    crop_name: _str
    crop_area: _float
    crop_investment: _float
    expected_money_return: _float
    expected_weight_return: _float
    land_id: _str


CropMinAggregateOutput = CropScalarAggregateOutput
CropMaxAggregateOutput = CropScalarAggregateOutput


class CropMaxAggregateInput(TypedDict, total=False):
    """Crop input for aggregating by max"""
    crop_id: bool
    crop_name: bool
    crop_area: bool
    crop_investment: bool
    expected_money_return: bool
    expected_weight_return: bool
    land_id: bool


class CropMinAggregateInput(TypedDict, total=False):
    """Crop input for aggregating by min"""
    crop_id: bool
    crop_name: bool
    crop_area: bool
    crop_investment: bool
    expected_money_return: bool
    expected_weight_return: bool
    land_id: bool


class CropNumberAggregateInput(TypedDict, total=False):
    """Crop input for aggregating numbers"""
    crop_area: bool
    crop_investment: bool
    expected_money_return: bool
    expected_weight_return: bool


CropAvgAggregateInput = CropNumberAggregateInput
CropSumAggregateInput = CropNumberAggregateInput


CropCountAggregateInput = TypedDict(
    'CropCountAggregateInput',
    {
        'crop_id': bool,
        'crop_name': bool,
        'crop_area': bool,
        'crop_investment': bool,
        'expected_money_return': bool,
        'expected_weight_return': bool,
        'land_id': bool,
        '_all': bool,
    },
    total=False,
)

CropCountAggregateOutput = TypedDict(
    'CropCountAggregateOutput',
    {
        'crop_id': int,
        'crop_name': int,
        'crop_area': int,
        'crop_investment': int,
        'expected_money_return': int,
        'expected_weight_return': int,
        'land_id': int,
        '_all': int,
    },
    total=False,
)


CropKeys = Literal[
    'crop_id',
    'crop_name',
    'crop_area',
    'crop_investment',
    'expected_money_return',
    'expected_weight_return',
    'land_id',
    'land',
]
CropScalarFieldKeys = Literal[
    'crop_id',
    'crop_name',
    'crop_area',
    'crop_investment',
    'expected_money_return',
    'expected_weight_return',
    'land_id',
]
CropScalarFieldKeysT = TypeVar('CropScalarFieldKeysT', bound=CropScalarFieldKeys)

CropRelationalFieldKeys = Literal[
        'land',
    ]

# CropMaintenance types

class CropMaintenanceOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the CropMaintenance create method"""
    maintenance_id: _str
    land_id: _str
    land: 'LandCreateNestedWithoutRelationsInput'


class CropMaintenanceCreateInput(CropMaintenanceOptionalCreateInput):
    """Required arguments to the CropMaintenance create method"""
    pesticide_level: _float
    water_sufficienty: _float


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class CropMaintenanceOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the CropMaintenance create method, without relations"""
    maintenance_id: _str
    land_id: _str


class CropMaintenanceCreateWithoutRelationsInput(CropMaintenanceOptionalCreateWithoutRelationsInput):
    """Required arguments to the CropMaintenance create method, without relations"""
    pesticide_level: _float
    water_sufficienty: _float

class CropMaintenanceConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'CropMaintenanceCreateWithoutRelationsInput'
    where: 'CropMaintenanceWhereUniqueInput'

class CropMaintenanceCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'CropMaintenanceCreateWithoutRelationsInput'
    connect: 'CropMaintenanceWhereUniqueInput'
    connect_or_create: 'CropMaintenanceConnectOrCreateWithoutRelationsInput'


class CropMaintenanceCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['CropMaintenanceCreateWithoutRelationsInput', List['CropMaintenanceCreateWithoutRelationsInput']]
    connect: Union['CropMaintenanceWhereUniqueInput', List['CropMaintenanceWhereUniqueInput']]
    connect_or_create: Union['CropMaintenanceConnectOrCreateWithoutRelationsInput', List['CropMaintenanceConnectOrCreateWithoutRelationsInput']]

_CropMaintenanceWhereUnique_maintenance_id_Input = TypedDict(
    '_CropMaintenanceWhereUnique_maintenance_id_Input',
    {
        'maintenance_id': '_str',
    },
    total=True
)

_CropMaintenanceWhereUnique_land_id_Input = TypedDict(
    '_CropMaintenanceWhereUnique_land_id_Input',
    {
        'land_id': '_str',
    },
    total=True
)

CropMaintenanceWhereUniqueInput = Union[
    '_CropMaintenanceWhereUnique_maintenance_id_Input',
    '_CropMaintenanceWhereUnique_land_id_Input',
]


class CropMaintenanceUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    maintenance_id: _str
    pesticide_level: Union[AtomicFloatInput, _float]
    water_sufficienty: Union[AtomicFloatInput, _float]
    land: 'LandUpdateOneWithoutRelationsInput'


class CropMaintenanceUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    maintenance_id: _str
    pesticide_level: Union[AtomicFloatInput, _float]
    water_sufficienty: Union[AtomicFloatInput, _float]


class CropMaintenanceUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['CropMaintenanceCreateWithoutRelationsInput']
    connect: List['CropMaintenanceWhereUniqueInput']
    connect_or_create: List['CropMaintenanceConnectOrCreateWithoutRelationsInput']
    set: List['CropMaintenanceWhereUniqueInput']
    disconnect: List['CropMaintenanceWhereUniqueInput']
    delete: List['CropMaintenanceWhereUniqueInput']

    # TODO
    # update: List['CropMaintenanceUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['CropMaintenanceUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['CropMaintenanceScalarWhereInput']
    # upsert: List['CropMaintenanceUpserteWithWhereUniqueWithoutRelationsInput']


class CropMaintenanceUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'CropMaintenanceCreateWithoutRelationsInput'
    connect: 'CropMaintenanceWhereUniqueInput'
    connect_or_create: 'CropMaintenanceConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'CropMaintenanceUpdateInput'
    # upsert: 'CropMaintenanceUpsertWithoutRelationsInput'


class CropMaintenanceUpsertInput(TypedDict):
    create: 'CropMaintenanceCreateInput'
    update: 'CropMaintenanceUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_CropMaintenance_maintenance_id_OrderByInput = TypedDict(
    '_CropMaintenance_maintenance_id_OrderByInput',
    {
        'maintenance_id': 'SortOrder',
    },
    total=True
)

_CropMaintenance_pesticide_level_OrderByInput = TypedDict(
    '_CropMaintenance_pesticide_level_OrderByInput',
    {
        'pesticide_level': 'SortOrder',
    },
    total=True
)

_CropMaintenance_water_sufficienty_OrderByInput = TypedDict(
    '_CropMaintenance_water_sufficienty_OrderByInput',
    {
        'water_sufficienty': 'SortOrder',
    },
    total=True
)

_CropMaintenance_land_id_OrderByInput = TypedDict(
    '_CropMaintenance_land_id_OrderByInput',
    {
        'land_id': 'SortOrder',
    },
    total=True
)

_CropMaintenance_RelevanceInner = TypedDict(
    '_CropMaintenance_RelevanceInner',
    {
        'fields': 'List[CropMaintenanceScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_CropMaintenance_RelevanceOrderByInput = TypedDict(
    '_CropMaintenance_RelevanceOrderByInput',
    {
        '_relevance': '_CropMaintenance_RelevanceInner',
    },
    total=True
)

CropMaintenanceOrderByInput = Union[
    '_CropMaintenance_maintenance_id_OrderByInput',
    '_CropMaintenance_pesticide_level_OrderByInput',
    '_CropMaintenance_water_sufficienty_OrderByInput',
    '_CropMaintenance_land_id_OrderByInput',
    '_CropMaintenance_RelevanceOrderByInput',
]



# recursive CropMaintenance types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

CropMaintenanceRelationFilter = TypedDict(
    'CropMaintenanceRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class CropMaintenanceListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class CropMaintenanceInclude(TypedDict, total=False):
    """CropMaintenance relational arguments"""
    land: Union[bool, 'LandArgsFromCropMaintenance']


    

class UserIncludeFromCropMaintenance(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    lands: Union[bool, 'FindManyLandArgsFromCropMaintenanceRecursive1']


class UserIncludeFromCropMaintenanceRecursive1(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    lands: Union[bool, 'FindManyLandArgsFromCropMaintenanceRecursive2']


class UserIncludeFromCropMaintenanceRecursive2(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    lands: Union[bool, 'FindManyLandArgsFromCropMaintenanceRecursive3']


class UserIncludeFromCropMaintenanceRecursive3(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    lands: Union[bool, 'FindManyLandArgsFromCropMaintenanceRecursive4']


class UserIncludeFromCropMaintenanceRecursive4(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""

    

class UserArgsFromCropMaintenance(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromCropMaintenanceRecursive1(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromCropMaintenanceRecursive2(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromCropMaintenanceRecursive3(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromCropMaintenanceRecursive4(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    
    

class FindManyUserArgsFromCropMaintenance(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromCropMaintenanceRecursive1(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromCropMaintenanceRecursive2(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromCropMaintenanceRecursive3(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromCropMaintenanceRecursive4(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class LandIncludeFromCropMaintenance(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    user: Union[bool, 'UserArgsFromCropMaintenanceRecursive1']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromCropMaintenanceRecursive1']
    crops: Union[bool, 'FindManyCropArgsFromCropMaintenanceRecursive1']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromCropMaintenanceRecursive1']
    finances: Union[bool, 'FindManyFinanceArgsFromCropMaintenanceRecursive1']
    weather_data: Union[bool, 'FindManyWeatherArgsFromCropMaintenanceRecursive1']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromCropMaintenanceRecursive1']


class LandIncludeFromCropMaintenanceRecursive1(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    user: Union[bool, 'UserArgsFromCropMaintenanceRecursive2']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromCropMaintenanceRecursive2']
    crops: Union[bool, 'FindManyCropArgsFromCropMaintenanceRecursive2']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromCropMaintenanceRecursive2']
    finances: Union[bool, 'FindManyFinanceArgsFromCropMaintenanceRecursive2']
    weather_data: Union[bool, 'FindManyWeatherArgsFromCropMaintenanceRecursive2']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromCropMaintenanceRecursive2']


class LandIncludeFromCropMaintenanceRecursive2(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    user: Union[bool, 'UserArgsFromCropMaintenanceRecursive3']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromCropMaintenanceRecursive3']
    crops: Union[bool, 'FindManyCropArgsFromCropMaintenanceRecursive3']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromCropMaintenanceRecursive3']
    finances: Union[bool, 'FindManyFinanceArgsFromCropMaintenanceRecursive3']
    weather_data: Union[bool, 'FindManyWeatherArgsFromCropMaintenanceRecursive3']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromCropMaintenanceRecursive3']


class LandIncludeFromCropMaintenanceRecursive3(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    user: Union[bool, 'UserArgsFromCropMaintenanceRecursive4']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromCropMaintenanceRecursive4']
    crops: Union[bool, 'FindManyCropArgsFromCropMaintenanceRecursive4']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromCropMaintenanceRecursive4']
    finances: Union[bool, 'FindManyFinanceArgsFromCropMaintenanceRecursive4']
    weather_data: Union[bool, 'FindManyWeatherArgsFromCropMaintenanceRecursive4']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromCropMaintenanceRecursive4']


class LandIncludeFromCropMaintenanceRecursive4(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""

    

class LandArgsFromCropMaintenance(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'LandIncludeFromLandRecursive1'


class LandArgsFromCropMaintenanceRecursive1(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'LandIncludeFromLandRecursive2'


class LandArgsFromCropMaintenanceRecursive2(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'LandIncludeFromLandRecursive3'


class LandArgsFromCropMaintenanceRecursive3(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'LandIncludeFromLandRecursive4'


class LandArgsFromCropMaintenanceRecursive4(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    
    

class FindManyLandArgsFromCropMaintenance(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive1'


class FindManyLandArgsFromCropMaintenanceRecursive1(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive2'


class FindManyLandArgsFromCropMaintenanceRecursive2(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive3'


class FindManyLandArgsFromCropMaintenanceRecursive3(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive4'


class FindManyLandArgsFromCropMaintenanceRecursive4(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    
    

class LandStatisticIncludeFromCropMaintenance(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    land: Union[bool, 'LandArgsFromCropMaintenanceRecursive1']


class LandStatisticIncludeFromCropMaintenanceRecursive1(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    land: Union[bool, 'LandArgsFromCropMaintenanceRecursive2']


class LandStatisticIncludeFromCropMaintenanceRecursive2(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    land: Union[bool, 'LandArgsFromCropMaintenanceRecursive3']


class LandStatisticIncludeFromCropMaintenanceRecursive3(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    land: Union[bool, 'LandArgsFromCropMaintenanceRecursive4']


class LandStatisticIncludeFromCropMaintenanceRecursive4(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""

    

class LandStatisticArgsFromCropMaintenance(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive1'


class LandStatisticArgsFromCropMaintenanceRecursive1(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive2'


class LandStatisticArgsFromCropMaintenanceRecursive2(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive3'


class LandStatisticArgsFromCropMaintenanceRecursive3(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive4'


class LandStatisticArgsFromCropMaintenanceRecursive4(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    
    

class FindManyLandStatisticArgsFromCropMaintenance(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive1'


class FindManyLandStatisticArgsFromCropMaintenanceRecursive1(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive2'


class FindManyLandStatisticArgsFromCropMaintenanceRecursive2(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive3'


class FindManyLandStatisticArgsFromCropMaintenanceRecursive3(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive4'


class FindManyLandStatisticArgsFromCropMaintenanceRecursive4(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    
    

class CropIncludeFromCropMaintenance(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    land: Union[bool, 'LandArgsFromCropMaintenanceRecursive1']


class CropIncludeFromCropMaintenanceRecursive1(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    land: Union[bool, 'LandArgsFromCropMaintenanceRecursive2']


class CropIncludeFromCropMaintenanceRecursive2(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    land: Union[bool, 'LandArgsFromCropMaintenanceRecursive3']


class CropIncludeFromCropMaintenanceRecursive3(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    land: Union[bool, 'LandArgsFromCropMaintenanceRecursive4']


class CropIncludeFromCropMaintenanceRecursive4(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""

    

class CropArgsFromCropMaintenance(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'CropIncludeFromCropRecursive1'


class CropArgsFromCropMaintenanceRecursive1(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'CropIncludeFromCropRecursive2'


class CropArgsFromCropMaintenanceRecursive2(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'CropIncludeFromCropRecursive3'


class CropArgsFromCropMaintenanceRecursive3(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'CropIncludeFromCropRecursive4'


class CropArgsFromCropMaintenanceRecursive4(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    
    

class FindManyCropArgsFromCropMaintenance(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive1'


class FindManyCropArgsFromCropMaintenanceRecursive1(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive2'


class FindManyCropArgsFromCropMaintenanceRecursive2(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive3'


class FindManyCropArgsFromCropMaintenanceRecursive3(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive4'


class FindManyCropArgsFromCropMaintenanceRecursive4(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    
    

class CropMaintenanceIncludeFromCropMaintenance(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    land: Union[bool, 'LandArgsFromCropMaintenanceRecursive1']


class CropMaintenanceIncludeFromCropMaintenanceRecursive1(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    land: Union[bool, 'LandArgsFromCropMaintenanceRecursive2']


class CropMaintenanceIncludeFromCropMaintenanceRecursive2(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    land: Union[bool, 'LandArgsFromCropMaintenanceRecursive3']


class CropMaintenanceIncludeFromCropMaintenanceRecursive3(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    land: Union[bool, 'LandArgsFromCropMaintenanceRecursive4']


class CropMaintenanceIncludeFromCropMaintenanceRecursive4(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""

    

class CropMaintenanceArgsFromCropMaintenance(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive1'


class CropMaintenanceArgsFromCropMaintenanceRecursive1(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive2'


class CropMaintenanceArgsFromCropMaintenanceRecursive2(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive3'


class CropMaintenanceArgsFromCropMaintenanceRecursive3(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive4'


class CropMaintenanceArgsFromCropMaintenanceRecursive4(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    
    

class FindManyCropMaintenanceArgsFromCropMaintenance(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive1'


class FindManyCropMaintenanceArgsFromCropMaintenanceRecursive1(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive2'


class FindManyCropMaintenanceArgsFromCropMaintenanceRecursive2(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive3'


class FindManyCropMaintenanceArgsFromCropMaintenanceRecursive3(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive4'


class FindManyCropMaintenanceArgsFromCropMaintenanceRecursive4(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    
    

class FinanceIncludeFromCropMaintenance(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    land: Union[bool, 'LandArgsFromCropMaintenanceRecursive1']


class FinanceIncludeFromCropMaintenanceRecursive1(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    land: Union[bool, 'LandArgsFromCropMaintenanceRecursive2']


class FinanceIncludeFromCropMaintenanceRecursive2(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    land: Union[bool, 'LandArgsFromCropMaintenanceRecursive3']


class FinanceIncludeFromCropMaintenanceRecursive3(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    land: Union[bool, 'LandArgsFromCropMaintenanceRecursive4']


class FinanceIncludeFromCropMaintenanceRecursive4(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""

    

class FinanceArgsFromCropMaintenance(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'FinanceIncludeFromFinanceRecursive1'


class FinanceArgsFromCropMaintenanceRecursive1(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'FinanceIncludeFromFinanceRecursive2'


class FinanceArgsFromCropMaintenanceRecursive2(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'FinanceIncludeFromFinanceRecursive3'


class FinanceArgsFromCropMaintenanceRecursive3(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'FinanceIncludeFromFinanceRecursive4'


class FinanceArgsFromCropMaintenanceRecursive4(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    
    

class FindManyFinanceArgsFromCropMaintenance(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive1'


class FindManyFinanceArgsFromCropMaintenanceRecursive1(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive2'


class FindManyFinanceArgsFromCropMaintenanceRecursive2(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive3'


class FindManyFinanceArgsFromCropMaintenanceRecursive3(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive4'


class FindManyFinanceArgsFromCropMaintenanceRecursive4(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    
    

class WeatherIncludeFromCropMaintenance(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    land: Union[bool, 'LandArgsFromCropMaintenanceRecursive1']


class WeatherIncludeFromCropMaintenanceRecursive1(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    land: Union[bool, 'LandArgsFromCropMaintenanceRecursive2']


class WeatherIncludeFromCropMaintenanceRecursive2(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    land: Union[bool, 'LandArgsFromCropMaintenanceRecursive3']


class WeatherIncludeFromCropMaintenanceRecursive3(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    land: Union[bool, 'LandArgsFromCropMaintenanceRecursive4']


class WeatherIncludeFromCropMaintenanceRecursive4(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""

    

class WeatherArgsFromCropMaintenance(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'WeatherIncludeFromWeatherRecursive1'


class WeatherArgsFromCropMaintenanceRecursive1(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'WeatherIncludeFromWeatherRecursive2'


class WeatherArgsFromCropMaintenanceRecursive2(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'WeatherIncludeFromWeatherRecursive3'


class WeatherArgsFromCropMaintenanceRecursive3(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'WeatherIncludeFromWeatherRecursive4'


class WeatherArgsFromCropMaintenanceRecursive4(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    
    

class FindManyWeatherArgsFromCropMaintenance(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive1'


class FindManyWeatherArgsFromCropMaintenanceRecursive1(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive2'


class FindManyWeatherArgsFromCropMaintenanceRecursive2(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive3'


class FindManyWeatherArgsFromCropMaintenanceRecursive3(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive4'


class FindManyWeatherArgsFromCropMaintenanceRecursive4(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    
    

class BusinessPlanIncludeFromCropMaintenance(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    land: Union[bool, 'LandArgsFromCropMaintenanceRecursive1']


class BusinessPlanIncludeFromCropMaintenanceRecursive1(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    land: Union[bool, 'LandArgsFromCropMaintenanceRecursive2']


class BusinessPlanIncludeFromCropMaintenanceRecursive2(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    land: Union[bool, 'LandArgsFromCropMaintenanceRecursive3']


class BusinessPlanIncludeFromCropMaintenanceRecursive3(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""
    land: Union[bool, 'LandArgsFromCropMaintenanceRecursive4']


class BusinessPlanIncludeFromCropMaintenanceRecursive4(TypedDict, total=False):
    """Relational arguments for CropMaintenance"""

    

class BusinessPlanArgsFromCropMaintenance(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive1'


class BusinessPlanArgsFromCropMaintenanceRecursive1(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive2'


class BusinessPlanArgsFromCropMaintenanceRecursive2(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive3'


class BusinessPlanArgsFromCropMaintenanceRecursive3(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive4'


class BusinessPlanArgsFromCropMaintenanceRecursive4(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    
    

class FindManyBusinessPlanArgsFromCropMaintenance(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive1'


class FindManyBusinessPlanArgsFromCropMaintenanceRecursive1(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive2'


class FindManyBusinessPlanArgsFromCropMaintenanceRecursive2(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive3'


class FindManyBusinessPlanArgsFromCropMaintenanceRecursive3(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive4'


class FindManyBusinessPlanArgsFromCropMaintenanceRecursive4(TypedDict, total=False):
    """Arguments for CropMaintenance"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    


FindManyCropMaintenanceArgs = FindManyCropMaintenanceArgsFromCropMaintenance
FindFirstCropMaintenanceArgs = FindManyCropMaintenanceArgsFromCropMaintenance


    

class CropMaintenanceWhereInput(TypedDict, total=False):
    """CropMaintenance arguments for searching"""
    maintenance_id: Union[_str, 'types.StringFilter']
    pesticide_level: Union[_float, 'types.FloatFilter']
    water_sufficienty: Union[_float, 'types.FloatFilter']
    land_id: Union[_str, 'types.StringFilter']
    land: 'LandRelationFilter'

    # should be noted that AND and NOT should be Union['CropMaintenanceWhereInputRecursive1', List['CropMaintenanceWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['CropMaintenanceWhereInputRecursive1']
    OR: List['CropMaintenanceWhereInputRecursive1']
    NOT: List['CropMaintenanceWhereInputRecursive1']


class CropMaintenanceWhereInputRecursive1(TypedDict, total=False):
    """CropMaintenance arguments for searching"""
    maintenance_id: Union[_str, 'types.StringFilter']
    pesticide_level: Union[_float, 'types.FloatFilter']
    water_sufficienty: Union[_float, 'types.FloatFilter']
    land_id: Union[_str, 'types.StringFilter']
    land: 'LandRelationFilter'

    # should be noted that AND and NOT should be Union['CropMaintenanceWhereInputRecursive2', List['CropMaintenanceWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['CropMaintenanceWhereInputRecursive2']
    OR: List['CropMaintenanceWhereInputRecursive2']
    NOT: List['CropMaintenanceWhereInputRecursive2']


class CropMaintenanceWhereInputRecursive2(TypedDict, total=False):
    """CropMaintenance arguments for searching"""
    maintenance_id: Union[_str, 'types.StringFilter']
    pesticide_level: Union[_float, 'types.FloatFilter']
    water_sufficienty: Union[_float, 'types.FloatFilter']
    land_id: Union[_str, 'types.StringFilter']
    land: 'LandRelationFilter'

    # should be noted that AND and NOT should be Union['CropMaintenanceWhereInputRecursive3', List['CropMaintenanceWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['CropMaintenanceWhereInputRecursive3']
    OR: List['CropMaintenanceWhereInputRecursive3']
    NOT: List['CropMaintenanceWhereInputRecursive3']


class CropMaintenanceWhereInputRecursive3(TypedDict, total=False):
    """CropMaintenance arguments for searching"""
    maintenance_id: Union[_str, 'types.StringFilter']
    pesticide_level: Union[_float, 'types.FloatFilter']
    water_sufficienty: Union[_float, 'types.FloatFilter']
    land_id: Union[_str, 'types.StringFilter']
    land: 'LandRelationFilter'

    # should be noted that AND and NOT should be Union['CropMaintenanceWhereInputRecursive4', List['CropMaintenanceWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['CropMaintenanceWhereInputRecursive4']
    OR: List['CropMaintenanceWhereInputRecursive4']
    NOT: List['CropMaintenanceWhereInputRecursive4']


class CropMaintenanceWhereInputRecursive4(TypedDict, total=False):
    """CropMaintenance arguments for searching"""
    maintenance_id: Union[_str, 'types.StringFilter']
    pesticide_level: Union[_float, 'types.FloatFilter']
    water_sufficienty: Union[_float, 'types.FloatFilter']
    land_id: Union[_str, 'types.StringFilter']
    land: 'LandRelationFilter'



# aggregate CropMaintenance types


    

class CropMaintenanceScalarWhereWithAggregatesInput(TypedDict, total=False):
    """CropMaintenance arguments for searching"""
    maintenance_id: Union[_str, 'types.StringWithAggregatesFilter']
    pesticide_level: Union[_float, 'types.FloatWithAggregatesFilter']
    water_sufficienty: Union[_float, 'types.FloatWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['CropMaintenanceScalarWhereWithAggregatesInputRecursive1']
    OR: List['CropMaintenanceScalarWhereWithAggregatesInputRecursive1']
    NOT: List['CropMaintenanceScalarWhereWithAggregatesInputRecursive1']


class CropMaintenanceScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """CropMaintenance arguments for searching"""
    maintenance_id: Union[_str, 'types.StringWithAggregatesFilter']
    pesticide_level: Union[_float, 'types.FloatWithAggregatesFilter']
    water_sufficienty: Union[_float, 'types.FloatWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['CropMaintenanceScalarWhereWithAggregatesInputRecursive2']
    OR: List['CropMaintenanceScalarWhereWithAggregatesInputRecursive2']
    NOT: List['CropMaintenanceScalarWhereWithAggregatesInputRecursive2']


class CropMaintenanceScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """CropMaintenance arguments for searching"""
    maintenance_id: Union[_str, 'types.StringWithAggregatesFilter']
    pesticide_level: Union[_float, 'types.FloatWithAggregatesFilter']
    water_sufficienty: Union[_float, 'types.FloatWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['CropMaintenanceScalarWhereWithAggregatesInputRecursive3']
    OR: List['CropMaintenanceScalarWhereWithAggregatesInputRecursive3']
    NOT: List['CropMaintenanceScalarWhereWithAggregatesInputRecursive3']


class CropMaintenanceScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """CropMaintenance arguments for searching"""
    maintenance_id: Union[_str, 'types.StringWithAggregatesFilter']
    pesticide_level: Union[_float, 'types.FloatWithAggregatesFilter']
    water_sufficienty: Union[_float, 'types.FloatWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['CropMaintenanceScalarWhereWithAggregatesInputRecursive4']
    OR: List['CropMaintenanceScalarWhereWithAggregatesInputRecursive4']
    NOT: List['CropMaintenanceScalarWhereWithAggregatesInputRecursive4']


class CropMaintenanceScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """CropMaintenance arguments for searching"""
    maintenance_id: Union[_str, 'types.StringWithAggregatesFilter']
    pesticide_level: Union[_float, 'types.FloatWithAggregatesFilter']
    water_sufficienty: Union[_float, 'types.FloatWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']



class CropMaintenanceGroupByOutput(TypedDict, total=False):
    maintenance_id: _str
    pesticide_level: _float
    water_sufficienty: _float
    land_id: _str
    _sum: 'CropMaintenanceSumAggregateOutput'
    _avg: 'CropMaintenanceAvgAggregateOutput'
    _min: 'CropMaintenanceMinAggregateOutput'
    _max: 'CropMaintenanceMaxAggregateOutput'
    _count: 'CropMaintenanceCountAggregateOutput'


class CropMaintenanceAvgAggregateOutput(TypedDict, total=False):
    """CropMaintenance output for aggregating averages"""
    pesticide_level: float
    water_sufficienty: float


class CropMaintenanceSumAggregateOutput(TypedDict, total=False):
    """CropMaintenance output for aggregating sums"""
    pesticide_level: _float
    water_sufficienty: _float


class CropMaintenanceScalarAggregateOutput(TypedDict, total=False):
    """CropMaintenance output including scalar fields"""
    maintenance_id: _str
    pesticide_level: _float
    water_sufficienty: _float
    land_id: _str


CropMaintenanceMinAggregateOutput = CropMaintenanceScalarAggregateOutput
CropMaintenanceMaxAggregateOutput = CropMaintenanceScalarAggregateOutput


class CropMaintenanceMaxAggregateInput(TypedDict, total=False):
    """CropMaintenance input for aggregating by max"""
    maintenance_id: bool
    pesticide_level: bool
    water_sufficienty: bool
    land_id: bool


class CropMaintenanceMinAggregateInput(TypedDict, total=False):
    """CropMaintenance input for aggregating by min"""
    maintenance_id: bool
    pesticide_level: bool
    water_sufficienty: bool
    land_id: bool


class CropMaintenanceNumberAggregateInput(TypedDict, total=False):
    """CropMaintenance input for aggregating numbers"""
    pesticide_level: bool
    water_sufficienty: bool


CropMaintenanceAvgAggregateInput = CropMaintenanceNumberAggregateInput
CropMaintenanceSumAggregateInput = CropMaintenanceNumberAggregateInput


CropMaintenanceCountAggregateInput = TypedDict(
    'CropMaintenanceCountAggregateInput',
    {
        'maintenance_id': bool,
        'pesticide_level': bool,
        'water_sufficienty': bool,
        'land_id': bool,
        '_all': bool,
    },
    total=False,
)

CropMaintenanceCountAggregateOutput = TypedDict(
    'CropMaintenanceCountAggregateOutput',
    {
        'maintenance_id': int,
        'pesticide_level': int,
        'water_sufficienty': int,
        'land_id': int,
        '_all': int,
    },
    total=False,
)


CropMaintenanceKeys = Literal[
    'maintenance_id',
    'pesticide_level',
    'water_sufficienty',
    'land_id',
    'land',
]
CropMaintenanceScalarFieldKeys = Literal[
    'maintenance_id',
    'pesticide_level',
    'water_sufficienty',
    'land_id',
]
CropMaintenanceScalarFieldKeysT = TypeVar('CropMaintenanceScalarFieldKeysT', bound=CropMaintenanceScalarFieldKeys)

CropMaintenanceRelationalFieldKeys = Literal[
        'land',
    ]

# Finance types

class FinanceOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Finance create method"""
    financial_id: _str
    investment_amount: Optional[_float]
    expected_revenue: Optional[_float]
    land_id: Optional[_str]
    land: 'LandCreateNestedWithoutRelationsInput'


class FinanceCreateInput(FinanceOptionalCreateInput):
    """Required arguments to the Finance create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class FinanceOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Finance create method, without relations"""
    financial_id: _str
    investment_amount: Optional[_float]
    expected_revenue: Optional[_float]
    land_id: Optional[_str]


class FinanceCreateWithoutRelationsInput(FinanceOptionalCreateWithoutRelationsInput):
    """Required arguments to the Finance create method, without relations"""

class FinanceConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'FinanceCreateWithoutRelationsInput'
    where: 'FinanceWhereUniqueInput'

class FinanceCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'FinanceCreateWithoutRelationsInput'
    connect: 'FinanceWhereUniqueInput'
    connect_or_create: 'FinanceConnectOrCreateWithoutRelationsInput'


class FinanceCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['FinanceCreateWithoutRelationsInput', List['FinanceCreateWithoutRelationsInput']]
    connect: Union['FinanceWhereUniqueInput', List['FinanceWhereUniqueInput']]
    connect_or_create: Union['FinanceConnectOrCreateWithoutRelationsInput', List['FinanceConnectOrCreateWithoutRelationsInput']]

_FinanceWhereUnique_financial_id_Input = TypedDict(
    '_FinanceWhereUnique_financial_id_Input',
    {
        'financial_id': '_str',
    },
    total=True
)

_FinanceWhereUnique_land_id_Input = TypedDict(
    '_FinanceWhereUnique_land_id_Input',
    {
        'land_id': '_str',
    },
    total=True
)

FinanceWhereUniqueInput = Union[
    '_FinanceWhereUnique_financial_id_Input',
    '_FinanceWhereUnique_land_id_Input',
]


class FinanceUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    financial_id: _str
    investment_amount: Optional[Union[AtomicFloatInput, _float]]
    expected_revenue: Optional[Union[AtomicFloatInput, _float]]
    land: 'LandUpdateOneWithoutRelationsInput'


class FinanceUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    financial_id: _str
    investment_amount: Optional[Union[AtomicFloatInput, _float]]
    expected_revenue: Optional[Union[AtomicFloatInput, _float]]


class FinanceUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['FinanceCreateWithoutRelationsInput']
    connect: List['FinanceWhereUniqueInput']
    connect_or_create: List['FinanceConnectOrCreateWithoutRelationsInput']
    set: List['FinanceWhereUniqueInput']
    disconnect: List['FinanceWhereUniqueInput']
    delete: List['FinanceWhereUniqueInput']

    # TODO
    # update: List['FinanceUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['FinanceUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['FinanceScalarWhereInput']
    # upsert: List['FinanceUpserteWithWhereUniqueWithoutRelationsInput']


class FinanceUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'FinanceCreateWithoutRelationsInput'
    connect: 'FinanceWhereUniqueInput'
    connect_or_create: 'FinanceConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'FinanceUpdateInput'
    # upsert: 'FinanceUpsertWithoutRelationsInput'


class FinanceUpsertInput(TypedDict):
    create: 'FinanceCreateInput'
    update: 'FinanceUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Finance_financial_id_OrderByInput = TypedDict(
    '_Finance_financial_id_OrderByInput',
    {
        'financial_id': 'SortOrder',
    },
    total=True
)

_Finance_investment_amount_OrderByInput = TypedDict(
    '_Finance_investment_amount_OrderByInput',
    {
        'investment_amount': 'SortOrder',
    },
    total=True
)

_Finance_expected_revenue_OrderByInput = TypedDict(
    '_Finance_expected_revenue_OrderByInput',
    {
        'expected_revenue': 'SortOrder',
    },
    total=True
)

_Finance_land_id_OrderByInput = TypedDict(
    '_Finance_land_id_OrderByInput',
    {
        'land_id': 'SortOrder',
    },
    total=True
)

_Finance_RelevanceInner = TypedDict(
    '_Finance_RelevanceInner',
    {
        'fields': 'List[FinanceScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Finance_RelevanceOrderByInput = TypedDict(
    '_Finance_RelevanceOrderByInput',
    {
        '_relevance': '_Finance_RelevanceInner',
    },
    total=True
)

FinanceOrderByInput = Union[
    '_Finance_financial_id_OrderByInput',
    '_Finance_investment_amount_OrderByInput',
    '_Finance_expected_revenue_OrderByInput',
    '_Finance_land_id_OrderByInput',
    '_Finance_RelevanceOrderByInput',
]



# recursive Finance types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

FinanceRelationFilter = TypedDict(
    'FinanceRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class FinanceListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class FinanceInclude(TypedDict, total=False):
    """Finance relational arguments"""
    land: Union[bool, 'LandArgsFromFinance']


    

class UserIncludeFromFinance(TypedDict, total=False):
    """Relational arguments for Finance"""
    lands: Union[bool, 'FindManyLandArgsFromFinanceRecursive1']


class UserIncludeFromFinanceRecursive1(TypedDict, total=False):
    """Relational arguments for Finance"""
    lands: Union[bool, 'FindManyLandArgsFromFinanceRecursive2']


class UserIncludeFromFinanceRecursive2(TypedDict, total=False):
    """Relational arguments for Finance"""
    lands: Union[bool, 'FindManyLandArgsFromFinanceRecursive3']


class UserIncludeFromFinanceRecursive3(TypedDict, total=False):
    """Relational arguments for Finance"""
    lands: Union[bool, 'FindManyLandArgsFromFinanceRecursive4']


class UserIncludeFromFinanceRecursive4(TypedDict, total=False):
    """Relational arguments for Finance"""

    

class UserArgsFromFinance(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromFinanceRecursive1(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromFinanceRecursive2(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromFinanceRecursive3(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromFinanceRecursive4(TypedDict, total=False):
    """Arguments for Finance"""
    
    

class FindManyUserArgsFromFinance(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromFinanceRecursive1(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromFinanceRecursive2(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromFinanceRecursive3(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromFinanceRecursive4(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class LandIncludeFromFinance(TypedDict, total=False):
    """Relational arguments for Finance"""
    user: Union[bool, 'UserArgsFromFinanceRecursive1']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromFinanceRecursive1']
    crops: Union[bool, 'FindManyCropArgsFromFinanceRecursive1']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromFinanceRecursive1']
    finances: Union[bool, 'FindManyFinanceArgsFromFinanceRecursive1']
    weather_data: Union[bool, 'FindManyWeatherArgsFromFinanceRecursive1']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromFinanceRecursive1']


class LandIncludeFromFinanceRecursive1(TypedDict, total=False):
    """Relational arguments for Finance"""
    user: Union[bool, 'UserArgsFromFinanceRecursive2']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromFinanceRecursive2']
    crops: Union[bool, 'FindManyCropArgsFromFinanceRecursive2']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromFinanceRecursive2']
    finances: Union[bool, 'FindManyFinanceArgsFromFinanceRecursive2']
    weather_data: Union[bool, 'FindManyWeatherArgsFromFinanceRecursive2']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromFinanceRecursive2']


class LandIncludeFromFinanceRecursive2(TypedDict, total=False):
    """Relational arguments for Finance"""
    user: Union[bool, 'UserArgsFromFinanceRecursive3']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromFinanceRecursive3']
    crops: Union[bool, 'FindManyCropArgsFromFinanceRecursive3']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromFinanceRecursive3']
    finances: Union[bool, 'FindManyFinanceArgsFromFinanceRecursive3']
    weather_data: Union[bool, 'FindManyWeatherArgsFromFinanceRecursive3']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromFinanceRecursive3']


class LandIncludeFromFinanceRecursive3(TypedDict, total=False):
    """Relational arguments for Finance"""
    user: Union[bool, 'UserArgsFromFinanceRecursive4']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromFinanceRecursive4']
    crops: Union[bool, 'FindManyCropArgsFromFinanceRecursive4']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromFinanceRecursive4']
    finances: Union[bool, 'FindManyFinanceArgsFromFinanceRecursive4']
    weather_data: Union[bool, 'FindManyWeatherArgsFromFinanceRecursive4']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromFinanceRecursive4']


class LandIncludeFromFinanceRecursive4(TypedDict, total=False):
    """Relational arguments for Finance"""

    

class LandArgsFromFinance(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'LandIncludeFromLandRecursive1'


class LandArgsFromFinanceRecursive1(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'LandIncludeFromLandRecursive2'


class LandArgsFromFinanceRecursive2(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'LandIncludeFromLandRecursive3'


class LandArgsFromFinanceRecursive3(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'LandIncludeFromLandRecursive4'


class LandArgsFromFinanceRecursive4(TypedDict, total=False):
    """Arguments for Finance"""
    
    

class FindManyLandArgsFromFinance(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive1'


class FindManyLandArgsFromFinanceRecursive1(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive2'


class FindManyLandArgsFromFinanceRecursive2(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive3'


class FindManyLandArgsFromFinanceRecursive3(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive4'


class FindManyLandArgsFromFinanceRecursive4(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    
    

class LandStatisticIncludeFromFinance(TypedDict, total=False):
    """Relational arguments for Finance"""
    land: Union[bool, 'LandArgsFromFinanceRecursive1']


class LandStatisticIncludeFromFinanceRecursive1(TypedDict, total=False):
    """Relational arguments for Finance"""
    land: Union[bool, 'LandArgsFromFinanceRecursive2']


class LandStatisticIncludeFromFinanceRecursive2(TypedDict, total=False):
    """Relational arguments for Finance"""
    land: Union[bool, 'LandArgsFromFinanceRecursive3']


class LandStatisticIncludeFromFinanceRecursive3(TypedDict, total=False):
    """Relational arguments for Finance"""
    land: Union[bool, 'LandArgsFromFinanceRecursive4']


class LandStatisticIncludeFromFinanceRecursive4(TypedDict, total=False):
    """Relational arguments for Finance"""

    

class LandStatisticArgsFromFinance(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive1'


class LandStatisticArgsFromFinanceRecursive1(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive2'


class LandStatisticArgsFromFinanceRecursive2(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive3'


class LandStatisticArgsFromFinanceRecursive3(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive4'


class LandStatisticArgsFromFinanceRecursive4(TypedDict, total=False):
    """Arguments for Finance"""
    
    

class FindManyLandStatisticArgsFromFinance(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive1'


class FindManyLandStatisticArgsFromFinanceRecursive1(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive2'


class FindManyLandStatisticArgsFromFinanceRecursive2(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive3'


class FindManyLandStatisticArgsFromFinanceRecursive3(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive4'


class FindManyLandStatisticArgsFromFinanceRecursive4(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    
    

class CropIncludeFromFinance(TypedDict, total=False):
    """Relational arguments for Finance"""
    land: Union[bool, 'LandArgsFromFinanceRecursive1']


class CropIncludeFromFinanceRecursive1(TypedDict, total=False):
    """Relational arguments for Finance"""
    land: Union[bool, 'LandArgsFromFinanceRecursive2']


class CropIncludeFromFinanceRecursive2(TypedDict, total=False):
    """Relational arguments for Finance"""
    land: Union[bool, 'LandArgsFromFinanceRecursive3']


class CropIncludeFromFinanceRecursive3(TypedDict, total=False):
    """Relational arguments for Finance"""
    land: Union[bool, 'LandArgsFromFinanceRecursive4']


class CropIncludeFromFinanceRecursive4(TypedDict, total=False):
    """Relational arguments for Finance"""

    

class CropArgsFromFinance(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'CropIncludeFromCropRecursive1'


class CropArgsFromFinanceRecursive1(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'CropIncludeFromCropRecursive2'


class CropArgsFromFinanceRecursive2(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'CropIncludeFromCropRecursive3'


class CropArgsFromFinanceRecursive3(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'CropIncludeFromCropRecursive4'


class CropArgsFromFinanceRecursive4(TypedDict, total=False):
    """Arguments for Finance"""
    
    

class FindManyCropArgsFromFinance(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive1'


class FindManyCropArgsFromFinanceRecursive1(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive2'


class FindManyCropArgsFromFinanceRecursive2(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive3'


class FindManyCropArgsFromFinanceRecursive3(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive4'


class FindManyCropArgsFromFinanceRecursive4(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    
    

class CropMaintenanceIncludeFromFinance(TypedDict, total=False):
    """Relational arguments for Finance"""
    land: Union[bool, 'LandArgsFromFinanceRecursive1']


class CropMaintenanceIncludeFromFinanceRecursive1(TypedDict, total=False):
    """Relational arguments for Finance"""
    land: Union[bool, 'LandArgsFromFinanceRecursive2']


class CropMaintenanceIncludeFromFinanceRecursive2(TypedDict, total=False):
    """Relational arguments for Finance"""
    land: Union[bool, 'LandArgsFromFinanceRecursive3']


class CropMaintenanceIncludeFromFinanceRecursive3(TypedDict, total=False):
    """Relational arguments for Finance"""
    land: Union[bool, 'LandArgsFromFinanceRecursive4']


class CropMaintenanceIncludeFromFinanceRecursive4(TypedDict, total=False):
    """Relational arguments for Finance"""

    

class CropMaintenanceArgsFromFinance(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive1'


class CropMaintenanceArgsFromFinanceRecursive1(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive2'


class CropMaintenanceArgsFromFinanceRecursive2(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive3'


class CropMaintenanceArgsFromFinanceRecursive3(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive4'


class CropMaintenanceArgsFromFinanceRecursive4(TypedDict, total=False):
    """Arguments for Finance"""
    
    

class FindManyCropMaintenanceArgsFromFinance(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive1'


class FindManyCropMaintenanceArgsFromFinanceRecursive1(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive2'


class FindManyCropMaintenanceArgsFromFinanceRecursive2(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive3'


class FindManyCropMaintenanceArgsFromFinanceRecursive3(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive4'


class FindManyCropMaintenanceArgsFromFinanceRecursive4(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    
    

class FinanceIncludeFromFinance(TypedDict, total=False):
    """Relational arguments for Finance"""
    land: Union[bool, 'LandArgsFromFinanceRecursive1']


class FinanceIncludeFromFinanceRecursive1(TypedDict, total=False):
    """Relational arguments for Finance"""
    land: Union[bool, 'LandArgsFromFinanceRecursive2']


class FinanceIncludeFromFinanceRecursive2(TypedDict, total=False):
    """Relational arguments for Finance"""
    land: Union[bool, 'LandArgsFromFinanceRecursive3']


class FinanceIncludeFromFinanceRecursive3(TypedDict, total=False):
    """Relational arguments for Finance"""
    land: Union[bool, 'LandArgsFromFinanceRecursive4']


class FinanceIncludeFromFinanceRecursive4(TypedDict, total=False):
    """Relational arguments for Finance"""

    

class FinanceArgsFromFinance(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'FinanceIncludeFromFinanceRecursive1'


class FinanceArgsFromFinanceRecursive1(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'FinanceIncludeFromFinanceRecursive2'


class FinanceArgsFromFinanceRecursive2(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'FinanceIncludeFromFinanceRecursive3'


class FinanceArgsFromFinanceRecursive3(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'FinanceIncludeFromFinanceRecursive4'


class FinanceArgsFromFinanceRecursive4(TypedDict, total=False):
    """Arguments for Finance"""
    
    

class FindManyFinanceArgsFromFinance(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive1'


class FindManyFinanceArgsFromFinanceRecursive1(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive2'


class FindManyFinanceArgsFromFinanceRecursive2(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive3'


class FindManyFinanceArgsFromFinanceRecursive3(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive4'


class FindManyFinanceArgsFromFinanceRecursive4(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    
    

class WeatherIncludeFromFinance(TypedDict, total=False):
    """Relational arguments for Finance"""
    land: Union[bool, 'LandArgsFromFinanceRecursive1']


class WeatherIncludeFromFinanceRecursive1(TypedDict, total=False):
    """Relational arguments for Finance"""
    land: Union[bool, 'LandArgsFromFinanceRecursive2']


class WeatherIncludeFromFinanceRecursive2(TypedDict, total=False):
    """Relational arguments for Finance"""
    land: Union[bool, 'LandArgsFromFinanceRecursive3']


class WeatherIncludeFromFinanceRecursive3(TypedDict, total=False):
    """Relational arguments for Finance"""
    land: Union[bool, 'LandArgsFromFinanceRecursive4']


class WeatherIncludeFromFinanceRecursive4(TypedDict, total=False):
    """Relational arguments for Finance"""

    

class WeatherArgsFromFinance(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'WeatherIncludeFromWeatherRecursive1'


class WeatherArgsFromFinanceRecursive1(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'WeatherIncludeFromWeatherRecursive2'


class WeatherArgsFromFinanceRecursive2(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'WeatherIncludeFromWeatherRecursive3'


class WeatherArgsFromFinanceRecursive3(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'WeatherIncludeFromWeatherRecursive4'


class WeatherArgsFromFinanceRecursive4(TypedDict, total=False):
    """Arguments for Finance"""
    
    

class FindManyWeatherArgsFromFinance(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive1'


class FindManyWeatherArgsFromFinanceRecursive1(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive2'


class FindManyWeatherArgsFromFinanceRecursive2(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive3'


class FindManyWeatherArgsFromFinanceRecursive3(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive4'


class FindManyWeatherArgsFromFinanceRecursive4(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    
    

class BusinessPlanIncludeFromFinance(TypedDict, total=False):
    """Relational arguments for Finance"""
    land: Union[bool, 'LandArgsFromFinanceRecursive1']


class BusinessPlanIncludeFromFinanceRecursive1(TypedDict, total=False):
    """Relational arguments for Finance"""
    land: Union[bool, 'LandArgsFromFinanceRecursive2']


class BusinessPlanIncludeFromFinanceRecursive2(TypedDict, total=False):
    """Relational arguments for Finance"""
    land: Union[bool, 'LandArgsFromFinanceRecursive3']


class BusinessPlanIncludeFromFinanceRecursive3(TypedDict, total=False):
    """Relational arguments for Finance"""
    land: Union[bool, 'LandArgsFromFinanceRecursive4']


class BusinessPlanIncludeFromFinanceRecursive4(TypedDict, total=False):
    """Relational arguments for Finance"""

    

class BusinessPlanArgsFromFinance(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive1'


class BusinessPlanArgsFromFinanceRecursive1(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive2'


class BusinessPlanArgsFromFinanceRecursive2(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive3'


class BusinessPlanArgsFromFinanceRecursive3(TypedDict, total=False):
    """Arguments for Finance"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive4'


class BusinessPlanArgsFromFinanceRecursive4(TypedDict, total=False):
    """Arguments for Finance"""
    
    

class FindManyBusinessPlanArgsFromFinance(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive1'


class FindManyBusinessPlanArgsFromFinanceRecursive1(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive2'


class FindManyBusinessPlanArgsFromFinanceRecursive2(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive3'


class FindManyBusinessPlanArgsFromFinanceRecursive3(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive4'


class FindManyBusinessPlanArgsFromFinanceRecursive4(TypedDict, total=False):
    """Arguments for Finance"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    


FindManyFinanceArgs = FindManyFinanceArgsFromFinance
FindFirstFinanceArgs = FindManyFinanceArgsFromFinance


    

class FinanceWhereInput(TypedDict, total=False):
    """Finance arguments for searching"""
    financial_id: Union[_str, 'types.StringFilter']
    investment_amount: Union[None, _float, 'types.FloatFilter']
    expected_revenue: Union[None, _float, 'types.FloatFilter']
    land_id: Union[None, _str, 'types.StringFilter']
    land: 'LandRelationFilter'

    # should be noted that AND and NOT should be Union['FinanceWhereInputRecursive1', List['FinanceWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['FinanceWhereInputRecursive1']
    OR: List['FinanceWhereInputRecursive1']
    NOT: List['FinanceWhereInputRecursive1']


class FinanceWhereInputRecursive1(TypedDict, total=False):
    """Finance arguments for searching"""
    financial_id: Union[_str, 'types.StringFilter']
    investment_amount: Union[None, _float, 'types.FloatFilter']
    expected_revenue: Union[None, _float, 'types.FloatFilter']
    land_id: Union[None, _str, 'types.StringFilter']
    land: 'LandRelationFilter'

    # should be noted that AND and NOT should be Union['FinanceWhereInputRecursive2', List['FinanceWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['FinanceWhereInputRecursive2']
    OR: List['FinanceWhereInputRecursive2']
    NOT: List['FinanceWhereInputRecursive2']


class FinanceWhereInputRecursive2(TypedDict, total=False):
    """Finance arguments for searching"""
    financial_id: Union[_str, 'types.StringFilter']
    investment_amount: Union[None, _float, 'types.FloatFilter']
    expected_revenue: Union[None, _float, 'types.FloatFilter']
    land_id: Union[None, _str, 'types.StringFilter']
    land: 'LandRelationFilter'

    # should be noted that AND and NOT should be Union['FinanceWhereInputRecursive3', List['FinanceWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['FinanceWhereInputRecursive3']
    OR: List['FinanceWhereInputRecursive3']
    NOT: List['FinanceWhereInputRecursive3']


class FinanceWhereInputRecursive3(TypedDict, total=False):
    """Finance arguments for searching"""
    financial_id: Union[_str, 'types.StringFilter']
    investment_amount: Union[None, _float, 'types.FloatFilter']
    expected_revenue: Union[None, _float, 'types.FloatFilter']
    land_id: Union[None, _str, 'types.StringFilter']
    land: 'LandRelationFilter'

    # should be noted that AND and NOT should be Union['FinanceWhereInputRecursive4', List['FinanceWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['FinanceWhereInputRecursive4']
    OR: List['FinanceWhereInputRecursive4']
    NOT: List['FinanceWhereInputRecursive4']


class FinanceWhereInputRecursive4(TypedDict, total=False):
    """Finance arguments for searching"""
    financial_id: Union[_str, 'types.StringFilter']
    investment_amount: Union[None, _float, 'types.FloatFilter']
    expected_revenue: Union[None, _float, 'types.FloatFilter']
    land_id: Union[None, _str, 'types.StringFilter']
    land: 'LandRelationFilter'



# aggregate Finance types


    

class FinanceScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Finance arguments for searching"""
    financial_id: Union[_str, 'types.StringWithAggregatesFilter']
    investment_amount: Union[_float, 'types.FloatWithAggregatesFilter']
    expected_revenue: Union[_float, 'types.FloatWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['FinanceScalarWhereWithAggregatesInputRecursive1']
    OR: List['FinanceScalarWhereWithAggregatesInputRecursive1']
    NOT: List['FinanceScalarWhereWithAggregatesInputRecursive1']


class FinanceScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Finance arguments for searching"""
    financial_id: Union[_str, 'types.StringWithAggregatesFilter']
    investment_amount: Union[_float, 'types.FloatWithAggregatesFilter']
    expected_revenue: Union[_float, 'types.FloatWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['FinanceScalarWhereWithAggregatesInputRecursive2']
    OR: List['FinanceScalarWhereWithAggregatesInputRecursive2']
    NOT: List['FinanceScalarWhereWithAggregatesInputRecursive2']


class FinanceScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Finance arguments for searching"""
    financial_id: Union[_str, 'types.StringWithAggregatesFilter']
    investment_amount: Union[_float, 'types.FloatWithAggregatesFilter']
    expected_revenue: Union[_float, 'types.FloatWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['FinanceScalarWhereWithAggregatesInputRecursive3']
    OR: List['FinanceScalarWhereWithAggregatesInputRecursive3']
    NOT: List['FinanceScalarWhereWithAggregatesInputRecursive3']


class FinanceScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Finance arguments for searching"""
    financial_id: Union[_str, 'types.StringWithAggregatesFilter']
    investment_amount: Union[_float, 'types.FloatWithAggregatesFilter']
    expected_revenue: Union[_float, 'types.FloatWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['FinanceScalarWhereWithAggregatesInputRecursive4']
    OR: List['FinanceScalarWhereWithAggregatesInputRecursive4']
    NOT: List['FinanceScalarWhereWithAggregatesInputRecursive4']


class FinanceScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Finance arguments for searching"""
    financial_id: Union[_str, 'types.StringWithAggregatesFilter']
    investment_amount: Union[_float, 'types.FloatWithAggregatesFilter']
    expected_revenue: Union[_float, 'types.FloatWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']



class FinanceGroupByOutput(TypedDict, total=False):
    financial_id: _str
    investment_amount: _float
    expected_revenue: _float
    land_id: _str
    _sum: 'FinanceSumAggregateOutput'
    _avg: 'FinanceAvgAggregateOutput'
    _min: 'FinanceMinAggregateOutput'
    _max: 'FinanceMaxAggregateOutput'
    _count: 'FinanceCountAggregateOutput'


class FinanceAvgAggregateOutput(TypedDict, total=False):
    """Finance output for aggregating averages"""
    investment_amount: float
    expected_revenue: float


class FinanceSumAggregateOutput(TypedDict, total=False):
    """Finance output for aggregating sums"""
    investment_amount: _float
    expected_revenue: _float


class FinanceScalarAggregateOutput(TypedDict, total=False):
    """Finance output including scalar fields"""
    financial_id: _str
    investment_amount: _float
    expected_revenue: _float
    land_id: _str


FinanceMinAggregateOutput = FinanceScalarAggregateOutput
FinanceMaxAggregateOutput = FinanceScalarAggregateOutput


class FinanceMaxAggregateInput(TypedDict, total=False):
    """Finance input for aggregating by max"""
    financial_id: bool
    investment_amount: bool
    expected_revenue: bool
    land_id: bool


class FinanceMinAggregateInput(TypedDict, total=False):
    """Finance input for aggregating by min"""
    financial_id: bool
    investment_amount: bool
    expected_revenue: bool
    land_id: bool


class FinanceNumberAggregateInput(TypedDict, total=False):
    """Finance input for aggregating numbers"""
    investment_amount: bool
    expected_revenue: bool


FinanceAvgAggregateInput = FinanceNumberAggregateInput
FinanceSumAggregateInput = FinanceNumberAggregateInput


FinanceCountAggregateInput = TypedDict(
    'FinanceCountAggregateInput',
    {
        'financial_id': bool,
        'investment_amount': bool,
        'expected_revenue': bool,
        'land_id': bool,
        '_all': bool,
    },
    total=False,
)

FinanceCountAggregateOutput = TypedDict(
    'FinanceCountAggregateOutput',
    {
        'financial_id': int,
        'investment_amount': int,
        'expected_revenue': int,
        'land_id': int,
        '_all': int,
    },
    total=False,
)


FinanceKeys = Literal[
    'financial_id',
    'investment_amount',
    'expected_revenue',
    'land_id',
    'land',
]
FinanceScalarFieldKeys = Literal[
    'financial_id',
    'investment_amount',
    'expected_revenue',
    'land_id',
]
FinanceScalarFieldKeysT = TypeVar('FinanceScalarFieldKeysT', bound=FinanceScalarFieldKeys)

FinanceRelationalFieldKeys = Literal[
        'land',
    ]

# Weather types

class WeatherOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Weather create method"""
    weather_id: _str
    land_id: Optional[_str]
    land: 'LandCreateNestedWithoutRelationsInput'


class WeatherCreateInput(WeatherOptionalCreateInput):
    """Required arguments to the Weather create method"""
    temperature: _float
    humidity: _float
    rainfall: _float
    sunlight: _float


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class WeatherOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Weather create method, without relations"""
    weather_id: _str
    land_id: Optional[_str]


class WeatherCreateWithoutRelationsInput(WeatherOptionalCreateWithoutRelationsInput):
    """Required arguments to the Weather create method, without relations"""
    temperature: _float
    humidity: _float
    rainfall: _float
    sunlight: _float

class WeatherConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'WeatherCreateWithoutRelationsInput'
    where: 'WeatherWhereUniqueInput'

class WeatherCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'WeatherCreateWithoutRelationsInput'
    connect: 'WeatherWhereUniqueInput'
    connect_or_create: 'WeatherConnectOrCreateWithoutRelationsInput'


class WeatherCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['WeatherCreateWithoutRelationsInput', List['WeatherCreateWithoutRelationsInput']]
    connect: Union['WeatherWhereUniqueInput', List['WeatherWhereUniqueInput']]
    connect_or_create: Union['WeatherConnectOrCreateWithoutRelationsInput', List['WeatherConnectOrCreateWithoutRelationsInput']]

_WeatherWhereUnique_weather_id_Input = TypedDict(
    '_WeatherWhereUnique_weather_id_Input',
    {
        'weather_id': '_str',
    },
    total=True
)

_WeatherWhereUnique_land_id_Input = TypedDict(
    '_WeatherWhereUnique_land_id_Input',
    {
        'land_id': '_str',
    },
    total=True
)

WeatherWhereUniqueInput = Union[
    '_WeatherWhereUnique_weather_id_Input',
    '_WeatherWhereUnique_land_id_Input',
]


class WeatherUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    weather_id: _str
    temperature: Union[AtomicFloatInput, _float]
    humidity: Union[AtomicFloatInput, _float]
    rainfall: Union[AtomicFloatInput, _float]
    sunlight: Union[AtomicFloatInput, _float]
    land: 'LandUpdateOneWithoutRelationsInput'


class WeatherUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    weather_id: _str
    temperature: Union[AtomicFloatInput, _float]
    humidity: Union[AtomicFloatInput, _float]
    rainfall: Union[AtomicFloatInput, _float]
    sunlight: Union[AtomicFloatInput, _float]


class WeatherUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['WeatherCreateWithoutRelationsInput']
    connect: List['WeatherWhereUniqueInput']
    connect_or_create: List['WeatherConnectOrCreateWithoutRelationsInput']
    set: List['WeatherWhereUniqueInput']
    disconnect: List['WeatherWhereUniqueInput']
    delete: List['WeatherWhereUniqueInput']

    # TODO
    # update: List['WeatherUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['WeatherUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['WeatherScalarWhereInput']
    # upsert: List['WeatherUpserteWithWhereUniqueWithoutRelationsInput']


class WeatherUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'WeatherCreateWithoutRelationsInput'
    connect: 'WeatherWhereUniqueInput'
    connect_or_create: 'WeatherConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'WeatherUpdateInput'
    # upsert: 'WeatherUpsertWithoutRelationsInput'


class WeatherUpsertInput(TypedDict):
    create: 'WeatherCreateInput'
    update: 'WeatherUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Weather_weather_id_OrderByInput = TypedDict(
    '_Weather_weather_id_OrderByInput',
    {
        'weather_id': 'SortOrder',
    },
    total=True
)

_Weather_temperature_OrderByInput = TypedDict(
    '_Weather_temperature_OrderByInput',
    {
        'temperature': 'SortOrder',
    },
    total=True
)

_Weather_humidity_OrderByInput = TypedDict(
    '_Weather_humidity_OrderByInput',
    {
        'humidity': 'SortOrder',
    },
    total=True
)

_Weather_rainfall_OrderByInput = TypedDict(
    '_Weather_rainfall_OrderByInput',
    {
        'rainfall': 'SortOrder',
    },
    total=True
)

_Weather_sunlight_OrderByInput = TypedDict(
    '_Weather_sunlight_OrderByInput',
    {
        'sunlight': 'SortOrder',
    },
    total=True
)

_Weather_land_id_OrderByInput = TypedDict(
    '_Weather_land_id_OrderByInput',
    {
        'land_id': 'SortOrder',
    },
    total=True
)

_Weather_RelevanceInner = TypedDict(
    '_Weather_RelevanceInner',
    {
        'fields': 'List[WeatherScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Weather_RelevanceOrderByInput = TypedDict(
    '_Weather_RelevanceOrderByInput',
    {
        '_relevance': '_Weather_RelevanceInner',
    },
    total=True
)

WeatherOrderByInput = Union[
    '_Weather_weather_id_OrderByInput',
    '_Weather_temperature_OrderByInput',
    '_Weather_humidity_OrderByInput',
    '_Weather_rainfall_OrderByInput',
    '_Weather_sunlight_OrderByInput',
    '_Weather_land_id_OrderByInput',
    '_Weather_RelevanceOrderByInput',
]



# recursive Weather types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

WeatherRelationFilter = TypedDict(
    'WeatherRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class WeatherListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class WeatherInclude(TypedDict, total=False):
    """Weather relational arguments"""
    land: Union[bool, 'LandArgsFromWeather']


    

class UserIncludeFromWeather(TypedDict, total=False):
    """Relational arguments for Weather"""
    lands: Union[bool, 'FindManyLandArgsFromWeatherRecursive1']


class UserIncludeFromWeatherRecursive1(TypedDict, total=False):
    """Relational arguments for Weather"""
    lands: Union[bool, 'FindManyLandArgsFromWeatherRecursive2']


class UserIncludeFromWeatherRecursive2(TypedDict, total=False):
    """Relational arguments for Weather"""
    lands: Union[bool, 'FindManyLandArgsFromWeatherRecursive3']


class UserIncludeFromWeatherRecursive3(TypedDict, total=False):
    """Relational arguments for Weather"""
    lands: Union[bool, 'FindManyLandArgsFromWeatherRecursive4']


class UserIncludeFromWeatherRecursive4(TypedDict, total=False):
    """Relational arguments for Weather"""

    

class UserArgsFromWeather(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromWeatherRecursive1(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromWeatherRecursive2(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromWeatherRecursive3(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromWeatherRecursive4(TypedDict, total=False):
    """Arguments for Weather"""
    
    

class FindManyUserArgsFromWeather(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromWeatherRecursive1(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromWeatherRecursive2(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromWeatherRecursive3(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromWeatherRecursive4(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class LandIncludeFromWeather(TypedDict, total=False):
    """Relational arguments for Weather"""
    user: Union[bool, 'UserArgsFromWeatherRecursive1']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromWeatherRecursive1']
    crops: Union[bool, 'FindManyCropArgsFromWeatherRecursive1']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromWeatherRecursive1']
    finances: Union[bool, 'FindManyFinanceArgsFromWeatherRecursive1']
    weather_data: Union[bool, 'FindManyWeatherArgsFromWeatherRecursive1']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromWeatherRecursive1']


class LandIncludeFromWeatherRecursive1(TypedDict, total=False):
    """Relational arguments for Weather"""
    user: Union[bool, 'UserArgsFromWeatherRecursive2']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromWeatherRecursive2']
    crops: Union[bool, 'FindManyCropArgsFromWeatherRecursive2']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromWeatherRecursive2']
    finances: Union[bool, 'FindManyFinanceArgsFromWeatherRecursive2']
    weather_data: Union[bool, 'FindManyWeatherArgsFromWeatherRecursive2']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromWeatherRecursive2']


class LandIncludeFromWeatherRecursive2(TypedDict, total=False):
    """Relational arguments for Weather"""
    user: Union[bool, 'UserArgsFromWeatherRecursive3']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromWeatherRecursive3']
    crops: Union[bool, 'FindManyCropArgsFromWeatherRecursive3']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromWeatherRecursive3']
    finances: Union[bool, 'FindManyFinanceArgsFromWeatherRecursive3']
    weather_data: Union[bool, 'FindManyWeatherArgsFromWeatherRecursive3']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromWeatherRecursive3']


class LandIncludeFromWeatherRecursive3(TypedDict, total=False):
    """Relational arguments for Weather"""
    user: Union[bool, 'UserArgsFromWeatherRecursive4']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromWeatherRecursive4']
    crops: Union[bool, 'FindManyCropArgsFromWeatherRecursive4']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromWeatherRecursive4']
    finances: Union[bool, 'FindManyFinanceArgsFromWeatherRecursive4']
    weather_data: Union[bool, 'FindManyWeatherArgsFromWeatherRecursive4']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromWeatherRecursive4']


class LandIncludeFromWeatherRecursive4(TypedDict, total=False):
    """Relational arguments for Weather"""

    

class LandArgsFromWeather(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'LandIncludeFromLandRecursive1'


class LandArgsFromWeatherRecursive1(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'LandIncludeFromLandRecursive2'


class LandArgsFromWeatherRecursive2(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'LandIncludeFromLandRecursive3'


class LandArgsFromWeatherRecursive3(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'LandIncludeFromLandRecursive4'


class LandArgsFromWeatherRecursive4(TypedDict, total=False):
    """Arguments for Weather"""
    
    

class FindManyLandArgsFromWeather(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive1'


class FindManyLandArgsFromWeatherRecursive1(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive2'


class FindManyLandArgsFromWeatherRecursive2(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive3'


class FindManyLandArgsFromWeatherRecursive3(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive4'


class FindManyLandArgsFromWeatherRecursive4(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    
    

class LandStatisticIncludeFromWeather(TypedDict, total=False):
    """Relational arguments for Weather"""
    land: Union[bool, 'LandArgsFromWeatherRecursive1']


class LandStatisticIncludeFromWeatherRecursive1(TypedDict, total=False):
    """Relational arguments for Weather"""
    land: Union[bool, 'LandArgsFromWeatherRecursive2']


class LandStatisticIncludeFromWeatherRecursive2(TypedDict, total=False):
    """Relational arguments for Weather"""
    land: Union[bool, 'LandArgsFromWeatherRecursive3']


class LandStatisticIncludeFromWeatherRecursive3(TypedDict, total=False):
    """Relational arguments for Weather"""
    land: Union[bool, 'LandArgsFromWeatherRecursive4']


class LandStatisticIncludeFromWeatherRecursive4(TypedDict, total=False):
    """Relational arguments for Weather"""

    

class LandStatisticArgsFromWeather(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive1'


class LandStatisticArgsFromWeatherRecursive1(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive2'


class LandStatisticArgsFromWeatherRecursive2(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive3'


class LandStatisticArgsFromWeatherRecursive3(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive4'


class LandStatisticArgsFromWeatherRecursive4(TypedDict, total=False):
    """Arguments for Weather"""
    
    

class FindManyLandStatisticArgsFromWeather(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive1'


class FindManyLandStatisticArgsFromWeatherRecursive1(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive2'


class FindManyLandStatisticArgsFromWeatherRecursive2(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive3'


class FindManyLandStatisticArgsFromWeatherRecursive3(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive4'


class FindManyLandStatisticArgsFromWeatherRecursive4(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    
    

class CropIncludeFromWeather(TypedDict, total=False):
    """Relational arguments for Weather"""
    land: Union[bool, 'LandArgsFromWeatherRecursive1']


class CropIncludeFromWeatherRecursive1(TypedDict, total=False):
    """Relational arguments for Weather"""
    land: Union[bool, 'LandArgsFromWeatherRecursive2']


class CropIncludeFromWeatherRecursive2(TypedDict, total=False):
    """Relational arguments for Weather"""
    land: Union[bool, 'LandArgsFromWeatherRecursive3']


class CropIncludeFromWeatherRecursive3(TypedDict, total=False):
    """Relational arguments for Weather"""
    land: Union[bool, 'LandArgsFromWeatherRecursive4']


class CropIncludeFromWeatherRecursive4(TypedDict, total=False):
    """Relational arguments for Weather"""

    

class CropArgsFromWeather(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'CropIncludeFromCropRecursive1'


class CropArgsFromWeatherRecursive1(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'CropIncludeFromCropRecursive2'


class CropArgsFromWeatherRecursive2(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'CropIncludeFromCropRecursive3'


class CropArgsFromWeatherRecursive3(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'CropIncludeFromCropRecursive4'


class CropArgsFromWeatherRecursive4(TypedDict, total=False):
    """Arguments for Weather"""
    
    

class FindManyCropArgsFromWeather(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive1'


class FindManyCropArgsFromWeatherRecursive1(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive2'


class FindManyCropArgsFromWeatherRecursive2(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive3'


class FindManyCropArgsFromWeatherRecursive3(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive4'


class FindManyCropArgsFromWeatherRecursive4(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    
    

class CropMaintenanceIncludeFromWeather(TypedDict, total=False):
    """Relational arguments for Weather"""
    land: Union[bool, 'LandArgsFromWeatherRecursive1']


class CropMaintenanceIncludeFromWeatherRecursive1(TypedDict, total=False):
    """Relational arguments for Weather"""
    land: Union[bool, 'LandArgsFromWeatherRecursive2']


class CropMaintenanceIncludeFromWeatherRecursive2(TypedDict, total=False):
    """Relational arguments for Weather"""
    land: Union[bool, 'LandArgsFromWeatherRecursive3']


class CropMaintenanceIncludeFromWeatherRecursive3(TypedDict, total=False):
    """Relational arguments for Weather"""
    land: Union[bool, 'LandArgsFromWeatherRecursive4']


class CropMaintenanceIncludeFromWeatherRecursive4(TypedDict, total=False):
    """Relational arguments for Weather"""

    

class CropMaintenanceArgsFromWeather(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive1'


class CropMaintenanceArgsFromWeatherRecursive1(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive2'


class CropMaintenanceArgsFromWeatherRecursive2(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive3'


class CropMaintenanceArgsFromWeatherRecursive3(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive4'


class CropMaintenanceArgsFromWeatherRecursive4(TypedDict, total=False):
    """Arguments for Weather"""
    
    

class FindManyCropMaintenanceArgsFromWeather(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive1'


class FindManyCropMaintenanceArgsFromWeatherRecursive1(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive2'


class FindManyCropMaintenanceArgsFromWeatherRecursive2(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive3'


class FindManyCropMaintenanceArgsFromWeatherRecursive3(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive4'


class FindManyCropMaintenanceArgsFromWeatherRecursive4(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    
    

class FinanceIncludeFromWeather(TypedDict, total=False):
    """Relational arguments for Weather"""
    land: Union[bool, 'LandArgsFromWeatherRecursive1']


class FinanceIncludeFromWeatherRecursive1(TypedDict, total=False):
    """Relational arguments for Weather"""
    land: Union[bool, 'LandArgsFromWeatherRecursive2']


class FinanceIncludeFromWeatherRecursive2(TypedDict, total=False):
    """Relational arguments for Weather"""
    land: Union[bool, 'LandArgsFromWeatherRecursive3']


class FinanceIncludeFromWeatherRecursive3(TypedDict, total=False):
    """Relational arguments for Weather"""
    land: Union[bool, 'LandArgsFromWeatherRecursive4']


class FinanceIncludeFromWeatherRecursive4(TypedDict, total=False):
    """Relational arguments for Weather"""

    

class FinanceArgsFromWeather(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'FinanceIncludeFromFinanceRecursive1'


class FinanceArgsFromWeatherRecursive1(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'FinanceIncludeFromFinanceRecursive2'


class FinanceArgsFromWeatherRecursive2(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'FinanceIncludeFromFinanceRecursive3'


class FinanceArgsFromWeatherRecursive3(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'FinanceIncludeFromFinanceRecursive4'


class FinanceArgsFromWeatherRecursive4(TypedDict, total=False):
    """Arguments for Weather"""
    
    

class FindManyFinanceArgsFromWeather(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive1'


class FindManyFinanceArgsFromWeatherRecursive1(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive2'


class FindManyFinanceArgsFromWeatherRecursive2(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive3'


class FindManyFinanceArgsFromWeatherRecursive3(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive4'


class FindManyFinanceArgsFromWeatherRecursive4(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    
    

class WeatherIncludeFromWeather(TypedDict, total=False):
    """Relational arguments for Weather"""
    land: Union[bool, 'LandArgsFromWeatherRecursive1']


class WeatherIncludeFromWeatherRecursive1(TypedDict, total=False):
    """Relational arguments for Weather"""
    land: Union[bool, 'LandArgsFromWeatherRecursive2']


class WeatherIncludeFromWeatherRecursive2(TypedDict, total=False):
    """Relational arguments for Weather"""
    land: Union[bool, 'LandArgsFromWeatherRecursive3']


class WeatherIncludeFromWeatherRecursive3(TypedDict, total=False):
    """Relational arguments for Weather"""
    land: Union[bool, 'LandArgsFromWeatherRecursive4']


class WeatherIncludeFromWeatherRecursive4(TypedDict, total=False):
    """Relational arguments for Weather"""

    

class WeatherArgsFromWeather(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'WeatherIncludeFromWeatherRecursive1'


class WeatherArgsFromWeatherRecursive1(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'WeatherIncludeFromWeatherRecursive2'


class WeatherArgsFromWeatherRecursive2(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'WeatherIncludeFromWeatherRecursive3'


class WeatherArgsFromWeatherRecursive3(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'WeatherIncludeFromWeatherRecursive4'


class WeatherArgsFromWeatherRecursive4(TypedDict, total=False):
    """Arguments for Weather"""
    
    

class FindManyWeatherArgsFromWeather(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive1'


class FindManyWeatherArgsFromWeatherRecursive1(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive2'


class FindManyWeatherArgsFromWeatherRecursive2(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive3'


class FindManyWeatherArgsFromWeatherRecursive3(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive4'


class FindManyWeatherArgsFromWeatherRecursive4(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    
    

class BusinessPlanIncludeFromWeather(TypedDict, total=False):
    """Relational arguments for Weather"""
    land: Union[bool, 'LandArgsFromWeatherRecursive1']


class BusinessPlanIncludeFromWeatherRecursive1(TypedDict, total=False):
    """Relational arguments for Weather"""
    land: Union[bool, 'LandArgsFromWeatherRecursive2']


class BusinessPlanIncludeFromWeatherRecursive2(TypedDict, total=False):
    """Relational arguments for Weather"""
    land: Union[bool, 'LandArgsFromWeatherRecursive3']


class BusinessPlanIncludeFromWeatherRecursive3(TypedDict, total=False):
    """Relational arguments for Weather"""
    land: Union[bool, 'LandArgsFromWeatherRecursive4']


class BusinessPlanIncludeFromWeatherRecursive4(TypedDict, total=False):
    """Relational arguments for Weather"""

    

class BusinessPlanArgsFromWeather(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive1'


class BusinessPlanArgsFromWeatherRecursive1(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive2'


class BusinessPlanArgsFromWeatherRecursive2(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive3'


class BusinessPlanArgsFromWeatherRecursive3(TypedDict, total=False):
    """Arguments for Weather"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive4'


class BusinessPlanArgsFromWeatherRecursive4(TypedDict, total=False):
    """Arguments for Weather"""
    
    

class FindManyBusinessPlanArgsFromWeather(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive1'


class FindManyBusinessPlanArgsFromWeatherRecursive1(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive2'


class FindManyBusinessPlanArgsFromWeatherRecursive2(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive3'


class FindManyBusinessPlanArgsFromWeatherRecursive3(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive4'


class FindManyBusinessPlanArgsFromWeatherRecursive4(TypedDict, total=False):
    """Arguments for Weather"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    


FindManyWeatherArgs = FindManyWeatherArgsFromWeather
FindFirstWeatherArgs = FindManyWeatherArgsFromWeather


    

class WeatherWhereInput(TypedDict, total=False):
    """Weather arguments for searching"""
    weather_id: Union[_str, 'types.StringFilter']
    temperature: Union[_float, 'types.FloatFilter']
    humidity: Union[_float, 'types.FloatFilter']
    rainfall: Union[_float, 'types.FloatFilter']
    sunlight: Union[_float, 'types.FloatFilter']
    land_id: Union[None, _str, 'types.StringFilter']
    land: 'LandRelationFilter'

    # should be noted that AND and NOT should be Union['WeatherWhereInputRecursive1', List['WeatherWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['WeatherWhereInputRecursive1']
    OR: List['WeatherWhereInputRecursive1']
    NOT: List['WeatherWhereInputRecursive1']


class WeatherWhereInputRecursive1(TypedDict, total=False):
    """Weather arguments for searching"""
    weather_id: Union[_str, 'types.StringFilter']
    temperature: Union[_float, 'types.FloatFilter']
    humidity: Union[_float, 'types.FloatFilter']
    rainfall: Union[_float, 'types.FloatFilter']
    sunlight: Union[_float, 'types.FloatFilter']
    land_id: Union[None, _str, 'types.StringFilter']
    land: 'LandRelationFilter'

    # should be noted that AND and NOT should be Union['WeatherWhereInputRecursive2', List['WeatherWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['WeatherWhereInputRecursive2']
    OR: List['WeatherWhereInputRecursive2']
    NOT: List['WeatherWhereInputRecursive2']


class WeatherWhereInputRecursive2(TypedDict, total=False):
    """Weather arguments for searching"""
    weather_id: Union[_str, 'types.StringFilter']
    temperature: Union[_float, 'types.FloatFilter']
    humidity: Union[_float, 'types.FloatFilter']
    rainfall: Union[_float, 'types.FloatFilter']
    sunlight: Union[_float, 'types.FloatFilter']
    land_id: Union[None, _str, 'types.StringFilter']
    land: 'LandRelationFilter'

    # should be noted that AND and NOT should be Union['WeatherWhereInputRecursive3', List['WeatherWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['WeatherWhereInputRecursive3']
    OR: List['WeatherWhereInputRecursive3']
    NOT: List['WeatherWhereInputRecursive3']


class WeatherWhereInputRecursive3(TypedDict, total=False):
    """Weather arguments for searching"""
    weather_id: Union[_str, 'types.StringFilter']
    temperature: Union[_float, 'types.FloatFilter']
    humidity: Union[_float, 'types.FloatFilter']
    rainfall: Union[_float, 'types.FloatFilter']
    sunlight: Union[_float, 'types.FloatFilter']
    land_id: Union[None, _str, 'types.StringFilter']
    land: 'LandRelationFilter'

    # should be noted that AND and NOT should be Union['WeatherWhereInputRecursive4', List['WeatherWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['WeatherWhereInputRecursive4']
    OR: List['WeatherWhereInputRecursive4']
    NOT: List['WeatherWhereInputRecursive4']


class WeatherWhereInputRecursive4(TypedDict, total=False):
    """Weather arguments for searching"""
    weather_id: Union[_str, 'types.StringFilter']
    temperature: Union[_float, 'types.FloatFilter']
    humidity: Union[_float, 'types.FloatFilter']
    rainfall: Union[_float, 'types.FloatFilter']
    sunlight: Union[_float, 'types.FloatFilter']
    land_id: Union[None, _str, 'types.StringFilter']
    land: 'LandRelationFilter'



# aggregate Weather types


    

class WeatherScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Weather arguments for searching"""
    weather_id: Union[_str, 'types.StringWithAggregatesFilter']
    temperature: Union[_float, 'types.FloatWithAggregatesFilter']
    humidity: Union[_float, 'types.FloatWithAggregatesFilter']
    rainfall: Union[_float, 'types.FloatWithAggregatesFilter']
    sunlight: Union[_float, 'types.FloatWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['WeatherScalarWhereWithAggregatesInputRecursive1']
    OR: List['WeatherScalarWhereWithAggregatesInputRecursive1']
    NOT: List['WeatherScalarWhereWithAggregatesInputRecursive1']


class WeatherScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Weather arguments for searching"""
    weather_id: Union[_str, 'types.StringWithAggregatesFilter']
    temperature: Union[_float, 'types.FloatWithAggregatesFilter']
    humidity: Union[_float, 'types.FloatWithAggregatesFilter']
    rainfall: Union[_float, 'types.FloatWithAggregatesFilter']
    sunlight: Union[_float, 'types.FloatWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['WeatherScalarWhereWithAggregatesInputRecursive2']
    OR: List['WeatherScalarWhereWithAggregatesInputRecursive2']
    NOT: List['WeatherScalarWhereWithAggregatesInputRecursive2']


class WeatherScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Weather arguments for searching"""
    weather_id: Union[_str, 'types.StringWithAggregatesFilter']
    temperature: Union[_float, 'types.FloatWithAggregatesFilter']
    humidity: Union[_float, 'types.FloatWithAggregatesFilter']
    rainfall: Union[_float, 'types.FloatWithAggregatesFilter']
    sunlight: Union[_float, 'types.FloatWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['WeatherScalarWhereWithAggregatesInputRecursive3']
    OR: List['WeatherScalarWhereWithAggregatesInputRecursive3']
    NOT: List['WeatherScalarWhereWithAggregatesInputRecursive3']


class WeatherScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Weather arguments for searching"""
    weather_id: Union[_str, 'types.StringWithAggregatesFilter']
    temperature: Union[_float, 'types.FloatWithAggregatesFilter']
    humidity: Union[_float, 'types.FloatWithAggregatesFilter']
    rainfall: Union[_float, 'types.FloatWithAggregatesFilter']
    sunlight: Union[_float, 'types.FloatWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['WeatherScalarWhereWithAggregatesInputRecursive4']
    OR: List['WeatherScalarWhereWithAggregatesInputRecursive4']
    NOT: List['WeatherScalarWhereWithAggregatesInputRecursive4']


class WeatherScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Weather arguments for searching"""
    weather_id: Union[_str, 'types.StringWithAggregatesFilter']
    temperature: Union[_float, 'types.FloatWithAggregatesFilter']
    humidity: Union[_float, 'types.FloatWithAggregatesFilter']
    rainfall: Union[_float, 'types.FloatWithAggregatesFilter']
    sunlight: Union[_float, 'types.FloatWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']



class WeatherGroupByOutput(TypedDict, total=False):
    weather_id: _str
    temperature: _float
    humidity: _float
    rainfall: _float
    sunlight: _float
    land_id: _str
    _sum: 'WeatherSumAggregateOutput'
    _avg: 'WeatherAvgAggregateOutput'
    _min: 'WeatherMinAggregateOutput'
    _max: 'WeatherMaxAggregateOutput'
    _count: 'WeatherCountAggregateOutput'


class WeatherAvgAggregateOutput(TypedDict, total=False):
    """Weather output for aggregating averages"""
    temperature: float
    humidity: float
    rainfall: float
    sunlight: float


class WeatherSumAggregateOutput(TypedDict, total=False):
    """Weather output for aggregating sums"""
    temperature: _float
    humidity: _float
    rainfall: _float
    sunlight: _float


class WeatherScalarAggregateOutput(TypedDict, total=False):
    """Weather output including scalar fields"""
    weather_id: _str
    temperature: _float
    humidity: _float
    rainfall: _float
    sunlight: _float
    land_id: _str


WeatherMinAggregateOutput = WeatherScalarAggregateOutput
WeatherMaxAggregateOutput = WeatherScalarAggregateOutput


class WeatherMaxAggregateInput(TypedDict, total=False):
    """Weather input for aggregating by max"""
    weather_id: bool
    temperature: bool
    humidity: bool
    rainfall: bool
    sunlight: bool
    land_id: bool


class WeatherMinAggregateInput(TypedDict, total=False):
    """Weather input for aggregating by min"""
    weather_id: bool
    temperature: bool
    humidity: bool
    rainfall: bool
    sunlight: bool
    land_id: bool


class WeatherNumberAggregateInput(TypedDict, total=False):
    """Weather input for aggregating numbers"""
    temperature: bool
    humidity: bool
    rainfall: bool
    sunlight: bool


WeatherAvgAggregateInput = WeatherNumberAggregateInput
WeatherSumAggregateInput = WeatherNumberAggregateInput


WeatherCountAggregateInput = TypedDict(
    'WeatherCountAggregateInput',
    {
        'weather_id': bool,
        'temperature': bool,
        'humidity': bool,
        'rainfall': bool,
        'sunlight': bool,
        'land_id': bool,
        '_all': bool,
    },
    total=False,
)

WeatherCountAggregateOutput = TypedDict(
    'WeatherCountAggregateOutput',
    {
        'weather_id': int,
        'temperature': int,
        'humidity': int,
        'rainfall': int,
        'sunlight': int,
        'land_id': int,
        '_all': int,
    },
    total=False,
)


WeatherKeys = Literal[
    'weather_id',
    'temperature',
    'humidity',
    'rainfall',
    'sunlight',
    'land_id',
    'land',
]
WeatherScalarFieldKeys = Literal[
    'weather_id',
    'temperature',
    'humidity',
    'rainfall',
    'sunlight',
    'land_id',
]
WeatherScalarFieldKeysT = TypeVar('WeatherScalarFieldKeysT', bound=WeatherScalarFieldKeys)

WeatherRelationalFieldKeys = Literal[
        'land',
    ]

# BusinessPlan types

class BusinessPlanOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the BusinessPlan create method"""
    business_plan_id: _str
    land_id: _str
    land: 'LandCreateNestedWithoutRelationsInput'


class BusinessPlanCreateInput(BusinessPlanOptionalCreateInput):
    """Required arguments to the BusinessPlan create method"""
    executive_summary: _str
    resources: _str
    crops: _str
    weather_considerations: _str
    soil_maintenance: _str
    profit_estimations: _str
    other_recommendations: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class BusinessPlanOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the BusinessPlan create method, without relations"""
    business_plan_id: _str
    land_id: _str


class BusinessPlanCreateWithoutRelationsInput(BusinessPlanOptionalCreateWithoutRelationsInput):
    """Required arguments to the BusinessPlan create method, without relations"""
    executive_summary: _str
    resources: _str
    crops: _str
    weather_considerations: _str
    soil_maintenance: _str
    profit_estimations: _str
    other_recommendations: _str

class BusinessPlanConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'BusinessPlanCreateWithoutRelationsInput'
    where: 'BusinessPlanWhereUniqueInput'

class BusinessPlanCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'BusinessPlanCreateWithoutRelationsInput'
    connect: 'BusinessPlanWhereUniqueInput'
    connect_or_create: 'BusinessPlanConnectOrCreateWithoutRelationsInput'


class BusinessPlanCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['BusinessPlanCreateWithoutRelationsInput', List['BusinessPlanCreateWithoutRelationsInput']]
    connect: Union['BusinessPlanWhereUniqueInput', List['BusinessPlanWhereUniqueInput']]
    connect_or_create: Union['BusinessPlanConnectOrCreateWithoutRelationsInput', List['BusinessPlanConnectOrCreateWithoutRelationsInput']]

_BusinessPlanWhereUnique_business_plan_id_Input = TypedDict(
    '_BusinessPlanWhereUnique_business_plan_id_Input',
    {
        'business_plan_id': '_str',
    },
    total=True
)

_BusinessPlanWhereUnique_land_id_Input = TypedDict(
    '_BusinessPlanWhereUnique_land_id_Input',
    {
        'land_id': '_str',
    },
    total=True
)

BusinessPlanWhereUniqueInput = Union[
    '_BusinessPlanWhereUnique_business_plan_id_Input',
    '_BusinessPlanWhereUnique_land_id_Input',
]


class BusinessPlanUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    business_plan_id: _str
    executive_summary: _str
    resources: _str
    crops: _str
    weather_considerations: _str
    soil_maintenance: _str
    profit_estimations: _str
    other_recommendations: _str
    land: 'LandUpdateOneWithoutRelationsInput'


class BusinessPlanUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    business_plan_id: _str
    executive_summary: _str
    resources: _str
    crops: _str
    weather_considerations: _str
    soil_maintenance: _str
    profit_estimations: _str
    other_recommendations: _str


class BusinessPlanUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['BusinessPlanCreateWithoutRelationsInput']
    connect: List['BusinessPlanWhereUniqueInput']
    connect_or_create: List['BusinessPlanConnectOrCreateWithoutRelationsInput']
    set: List['BusinessPlanWhereUniqueInput']
    disconnect: List['BusinessPlanWhereUniqueInput']
    delete: List['BusinessPlanWhereUniqueInput']

    # TODO
    # update: List['BusinessPlanUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['BusinessPlanUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['BusinessPlanScalarWhereInput']
    # upsert: List['BusinessPlanUpserteWithWhereUniqueWithoutRelationsInput']


class BusinessPlanUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'BusinessPlanCreateWithoutRelationsInput'
    connect: 'BusinessPlanWhereUniqueInput'
    connect_or_create: 'BusinessPlanConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'BusinessPlanUpdateInput'
    # upsert: 'BusinessPlanUpsertWithoutRelationsInput'


class BusinessPlanUpsertInput(TypedDict):
    create: 'BusinessPlanCreateInput'
    update: 'BusinessPlanUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_BusinessPlan_business_plan_id_OrderByInput = TypedDict(
    '_BusinessPlan_business_plan_id_OrderByInput',
    {
        'business_plan_id': 'SortOrder',
    },
    total=True
)

_BusinessPlan_executive_summary_OrderByInput = TypedDict(
    '_BusinessPlan_executive_summary_OrderByInput',
    {
        'executive_summary': 'SortOrder',
    },
    total=True
)

_BusinessPlan_resources_OrderByInput = TypedDict(
    '_BusinessPlan_resources_OrderByInput',
    {
        'resources': 'SortOrder',
    },
    total=True
)

_BusinessPlan_crops_OrderByInput = TypedDict(
    '_BusinessPlan_crops_OrderByInput',
    {
        'crops': 'SortOrder',
    },
    total=True
)

_BusinessPlan_weather_considerations_OrderByInput = TypedDict(
    '_BusinessPlan_weather_considerations_OrderByInput',
    {
        'weather_considerations': 'SortOrder',
    },
    total=True
)

_BusinessPlan_soil_maintenance_OrderByInput = TypedDict(
    '_BusinessPlan_soil_maintenance_OrderByInput',
    {
        'soil_maintenance': 'SortOrder',
    },
    total=True
)

_BusinessPlan_profit_estimations_OrderByInput = TypedDict(
    '_BusinessPlan_profit_estimations_OrderByInput',
    {
        'profit_estimations': 'SortOrder',
    },
    total=True
)

_BusinessPlan_other_recommendations_OrderByInput = TypedDict(
    '_BusinessPlan_other_recommendations_OrderByInput',
    {
        'other_recommendations': 'SortOrder',
    },
    total=True
)

_BusinessPlan_land_id_OrderByInput = TypedDict(
    '_BusinessPlan_land_id_OrderByInput',
    {
        'land_id': 'SortOrder',
    },
    total=True
)

_BusinessPlan_RelevanceInner = TypedDict(
    '_BusinessPlan_RelevanceInner',
    {
        'fields': 'List[BusinessPlanScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_BusinessPlan_RelevanceOrderByInput = TypedDict(
    '_BusinessPlan_RelevanceOrderByInput',
    {
        '_relevance': '_BusinessPlan_RelevanceInner',
    },
    total=True
)

BusinessPlanOrderByInput = Union[
    '_BusinessPlan_business_plan_id_OrderByInput',
    '_BusinessPlan_executive_summary_OrderByInput',
    '_BusinessPlan_resources_OrderByInput',
    '_BusinessPlan_crops_OrderByInput',
    '_BusinessPlan_weather_considerations_OrderByInput',
    '_BusinessPlan_soil_maintenance_OrderByInput',
    '_BusinessPlan_profit_estimations_OrderByInput',
    '_BusinessPlan_other_recommendations_OrderByInput',
    '_BusinessPlan_land_id_OrderByInput',
    '_BusinessPlan_RelevanceOrderByInput',
]



# recursive BusinessPlan types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

BusinessPlanRelationFilter = TypedDict(
    'BusinessPlanRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class BusinessPlanListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class BusinessPlanInclude(TypedDict, total=False):
    """BusinessPlan relational arguments"""
    land: Union[bool, 'LandArgsFromBusinessPlan']


    

class UserIncludeFromBusinessPlan(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    lands: Union[bool, 'FindManyLandArgsFromBusinessPlanRecursive1']


class UserIncludeFromBusinessPlanRecursive1(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    lands: Union[bool, 'FindManyLandArgsFromBusinessPlanRecursive2']


class UserIncludeFromBusinessPlanRecursive2(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    lands: Union[bool, 'FindManyLandArgsFromBusinessPlanRecursive3']


class UserIncludeFromBusinessPlanRecursive3(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    lands: Union[bool, 'FindManyLandArgsFromBusinessPlanRecursive4']


class UserIncludeFromBusinessPlanRecursive4(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""

    

class UserArgsFromBusinessPlan(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromBusinessPlanRecursive1(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromBusinessPlanRecursive2(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromBusinessPlanRecursive3(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromBusinessPlanRecursive4(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    
    

class FindManyUserArgsFromBusinessPlan(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromBusinessPlanRecursive1(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromBusinessPlanRecursive2(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromBusinessPlanRecursive3(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromBusinessPlanRecursive4(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class LandIncludeFromBusinessPlan(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    user: Union[bool, 'UserArgsFromBusinessPlanRecursive1']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromBusinessPlanRecursive1']
    crops: Union[bool, 'FindManyCropArgsFromBusinessPlanRecursive1']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromBusinessPlanRecursive1']
    finances: Union[bool, 'FindManyFinanceArgsFromBusinessPlanRecursive1']
    weather_data: Union[bool, 'FindManyWeatherArgsFromBusinessPlanRecursive1']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromBusinessPlanRecursive1']


class LandIncludeFromBusinessPlanRecursive1(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    user: Union[bool, 'UserArgsFromBusinessPlanRecursive2']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromBusinessPlanRecursive2']
    crops: Union[bool, 'FindManyCropArgsFromBusinessPlanRecursive2']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromBusinessPlanRecursive2']
    finances: Union[bool, 'FindManyFinanceArgsFromBusinessPlanRecursive2']
    weather_data: Union[bool, 'FindManyWeatherArgsFromBusinessPlanRecursive2']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromBusinessPlanRecursive2']


class LandIncludeFromBusinessPlanRecursive2(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    user: Union[bool, 'UserArgsFromBusinessPlanRecursive3']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromBusinessPlanRecursive3']
    crops: Union[bool, 'FindManyCropArgsFromBusinessPlanRecursive3']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromBusinessPlanRecursive3']
    finances: Union[bool, 'FindManyFinanceArgsFromBusinessPlanRecursive3']
    weather_data: Union[bool, 'FindManyWeatherArgsFromBusinessPlanRecursive3']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromBusinessPlanRecursive3']


class LandIncludeFromBusinessPlanRecursive3(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    user: Union[bool, 'UserArgsFromBusinessPlanRecursive4']
    statistics: Union[bool, 'FindManyLandStatisticArgsFromBusinessPlanRecursive4']
    crops: Union[bool, 'FindManyCropArgsFromBusinessPlanRecursive4']
    maintenances: Union[bool, 'FindManyCropMaintenanceArgsFromBusinessPlanRecursive4']
    finances: Union[bool, 'FindManyFinanceArgsFromBusinessPlanRecursive4']
    weather_data: Union[bool, 'FindManyWeatherArgsFromBusinessPlanRecursive4']
    business_plans: Union[bool, 'FindManyBusinessPlanArgsFromBusinessPlanRecursive4']


class LandIncludeFromBusinessPlanRecursive4(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""

    

class LandArgsFromBusinessPlan(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'LandIncludeFromLandRecursive1'


class LandArgsFromBusinessPlanRecursive1(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'LandIncludeFromLandRecursive2'


class LandArgsFromBusinessPlanRecursive2(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'LandIncludeFromLandRecursive3'


class LandArgsFromBusinessPlanRecursive3(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'LandIncludeFromLandRecursive4'


class LandArgsFromBusinessPlanRecursive4(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    
    

class FindManyLandArgsFromBusinessPlan(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive1'


class FindManyLandArgsFromBusinessPlanRecursive1(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive2'


class FindManyLandArgsFromBusinessPlanRecursive2(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive3'


class FindManyLandArgsFromBusinessPlanRecursive3(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    include: 'LandIncludeFromLandRecursive4'


class FindManyLandArgsFromBusinessPlanRecursive4(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['LandOrderByInput', List['LandOrderByInput']]
    where: 'LandWhereInput'
    cursor: 'LandWhereUniqueInput'
    distinct: List['LandScalarFieldKeys']
    
    

class LandStatisticIncludeFromBusinessPlan(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    land: Union[bool, 'LandArgsFromBusinessPlanRecursive1']


class LandStatisticIncludeFromBusinessPlanRecursive1(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    land: Union[bool, 'LandArgsFromBusinessPlanRecursive2']


class LandStatisticIncludeFromBusinessPlanRecursive2(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    land: Union[bool, 'LandArgsFromBusinessPlanRecursive3']


class LandStatisticIncludeFromBusinessPlanRecursive3(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    land: Union[bool, 'LandArgsFromBusinessPlanRecursive4']


class LandStatisticIncludeFromBusinessPlanRecursive4(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""

    

class LandStatisticArgsFromBusinessPlan(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive1'


class LandStatisticArgsFromBusinessPlanRecursive1(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive2'


class LandStatisticArgsFromBusinessPlanRecursive2(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive3'


class LandStatisticArgsFromBusinessPlanRecursive3(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'LandStatisticIncludeFromLandStatisticRecursive4'


class LandStatisticArgsFromBusinessPlanRecursive4(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    
    

class FindManyLandStatisticArgsFromBusinessPlan(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive1'


class FindManyLandStatisticArgsFromBusinessPlanRecursive1(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive2'


class FindManyLandStatisticArgsFromBusinessPlanRecursive2(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive3'


class FindManyLandStatisticArgsFromBusinessPlanRecursive3(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    include: 'LandStatisticIncludeFromLandStatisticRecursive4'


class FindManyLandStatisticArgsFromBusinessPlanRecursive4(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['LandStatisticOrderByInput', List['LandStatisticOrderByInput']]
    where: 'LandStatisticWhereInput'
    cursor: 'LandStatisticWhereUniqueInput'
    distinct: List['LandStatisticScalarFieldKeys']
    
    

class CropIncludeFromBusinessPlan(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    land: Union[bool, 'LandArgsFromBusinessPlanRecursive1']


class CropIncludeFromBusinessPlanRecursive1(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    land: Union[bool, 'LandArgsFromBusinessPlanRecursive2']


class CropIncludeFromBusinessPlanRecursive2(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    land: Union[bool, 'LandArgsFromBusinessPlanRecursive3']


class CropIncludeFromBusinessPlanRecursive3(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    land: Union[bool, 'LandArgsFromBusinessPlanRecursive4']


class CropIncludeFromBusinessPlanRecursive4(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""

    

class CropArgsFromBusinessPlan(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'CropIncludeFromCropRecursive1'


class CropArgsFromBusinessPlanRecursive1(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'CropIncludeFromCropRecursive2'


class CropArgsFromBusinessPlanRecursive2(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'CropIncludeFromCropRecursive3'


class CropArgsFromBusinessPlanRecursive3(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'CropIncludeFromCropRecursive4'


class CropArgsFromBusinessPlanRecursive4(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    
    

class FindManyCropArgsFromBusinessPlan(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive1'


class FindManyCropArgsFromBusinessPlanRecursive1(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive2'


class FindManyCropArgsFromBusinessPlanRecursive2(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive3'


class FindManyCropArgsFromBusinessPlanRecursive3(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    include: 'CropIncludeFromCropRecursive4'


class FindManyCropArgsFromBusinessPlanRecursive4(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['CropOrderByInput', List['CropOrderByInput']]
    where: 'CropWhereInput'
    cursor: 'CropWhereUniqueInput'
    distinct: List['CropScalarFieldKeys']
    
    

class CropMaintenanceIncludeFromBusinessPlan(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    land: Union[bool, 'LandArgsFromBusinessPlanRecursive1']


class CropMaintenanceIncludeFromBusinessPlanRecursive1(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    land: Union[bool, 'LandArgsFromBusinessPlanRecursive2']


class CropMaintenanceIncludeFromBusinessPlanRecursive2(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    land: Union[bool, 'LandArgsFromBusinessPlanRecursive3']


class CropMaintenanceIncludeFromBusinessPlanRecursive3(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    land: Union[bool, 'LandArgsFromBusinessPlanRecursive4']


class CropMaintenanceIncludeFromBusinessPlanRecursive4(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""

    

class CropMaintenanceArgsFromBusinessPlan(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive1'


class CropMaintenanceArgsFromBusinessPlanRecursive1(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive2'


class CropMaintenanceArgsFromBusinessPlanRecursive2(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive3'


class CropMaintenanceArgsFromBusinessPlanRecursive3(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive4'


class CropMaintenanceArgsFromBusinessPlanRecursive4(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    
    

class FindManyCropMaintenanceArgsFromBusinessPlan(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive1'


class FindManyCropMaintenanceArgsFromBusinessPlanRecursive1(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive2'


class FindManyCropMaintenanceArgsFromBusinessPlanRecursive2(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive3'


class FindManyCropMaintenanceArgsFromBusinessPlanRecursive3(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    include: 'CropMaintenanceIncludeFromCropMaintenanceRecursive4'


class FindManyCropMaintenanceArgsFromBusinessPlanRecursive4(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['CropMaintenanceOrderByInput', List['CropMaintenanceOrderByInput']]
    where: 'CropMaintenanceWhereInput'
    cursor: 'CropMaintenanceWhereUniqueInput'
    distinct: List['CropMaintenanceScalarFieldKeys']
    
    

class FinanceIncludeFromBusinessPlan(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    land: Union[bool, 'LandArgsFromBusinessPlanRecursive1']


class FinanceIncludeFromBusinessPlanRecursive1(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    land: Union[bool, 'LandArgsFromBusinessPlanRecursive2']


class FinanceIncludeFromBusinessPlanRecursive2(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    land: Union[bool, 'LandArgsFromBusinessPlanRecursive3']


class FinanceIncludeFromBusinessPlanRecursive3(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    land: Union[bool, 'LandArgsFromBusinessPlanRecursive4']


class FinanceIncludeFromBusinessPlanRecursive4(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""

    

class FinanceArgsFromBusinessPlan(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'FinanceIncludeFromFinanceRecursive1'


class FinanceArgsFromBusinessPlanRecursive1(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'FinanceIncludeFromFinanceRecursive2'


class FinanceArgsFromBusinessPlanRecursive2(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'FinanceIncludeFromFinanceRecursive3'


class FinanceArgsFromBusinessPlanRecursive3(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'FinanceIncludeFromFinanceRecursive4'


class FinanceArgsFromBusinessPlanRecursive4(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    
    

class FindManyFinanceArgsFromBusinessPlan(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive1'


class FindManyFinanceArgsFromBusinessPlanRecursive1(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive2'


class FindManyFinanceArgsFromBusinessPlanRecursive2(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive3'


class FindManyFinanceArgsFromBusinessPlanRecursive3(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    include: 'FinanceIncludeFromFinanceRecursive4'


class FindManyFinanceArgsFromBusinessPlanRecursive4(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['FinanceOrderByInput', List['FinanceOrderByInput']]
    where: 'FinanceWhereInput'
    cursor: 'FinanceWhereUniqueInput'
    distinct: List['FinanceScalarFieldKeys']
    
    

class WeatherIncludeFromBusinessPlan(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    land: Union[bool, 'LandArgsFromBusinessPlanRecursive1']


class WeatherIncludeFromBusinessPlanRecursive1(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    land: Union[bool, 'LandArgsFromBusinessPlanRecursive2']


class WeatherIncludeFromBusinessPlanRecursive2(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    land: Union[bool, 'LandArgsFromBusinessPlanRecursive3']


class WeatherIncludeFromBusinessPlanRecursive3(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    land: Union[bool, 'LandArgsFromBusinessPlanRecursive4']


class WeatherIncludeFromBusinessPlanRecursive4(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""

    

class WeatherArgsFromBusinessPlan(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'WeatherIncludeFromWeatherRecursive1'


class WeatherArgsFromBusinessPlanRecursive1(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'WeatherIncludeFromWeatherRecursive2'


class WeatherArgsFromBusinessPlanRecursive2(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'WeatherIncludeFromWeatherRecursive3'


class WeatherArgsFromBusinessPlanRecursive3(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'WeatherIncludeFromWeatherRecursive4'


class WeatherArgsFromBusinessPlanRecursive4(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    
    

class FindManyWeatherArgsFromBusinessPlan(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive1'


class FindManyWeatherArgsFromBusinessPlanRecursive1(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive2'


class FindManyWeatherArgsFromBusinessPlanRecursive2(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive3'


class FindManyWeatherArgsFromBusinessPlanRecursive3(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    include: 'WeatherIncludeFromWeatherRecursive4'


class FindManyWeatherArgsFromBusinessPlanRecursive4(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['WeatherOrderByInput', List['WeatherOrderByInput']]
    where: 'WeatherWhereInput'
    cursor: 'WeatherWhereUniqueInput'
    distinct: List['WeatherScalarFieldKeys']
    
    

class BusinessPlanIncludeFromBusinessPlan(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    land: Union[bool, 'LandArgsFromBusinessPlanRecursive1']


class BusinessPlanIncludeFromBusinessPlanRecursive1(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    land: Union[bool, 'LandArgsFromBusinessPlanRecursive2']


class BusinessPlanIncludeFromBusinessPlanRecursive2(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    land: Union[bool, 'LandArgsFromBusinessPlanRecursive3']


class BusinessPlanIncludeFromBusinessPlanRecursive3(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""
    land: Union[bool, 'LandArgsFromBusinessPlanRecursive4']


class BusinessPlanIncludeFromBusinessPlanRecursive4(TypedDict, total=False):
    """Relational arguments for BusinessPlan"""

    

class BusinessPlanArgsFromBusinessPlan(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive1'


class BusinessPlanArgsFromBusinessPlanRecursive1(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive2'


class BusinessPlanArgsFromBusinessPlanRecursive2(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive3'


class BusinessPlanArgsFromBusinessPlanRecursive3(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive4'


class BusinessPlanArgsFromBusinessPlanRecursive4(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    
    

class FindManyBusinessPlanArgsFromBusinessPlan(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive1'


class FindManyBusinessPlanArgsFromBusinessPlanRecursive1(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive2'


class FindManyBusinessPlanArgsFromBusinessPlanRecursive2(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive3'


class FindManyBusinessPlanArgsFromBusinessPlanRecursive3(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    include: 'BusinessPlanIncludeFromBusinessPlanRecursive4'


class FindManyBusinessPlanArgsFromBusinessPlanRecursive4(TypedDict, total=False):
    """Arguments for BusinessPlan"""
    take: int
    skip: int
    order_by: Union['BusinessPlanOrderByInput', List['BusinessPlanOrderByInput']]
    where: 'BusinessPlanWhereInput'
    cursor: 'BusinessPlanWhereUniqueInput'
    distinct: List['BusinessPlanScalarFieldKeys']
    


FindManyBusinessPlanArgs = FindManyBusinessPlanArgsFromBusinessPlan
FindFirstBusinessPlanArgs = FindManyBusinessPlanArgsFromBusinessPlan


    

class BusinessPlanWhereInput(TypedDict, total=False):
    """BusinessPlan arguments for searching"""
    business_plan_id: Union[_str, 'types.StringFilter']
    executive_summary: Union[_str, 'types.StringFilter']
    resources: Union[_str, 'types.StringFilter']
    crops: Union[_str, 'types.StringFilter']
    weather_considerations: Union[_str, 'types.StringFilter']
    soil_maintenance: Union[_str, 'types.StringFilter']
    profit_estimations: Union[_str, 'types.StringFilter']
    other_recommendations: Union[_str, 'types.StringFilter']
    land_id: Union[_str, 'types.StringFilter']
    land: 'LandRelationFilter'

    # should be noted that AND and NOT should be Union['BusinessPlanWhereInputRecursive1', List['BusinessPlanWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['BusinessPlanWhereInputRecursive1']
    OR: List['BusinessPlanWhereInputRecursive1']
    NOT: List['BusinessPlanWhereInputRecursive1']


class BusinessPlanWhereInputRecursive1(TypedDict, total=False):
    """BusinessPlan arguments for searching"""
    business_plan_id: Union[_str, 'types.StringFilter']
    executive_summary: Union[_str, 'types.StringFilter']
    resources: Union[_str, 'types.StringFilter']
    crops: Union[_str, 'types.StringFilter']
    weather_considerations: Union[_str, 'types.StringFilter']
    soil_maintenance: Union[_str, 'types.StringFilter']
    profit_estimations: Union[_str, 'types.StringFilter']
    other_recommendations: Union[_str, 'types.StringFilter']
    land_id: Union[_str, 'types.StringFilter']
    land: 'LandRelationFilter'

    # should be noted that AND and NOT should be Union['BusinessPlanWhereInputRecursive2', List['BusinessPlanWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['BusinessPlanWhereInputRecursive2']
    OR: List['BusinessPlanWhereInputRecursive2']
    NOT: List['BusinessPlanWhereInputRecursive2']


class BusinessPlanWhereInputRecursive2(TypedDict, total=False):
    """BusinessPlan arguments for searching"""
    business_plan_id: Union[_str, 'types.StringFilter']
    executive_summary: Union[_str, 'types.StringFilter']
    resources: Union[_str, 'types.StringFilter']
    crops: Union[_str, 'types.StringFilter']
    weather_considerations: Union[_str, 'types.StringFilter']
    soil_maintenance: Union[_str, 'types.StringFilter']
    profit_estimations: Union[_str, 'types.StringFilter']
    other_recommendations: Union[_str, 'types.StringFilter']
    land_id: Union[_str, 'types.StringFilter']
    land: 'LandRelationFilter'

    # should be noted that AND and NOT should be Union['BusinessPlanWhereInputRecursive3', List['BusinessPlanWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['BusinessPlanWhereInputRecursive3']
    OR: List['BusinessPlanWhereInputRecursive3']
    NOT: List['BusinessPlanWhereInputRecursive3']


class BusinessPlanWhereInputRecursive3(TypedDict, total=False):
    """BusinessPlan arguments for searching"""
    business_plan_id: Union[_str, 'types.StringFilter']
    executive_summary: Union[_str, 'types.StringFilter']
    resources: Union[_str, 'types.StringFilter']
    crops: Union[_str, 'types.StringFilter']
    weather_considerations: Union[_str, 'types.StringFilter']
    soil_maintenance: Union[_str, 'types.StringFilter']
    profit_estimations: Union[_str, 'types.StringFilter']
    other_recommendations: Union[_str, 'types.StringFilter']
    land_id: Union[_str, 'types.StringFilter']
    land: 'LandRelationFilter'

    # should be noted that AND and NOT should be Union['BusinessPlanWhereInputRecursive4', List['BusinessPlanWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['BusinessPlanWhereInputRecursive4']
    OR: List['BusinessPlanWhereInputRecursive4']
    NOT: List['BusinessPlanWhereInputRecursive4']


class BusinessPlanWhereInputRecursive4(TypedDict, total=False):
    """BusinessPlan arguments for searching"""
    business_plan_id: Union[_str, 'types.StringFilter']
    executive_summary: Union[_str, 'types.StringFilter']
    resources: Union[_str, 'types.StringFilter']
    crops: Union[_str, 'types.StringFilter']
    weather_considerations: Union[_str, 'types.StringFilter']
    soil_maintenance: Union[_str, 'types.StringFilter']
    profit_estimations: Union[_str, 'types.StringFilter']
    other_recommendations: Union[_str, 'types.StringFilter']
    land_id: Union[_str, 'types.StringFilter']
    land: 'LandRelationFilter'



# aggregate BusinessPlan types


    

class BusinessPlanScalarWhereWithAggregatesInput(TypedDict, total=False):
    """BusinessPlan arguments for searching"""
    business_plan_id: Union[_str, 'types.StringWithAggregatesFilter']
    executive_summary: Union[_str, 'types.StringWithAggregatesFilter']
    resources: Union[_str, 'types.StringWithAggregatesFilter']
    crops: Union[_str, 'types.StringWithAggregatesFilter']
    weather_considerations: Union[_str, 'types.StringWithAggregatesFilter']
    soil_maintenance: Union[_str, 'types.StringWithAggregatesFilter']
    profit_estimations: Union[_str, 'types.StringWithAggregatesFilter']
    other_recommendations: Union[_str, 'types.StringWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['BusinessPlanScalarWhereWithAggregatesInputRecursive1']
    OR: List['BusinessPlanScalarWhereWithAggregatesInputRecursive1']
    NOT: List['BusinessPlanScalarWhereWithAggregatesInputRecursive1']


class BusinessPlanScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """BusinessPlan arguments for searching"""
    business_plan_id: Union[_str, 'types.StringWithAggregatesFilter']
    executive_summary: Union[_str, 'types.StringWithAggregatesFilter']
    resources: Union[_str, 'types.StringWithAggregatesFilter']
    crops: Union[_str, 'types.StringWithAggregatesFilter']
    weather_considerations: Union[_str, 'types.StringWithAggregatesFilter']
    soil_maintenance: Union[_str, 'types.StringWithAggregatesFilter']
    profit_estimations: Union[_str, 'types.StringWithAggregatesFilter']
    other_recommendations: Union[_str, 'types.StringWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['BusinessPlanScalarWhereWithAggregatesInputRecursive2']
    OR: List['BusinessPlanScalarWhereWithAggregatesInputRecursive2']
    NOT: List['BusinessPlanScalarWhereWithAggregatesInputRecursive2']


class BusinessPlanScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """BusinessPlan arguments for searching"""
    business_plan_id: Union[_str, 'types.StringWithAggregatesFilter']
    executive_summary: Union[_str, 'types.StringWithAggregatesFilter']
    resources: Union[_str, 'types.StringWithAggregatesFilter']
    crops: Union[_str, 'types.StringWithAggregatesFilter']
    weather_considerations: Union[_str, 'types.StringWithAggregatesFilter']
    soil_maintenance: Union[_str, 'types.StringWithAggregatesFilter']
    profit_estimations: Union[_str, 'types.StringWithAggregatesFilter']
    other_recommendations: Union[_str, 'types.StringWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['BusinessPlanScalarWhereWithAggregatesInputRecursive3']
    OR: List['BusinessPlanScalarWhereWithAggregatesInputRecursive3']
    NOT: List['BusinessPlanScalarWhereWithAggregatesInputRecursive3']


class BusinessPlanScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """BusinessPlan arguments for searching"""
    business_plan_id: Union[_str, 'types.StringWithAggregatesFilter']
    executive_summary: Union[_str, 'types.StringWithAggregatesFilter']
    resources: Union[_str, 'types.StringWithAggregatesFilter']
    crops: Union[_str, 'types.StringWithAggregatesFilter']
    weather_considerations: Union[_str, 'types.StringWithAggregatesFilter']
    soil_maintenance: Union[_str, 'types.StringWithAggregatesFilter']
    profit_estimations: Union[_str, 'types.StringWithAggregatesFilter']
    other_recommendations: Union[_str, 'types.StringWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['BusinessPlanScalarWhereWithAggregatesInputRecursive4']
    OR: List['BusinessPlanScalarWhereWithAggregatesInputRecursive4']
    NOT: List['BusinessPlanScalarWhereWithAggregatesInputRecursive4']


class BusinessPlanScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """BusinessPlan arguments for searching"""
    business_plan_id: Union[_str, 'types.StringWithAggregatesFilter']
    executive_summary: Union[_str, 'types.StringWithAggregatesFilter']
    resources: Union[_str, 'types.StringWithAggregatesFilter']
    crops: Union[_str, 'types.StringWithAggregatesFilter']
    weather_considerations: Union[_str, 'types.StringWithAggregatesFilter']
    soil_maintenance: Union[_str, 'types.StringWithAggregatesFilter']
    profit_estimations: Union[_str, 'types.StringWithAggregatesFilter']
    other_recommendations: Union[_str, 'types.StringWithAggregatesFilter']
    land_id: Union[_str, 'types.StringWithAggregatesFilter']



class BusinessPlanGroupByOutput(TypedDict, total=False):
    business_plan_id: _str
    executive_summary: _str
    resources: _str
    crops: _str
    weather_considerations: _str
    soil_maintenance: _str
    profit_estimations: _str
    other_recommendations: _str
    land_id: _str
    _sum: 'BusinessPlanSumAggregateOutput'
    _avg: 'BusinessPlanAvgAggregateOutput'
    _min: 'BusinessPlanMinAggregateOutput'
    _max: 'BusinessPlanMaxAggregateOutput'
    _count: 'BusinessPlanCountAggregateOutput'


class BusinessPlanAvgAggregateOutput(TypedDict, total=False):
    """BusinessPlan output for aggregating averages"""


class BusinessPlanSumAggregateOutput(TypedDict, total=False):
    """BusinessPlan output for aggregating sums"""


class BusinessPlanScalarAggregateOutput(TypedDict, total=False):
    """BusinessPlan output including scalar fields"""
    business_plan_id: _str
    executive_summary: _str
    resources: _str
    crops: _str
    weather_considerations: _str
    soil_maintenance: _str
    profit_estimations: _str
    other_recommendations: _str
    land_id: _str


BusinessPlanMinAggregateOutput = BusinessPlanScalarAggregateOutput
BusinessPlanMaxAggregateOutput = BusinessPlanScalarAggregateOutput


class BusinessPlanMaxAggregateInput(TypedDict, total=False):
    """BusinessPlan input for aggregating by max"""
    business_plan_id: bool
    executive_summary: bool
    resources: bool
    crops: bool
    weather_considerations: bool
    soil_maintenance: bool
    profit_estimations: bool
    other_recommendations: bool
    land_id: bool


class BusinessPlanMinAggregateInput(TypedDict, total=False):
    """BusinessPlan input for aggregating by min"""
    business_plan_id: bool
    executive_summary: bool
    resources: bool
    crops: bool
    weather_considerations: bool
    soil_maintenance: bool
    profit_estimations: bool
    other_recommendations: bool
    land_id: bool


class BusinessPlanNumberAggregateInput(TypedDict, total=False):
    """BusinessPlan input for aggregating numbers"""


BusinessPlanAvgAggregateInput = BusinessPlanNumberAggregateInput
BusinessPlanSumAggregateInput = BusinessPlanNumberAggregateInput


BusinessPlanCountAggregateInput = TypedDict(
    'BusinessPlanCountAggregateInput',
    {
        'business_plan_id': bool,
        'executive_summary': bool,
        'resources': bool,
        'crops': bool,
        'weather_considerations': bool,
        'soil_maintenance': bool,
        'profit_estimations': bool,
        'other_recommendations': bool,
        'land_id': bool,
        '_all': bool,
    },
    total=False,
)

BusinessPlanCountAggregateOutput = TypedDict(
    'BusinessPlanCountAggregateOutput',
    {
        'business_plan_id': int,
        'executive_summary': int,
        'resources': int,
        'crops': int,
        'weather_considerations': int,
        'soil_maintenance': int,
        'profit_estimations': int,
        'other_recommendations': int,
        'land_id': int,
        '_all': int,
    },
    total=False,
)


BusinessPlanKeys = Literal[
    'business_plan_id',
    'executive_summary',
    'resources',
    'crops',
    'weather_considerations',
    'soil_maintenance',
    'profit_estimations',
    'other_recommendations',
    'land_id',
    'land',
]
BusinessPlanScalarFieldKeys = Literal[
    'business_plan_id',
    'executive_summary',
    'resources',
    'crops',
    'weather_considerations',
    'soil_maintenance',
    'profit_estimations',
    'other_recommendations',
    'land_id',
]
BusinessPlanScalarFieldKeysT = TypeVar('BusinessPlanScalarFieldKeysT', bound=BusinessPlanScalarFieldKeys)

BusinessPlanRelationalFieldKeys = Literal[
        'land',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields