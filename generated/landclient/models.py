# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from ._builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class User(bases.BaseUser):
    """Represents a User record"""

    user_id: _str
    lands: Optional[List['models.Land']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserKeys']] = None,
        exclude: Optional[Iterable['types.UserKeys']] = None,
        required: Optional[Iterable['types.UserKeys']] = None,
        optional: Optional[Iterable['types.UserKeys']] = None,
        relations: Optional[Mapping['types.UserRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _User_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _User_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _User_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _User_relational_fields:
                        raise errors.UnknownRelationalFieldError('User', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid User / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'User',
            }
        )
        _created_partial_types.add(name)


class Land(bases.BaseLand):
    """Represents a Land record"""

    land_id: _str
    latitude: _float
    longitude: _float
    land_size: _float
    land_name: Optional[_str] = None
    land_image: Optional[_str] = None
    ph_level: _float
    phosphorus: _float
    potassium: _float
    oxygen_level: _float
    nitrogen: _float
    user_id: _str
    user: Optional['models.User'] = None
    statistics: Optional[List['models.LandStatistic']] = None
    crops: Optional[List['models.Crop']] = None
    maintenances: Optional[List['models.CropMaintenance']] = None
    finances: Optional[List['models.Finance']] = None
    weather_data: Optional[List['models.Weather']] = None
    business_plans: Optional[List['models.BusinessPlan']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LandKeys']] = None,
        exclude: Optional[Iterable['types.LandKeys']] = None,
        required: Optional[Iterable['types.LandKeys']] = None,
        optional: Optional[Iterable['types.LandKeys']] = None,
        relations: Optional[Mapping['types.LandRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LandKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Land_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Land_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Land_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Land_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Land_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Land_relational_fields:
                        raise errors.UnknownRelationalFieldError('Land', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Land / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Land',
            }
        )
        _created_partial_types.add(name)


class LandStatistic(bases.BaseLandStatistic):
    """Represents a LandStatistic record"""

    land_stat_id: _str
    land_use: _float
    human_coverage: _float
    water_availability: _float
    distribution_optimality: _float
    total_profit: _float
    land_id: _str
    land: Optional['models.Land'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LandStatisticKeys']] = None,
        exclude: Optional[Iterable['types.LandStatisticKeys']] = None,
        required: Optional[Iterable['types.LandStatisticKeys']] = None,
        optional: Optional[Iterable['types.LandStatisticKeys']] = None,
        relations: Optional[Mapping['types.LandStatisticRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LandStatisticKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LandStatistic_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LandStatistic_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LandStatistic_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LandStatistic_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _LandStatistic_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _LandStatistic_relational_fields:
                        raise errors.UnknownRelationalFieldError('LandStatistic', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LandStatistic / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LandStatistic',
            }
        )
        _created_partial_types.add(name)


class Crop(bases.BaseCrop):
    """Represents a Crop record"""

    crop_id: _str
    crop_name: _str
    crop_area: _float
    crop_investment: _float
    expected_money_return: _float
    expected_weight_return: _float
    land_id: _str
    land: Optional['models.Land'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.CropKeys']] = None,
        exclude: Optional[Iterable['types.CropKeys']] = None,
        required: Optional[Iterable['types.CropKeys']] = None,
        optional: Optional[Iterable['types.CropKeys']] = None,
        relations: Optional[Mapping['types.CropRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.CropKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Crop_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Crop_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Crop_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Crop_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Crop_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Crop_relational_fields:
                        raise errors.UnknownRelationalFieldError('Crop', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Crop / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Crop',
            }
        )
        _created_partial_types.add(name)


class CropMaintenance(bases.BaseCropMaintenance):
    """Represents a CropMaintenance record"""

    maintenance_id: _str
    pesticide_level: _float
    water_sufficienty: _float
    land_id: _str
    land: Optional['models.Land'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.CropMaintenanceKeys']] = None,
        exclude: Optional[Iterable['types.CropMaintenanceKeys']] = None,
        required: Optional[Iterable['types.CropMaintenanceKeys']] = None,
        optional: Optional[Iterable['types.CropMaintenanceKeys']] = None,
        relations: Optional[Mapping['types.CropMaintenanceRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.CropMaintenanceKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _CropMaintenance_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _CropMaintenance_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _CropMaintenance_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _CropMaintenance_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _CropMaintenance_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _CropMaintenance_relational_fields:
                        raise errors.UnknownRelationalFieldError('CropMaintenance', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid CropMaintenance / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'CropMaintenance',
            }
        )
        _created_partial_types.add(name)


class Finance(bases.BaseFinance):
    """Represents a Finance record"""

    financial_id: _str
    investment_amount: Optional[_float] = None
    expected_revenue: Optional[_float] = None
    land_id: Optional[_str] = None
    land: Optional['models.Land'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.FinanceKeys']] = None,
        exclude: Optional[Iterable['types.FinanceKeys']] = None,
        required: Optional[Iterable['types.FinanceKeys']] = None,
        optional: Optional[Iterable['types.FinanceKeys']] = None,
        relations: Optional[Mapping['types.FinanceRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.FinanceKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Finance_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Finance_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Finance_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Finance_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Finance_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Finance_relational_fields:
                        raise errors.UnknownRelationalFieldError('Finance', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Finance / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Finance',
            }
        )
        _created_partial_types.add(name)


class Weather(bases.BaseWeather):
    """Represents a Weather record"""

    weather_id: _str
    temperature: _float
    humidity: _float
    rainfall: _float
    sunlight: _float
    land_id: Optional[_str] = None
    land: Optional['models.Land'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.WeatherKeys']] = None,
        exclude: Optional[Iterable['types.WeatherKeys']] = None,
        required: Optional[Iterable['types.WeatherKeys']] = None,
        optional: Optional[Iterable['types.WeatherKeys']] = None,
        relations: Optional[Mapping['types.WeatherRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.WeatherKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Weather_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Weather_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Weather_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Weather_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Weather_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Weather_relational_fields:
                        raise errors.UnknownRelationalFieldError('Weather', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Weather / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Weather',
            }
        )
        _created_partial_types.add(name)


class BusinessPlan(bases.BaseBusinessPlan):
    """Represents a BusinessPlan record"""

    business_plan_id: _str
    executive_summary: _str
    resources: _str
    crops: _str
    weather_considerations: _str
    soil_maintenance: _str
    profit_estimations: _str
    other_recommendations: _str
    land_id: _str
    land: Optional['models.Land'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.BusinessPlanKeys']] = None,
        exclude: Optional[Iterable['types.BusinessPlanKeys']] = None,
        required: Optional[Iterable['types.BusinessPlanKeys']] = None,
        optional: Optional[Iterable['types.BusinessPlanKeys']] = None,
        relations: Optional[Mapping['types.BusinessPlanRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.BusinessPlanKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _BusinessPlan_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _BusinessPlan_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _BusinessPlan_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _BusinessPlan_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _BusinessPlan_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _BusinessPlan_relational_fields:
                        raise errors.UnknownRelationalFieldError('BusinessPlan', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid BusinessPlan / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'BusinessPlan',
            }
        )
        _created_partial_types.add(name)



_User_relational_fields: Set[str] = {
        'lands',
    }
_User_fields: Dict['types.UserKeys', PartialModelField] = OrderedDict(
    [
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('lands', {
            'name': 'lands',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Land\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Land_relational_fields: Set[str] = {
        'user',
        'statistics',
        'crops',
        'maintenances',
        'finances',
        'weather_data',
        'business_plans',
    }
_Land_fields: Dict['types.LandKeys', PartialModelField] = OrderedDict(
    [
        ('land_id', {
            'name': 'land_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('latitude', {
            'name': 'latitude',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('longitude', {
            'name': 'longitude',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('land_size', {
            'name': 'land_size',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('land_name', {
            'name': 'land_name',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('land_image', {
            'name': 'land_image',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('ph_level', {
            'name': 'ph_level',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('phosphorus', {
            'name': 'phosphorus',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('potassium', {
            'name': 'potassium',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('oxygen_level', {
            'name': 'oxygen_level',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('nitrogen', {
            'name': 'nitrogen',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('statistics', {
            'name': 'statistics',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LandStatistic\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('crops', {
            'name': 'crops',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Crop\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('maintenances', {
            'name': 'maintenances',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.CropMaintenance\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('finances', {
            'name': 'finances',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Finance\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('weather_data', {
            'name': 'weather_data',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Weather\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('business_plans', {
            'name': 'business_plans',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.BusinessPlan\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_LandStatistic_relational_fields: Set[str] = {
        'land',
    }
_LandStatistic_fields: Dict['types.LandStatisticKeys', PartialModelField] = OrderedDict(
    [
        ('land_stat_id', {
            'name': 'land_stat_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('land_use', {
            'name': 'land_use',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('human_coverage', {
            'name': 'human_coverage',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('water_availability', {
            'name': 'water_availability',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('distribution_optimality', {
            'name': 'distribution_optimality',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('total_profit', {
            'name': 'total_profit',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('land_id', {
            'name': 'land_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('land', {
            'name': 'land',
            'is_list': False,
            'optional': True,
            'type': 'models.Land',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Crop_relational_fields: Set[str] = {
        'land',
    }
_Crop_fields: Dict['types.CropKeys', PartialModelField] = OrderedDict(
    [
        ('crop_id', {
            'name': 'crop_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('crop_name', {
            'name': 'crop_name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('crop_area', {
            'name': 'crop_area',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('crop_investment', {
            'name': 'crop_investment',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('expected_money_return', {
            'name': 'expected_money_return',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('expected_weight_return', {
            'name': 'expected_weight_return',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('land_id', {
            'name': 'land_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('land', {
            'name': 'land',
            'is_list': False,
            'optional': True,
            'type': 'models.Land',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_CropMaintenance_relational_fields: Set[str] = {
        'land',
    }
_CropMaintenance_fields: Dict['types.CropMaintenanceKeys', PartialModelField] = OrderedDict(
    [
        ('maintenance_id', {
            'name': 'maintenance_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('pesticide_level', {
            'name': 'pesticide_level',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('water_sufficienty', {
            'name': 'water_sufficienty',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('land_id', {
            'name': 'land_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('land', {
            'name': 'land',
            'is_list': False,
            'optional': True,
            'type': 'models.Land',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Finance_relational_fields: Set[str] = {
        'land',
    }
_Finance_fields: Dict['types.FinanceKeys', PartialModelField] = OrderedDict(
    [
        ('financial_id', {
            'name': 'financial_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('investment_amount', {
            'name': 'investment_amount',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('expected_revenue', {
            'name': 'expected_revenue',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('land_id', {
            'name': 'land_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('land', {
            'name': 'land',
            'is_list': False,
            'optional': True,
            'type': 'models.Land',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Weather_relational_fields: Set[str] = {
        'land',
    }
_Weather_fields: Dict['types.WeatherKeys', PartialModelField] = OrderedDict(
    [
        ('weather_id', {
            'name': 'weather_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('temperature', {
            'name': 'temperature',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('humidity', {
            'name': 'humidity',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('rainfall', {
            'name': 'rainfall',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('sunlight', {
            'name': 'sunlight',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('land_id', {
            'name': 'land_id',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('land', {
            'name': 'land',
            'is_list': False,
            'optional': True,
            'type': 'models.Land',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_BusinessPlan_relational_fields: Set[str] = {
        'land',
    }
_BusinessPlan_fields: Dict['types.BusinessPlanKeys', PartialModelField] = OrderedDict(
    [
        ('business_plan_id', {
            'name': 'business_plan_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('executive_summary', {
            'name': 'executive_summary',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('resources', {
            'name': 'resources',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('crops', {
            'name': 'crops',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('weather_considerations', {
            'name': 'weather_considerations',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('soil_maintenance', {
            'name': 'soil_maintenance',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('profit_estimations', {
            'name': 'profit_estimations',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('other_recommendations', {
            'name': 'other_recommendations',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('land_id', {
            'name': 'land_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('land', {
            'name': 'land',
            'is_list': False,
            'optional': True,
            'type': 'models.Land',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(User)
model_rebuild(Land)
model_rebuild(LandStatistic)
model_rebuild(Crop)
model_rebuild(CropMaintenance)
model_rebuild(Finance)
model_rebuild(Weather)
model_rebuild(BusinessPlan)
